{
"version":3,
"file":"module$node_modules$$babylonjs$core$Meshes$subMesh.js",
"lineCount":22,
"mappings":"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",
"sources":["node_modules/@babylonjs/core/Meshes/subMesh.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$babylonjs$core$Meshes$subMesh\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SubMesh = void 0;\n\nvar _buffer = require(\"../Buffers/buffer.js\");\n\nvar _intersectionInfo = require(\"../Collisions/intersectionInfo.js\");\n\nvar _boundingInfo = require(\"../Culling/boundingInfo.js\");\n\nvar _mathFunctions = require(\"../Maths/math.functions.js\");\n\nvar _drawWrapper = require(\"../Materials/drawWrapper.js\");\n\n/**\n * Defines a subdivision inside a mesh\n */\nclass SubMesh {\n  /**\n   * Gets material defines used by the effect associated to the sub mesh\n   */\n  get materialDefines() {\n    var _a;\n\n    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.defines;\n  }\n  /**\n   * Sets material defines used by the effect associated to the sub mesh\n   */\n\n\n  set materialDefines(defines) {\n    var _a;\n\n    const drawWrapper = (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(undefined, true);\n    drawWrapper.defines = defines;\n  }\n  /**\n   * @internal\n   */\n\n\n  _getDrawWrapper(passId, createIfNotExisting = false) {\n    passId = passId !== null && passId !== void 0 ? passId : this._engine.currentRenderPassId;\n    let drawWrapper = this._drawWrappers[passId];\n\n    if (!drawWrapper && createIfNotExisting) {\n      this._drawWrappers[passId] = drawWrapper = new _drawWrapper.DrawWrapper(this._mesh.getScene().getEngine());\n    }\n\n    return drawWrapper;\n  }\n  /**\n   * @internal\n   */\n\n\n  _removeDrawWrapper(passId, disposeWrapper = true) {\n    var _a;\n\n    if (disposeWrapper) {\n      (_a = this._drawWrappers[passId]) === null || _a === void 0 ? void 0 : _a.dispose();\n    }\n\n    this._drawWrappers[passId] = undefined;\n  }\n  /**\n   * Gets associated (main) effect (possibly the effect override if defined)\n   */\n\n\n  get effect() {\n    var _a, _b;\n\n    return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (_b = (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : null;\n  }\n  /** @internal */\n\n\n  get _drawWrapper() {\n    var _a;\n\n    return (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(undefined, true);\n  }\n  /** @internal */\n\n\n  get _drawWrapperOverride() {\n    return this._mainDrawWrapperOverride;\n  }\n  /**\n   * @internal\n   */\n\n\n  _setMainDrawWrapperOverride(wrapper) {\n    this._mainDrawWrapperOverride = wrapper;\n  }\n  /**\n   * Sets associated effect (effect used to render this submesh)\n   * @param effect defines the effect to associate with\n   * @param defines defines the set of defines used to compile this effect\n   * @param materialContext material context associated to the effect\n   * @param resetContext true to reset the draw context\n   */\n\n\n  setEffect(effect, defines = null, materialContext, resetContext = true) {\n    const drawWrapper = this._drawWrapper;\n    drawWrapper.setEffect(effect, defines, resetContext);\n\n    if (materialContext !== undefined) {\n      drawWrapper.materialContext = materialContext;\n    }\n\n    if (!effect) {\n      drawWrapper.defines = null;\n      drawWrapper.materialContext = undefined;\n    }\n  }\n  /**\n   * Resets the draw wrappers cache\n   * @param passId If provided, releases only the draw wrapper corresponding to this render pass id\n   */\n\n\n  resetDrawCache(passId) {\n    if (this._drawWrappers) {\n      if (passId !== undefined) {\n        this._removeDrawWrapper(passId);\n\n        return;\n      } else {\n        for (const drawWrapper of this._drawWrappers) {\n          drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();\n        }\n      }\n    }\n\n    this._drawWrappers = [];\n  }\n  /**\n   * Add a new submesh to a mesh\n   * @param materialIndex defines the material index to use\n   * @param verticesStart defines vertex index start\n   * @param verticesCount defines vertices count\n   * @param indexStart defines index start\n   * @param indexCount defines indices count\n   * @param mesh defines the parent mesh\n   * @param renderingMesh defines an optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @returns the new submesh\n   */\n\n\n  static AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox = true) {\n    return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);\n  }\n  /**\n   * Creates a new submesh\n   * @param materialIndex defines the material index to use\n   * @param verticesStart defines vertex index start\n   * @param verticesCount defines vertices count\n   * @param indexStart defines index start\n   * @param indexCount defines indices count\n   * @param mesh defines the parent mesh\n   * @param renderingMesh defines an optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @param addToMesh defines a boolean indicating that the submesh must be added to the mesh.subMeshes array (true by default)\n   */\n\n\n  constructor(\n  /** the material index to use */\n  materialIndex,\n  /** vertex index start */\n  verticesStart,\n  /** vertices count */\n  verticesCount,\n  /** index start */\n  indexStart,\n  /** indices count */\n  indexCount, mesh, renderingMesh, createBoundingBox = true, addToMesh = true) {\n    this.materialIndex = materialIndex;\n    this.verticesStart = verticesStart;\n    this.verticesCount = verticesCount;\n    this.indexStart = indexStart;\n    this.indexCount = indexCount;\n    this._mainDrawWrapperOverride = null;\n    /** @internal */\n\n    this._linesIndexCount = 0;\n    this._linesIndexBuffer = null;\n    /** @internal */\n\n    this._lastColliderWorldVertices = null;\n    /** @internal */\n\n    this._lastColliderTransformMatrix = null;\n    /** @internal */\n\n    this._wasDispatched = false;\n    /** @internal */\n\n    this._renderId = 0;\n    /** @internal */\n\n    this._alphaIndex = 0;\n    /** @internal */\n\n    this._distanceToCamera = 0;\n    this._currentMaterial = null;\n    this._mesh = mesh;\n    this._renderingMesh = renderingMesh || mesh;\n\n    if (addToMesh) {\n      mesh.subMeshes.push(this);\n    }\n\n    this._engine = this._mesh.getScene().getEngine();\n    this.resetDrawCache();\n    this._trianglePlanes = [];\n    this._id = mesh.subMeshes.length - 1;\n\n    if (createBoundingBox) {\n      this.refreshBoundingInfo();\n      mesh.computeWorldMatrix(true);\n    }\n  }\n  /**\n   * Returns true if this submesh covers the entire parent mesh\n   * @ignorenaming\n   */\n  // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\n  get IsGlobal() {\n    return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();\n  }\n  /**\n   * Returns the submesh BoundingInfo object\n   * @returns current bounding info (or mesh's one if the submesh is global)\n   */\n\n\n  getBoundingInfo() {\n    if (this.IsGlobal) {\n      return this._mesh.getBoundingInfo();\n    }\n\n    return this._boundingInfo;\n  }\n  /**\n   * Sets the submesh BoundingInfo\n   * @param boundingInfo defines the new bounding info to use\n   * @returns the SubMesh\n   */\n\n\n  setBoundingInfo(boundingInfo) {\n    this._boundingInfo = boundingInfo;\n    return this;\n  }\n  /**\n   * Returns the mesh of the current submesh\n   * @returns the parent mesh\n   */\n\n\n  getMesh() {\n    return this._mesh;\n  }\n  /**\n   * Returns the rendering mesh of the submesh\n   * @returns the rendering mesh (could be different from parent mesh)\n   */\n\n\n  getRenderingMesh() {\n    return this._renderingMesh;\n  }\n  /**\n   * Returns the replacement mesh of the submesh\n   * @returns the replacement mesh (could be different from parent mesh)\n   */\n\n\n  getReplacementMesh() {\n    return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n  }\n  /**\n   * Returns the effective mesh of the submesh\n   * @returns the effective mesh (could be different from parent mesh)\n   */\n\n\n  getEffectiveMesh() {\n    const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;\n    return replacementMesh ? replacementMesh : this._renderingMesh;\n  }\n  /**\n   * Returns the submesh material\n   * @param getDefaultMaterial Defines whether or not to get the default material if nothing has been defined.\n   * @returns null or the current material\n   */\n\n\n  getMaterial(getDefaultMaterial = true) {\n    var _a;\n\n    const rootMaterial = (_a = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) !== null && _a !== void 0 ? _a : this._renderingMesh.material;\n\n    if (!rootMaterial) {\n      return getDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;\n    } else if (this._isMultiMaterial(rootMaterial)) {\n      const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);\n\n      if (this._currentMaterial !== effectiveMaterial) {\n        this._currentMaterial = effectiveMaterial;\n        this.resetDrawCache();\n      }\n\n      return effectiveMaterial;\n    }\n\n    return rootMaterial;\n  }\n\n  _isMultiMaterial(material) {\n    return material.getSubMaterial !== undefined;\n  } // Methods\n\n  /**\n   * Sets a new updated BoundingInfo object to the submesh\n   * @param data defines an optional position array to use to determine the bounding info\n   * @returns the SubMesh\n   */\n\n\n  refreshBoundingInfo(data = null) {\n    this._lastColliderWorldVertices = null;\n\n    if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {\n      return this;\n    }\n\n    if (!data) {\n      data = this._renderingMesh.getVerticesData(_buffer.VertexBuffer.PositionKind);\n    }\n\n    if (!data) {\n      this._boundingInfo = this._mesh.getBoundingInfo();\n      return this;\n    }\n\n    const indices = this._renderingMesh.getIndices();\n\n    let extend; //is this the only submesh?\n\n    if (this.indexStart === 0 && this.indexCount === indices.length) {\n      const boundingInfo = this._renderingMesh.getBoundingInfo(); //the rendering mesh's bounding info can be used, it is the standard submesh for all indices.\n\n\n      extend = {\n        minimum: boundingInfo.minimum.clone(),\n        maximum: boundingInfo.maximum.clone()\n      };\n    } else {\n      extend = (0, _mathFunctions.extractMinAndMaxIndexed)(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);\n    }\n\n    if (this._boundingInfo) {\n      this._boundingInfo.reConstruct(extend.minimum, extend.maximum);\n    } else {\n      this._boundingInfo = new _boundingInfo.BoundingInfo(extend.minimum, extend.maximum);\n    }\n\n    return this;\n  }\n  /**\n   * @internal\n   */\n\n\n  _checkCollision(collider) {\n    const boundingInfo = this.getBoundingInfo();\n    return boundingInfo._checkCollision(collider);\n  }\n  /**\n   * Updates the submesh BoundingInfo\n   * @param world defines the world matrix to use to update the bounding info\n   * @returns the submesh\n   */\n\n\n  updateBoundingInfo(world) {\n    let boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      this.refreshBoundingInfo();\n      boundingInfo = this.getBoundingInfo();\n    }\n\n    if (boundingInfo) {\n      boundingInfo.update(world);\n    }\n\n    return this;\n  }\n  /**\n   * True is the submesh bounding box intersects the frustum defined by the passed array of planes.\n   * @param frustumPlanes defines the frustum planes\n   * @returns true if the submesh is intersecting with the frustum\n   */\n\n\n  isInFrustum(frustumPlanes) {\n    const boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      return false;\n    }\n\n    return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);\n  }\n  /**\n   * True is the submesh bounding box is completely inside the frustum defined by the passed array of planes\n   * @param frustumPlanes defines the frustum planes\n   * @returns true if the submesh is inside the frustum\n   */\n\n\n  isCompletelyInFrustum(frustumPlanes) {\n    const boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      return false;\n    }\n\n    return boundingInfo.isCompletelyInFrustum(frustumPlanes);\n  }\n  /**\n   * Renders the submesh\n   * @param enableAlphaMode defines if alpha needs to be used\n   * @returns the submesh\n   */\n\n\n  render(enableAlphaMode) {\n    this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : undefined);\n\n    return this;\n  }\n  /**\n   * @internal\n   */\n\n\n  _getLinesIndexBuffer(indices, engine) {\n    if (!this._linesIndexBuffer) {\n      const linesIndices = [];\n\n      for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {\n        linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);\n      }\n\n      this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);\n      this._linesIndexCount = linesIndices.length;\n    }\n\n    return this._linesIndexBuffer;\n  }\n  /**\n   * Checks if the submesh intersects with a ray\n   * @param ray defines the ray to test\n   * @returns true is the passed ray intersects the submesh bounding box\n   */\n\n\n  canIntersects(ray) {\n    const boundingInfo = this.getBoundingInfo();\n\n    if (!boundingInfo) {\n      return false;\n    }\n\n    return ray.intersectsBox(boundingInfo.boundingBox);\n  }\n  /**\n   * Intersects current submesh with a ray\n   * @param ray defines the ray to test\n   * @param positions defines mesh's positions array\n   * @param indices defines mesh's indices array\n   * @param fastCheck defines if the first intersection will be used (and not the closest)\n   * @param trianglePredicate defines an optional predicate used to select faces when a mesh intersection is detected\n   * @returns intersection info or null if no intersection\n   */\n\n\n  intersects(ray, positions, indices, fastCheck, trianglePredicate) {\n    const material = this.getMaterial();\n\n    if (!material) {\n      return null;\n    }\n\n    let step = 3;\n    let checkStopper = false;\n\n    switch (material.fillMode) {\n      case 3:\n      case 5:\n      case 6:\n      case 8:\n        return null;\n\n      case 7:\n        step = 1;\n        checkStopper = true;\n        break;\n\n      default:\n        break;\n    } // LineMesh first as it's also a Mesh...\n\n\n    if (material.fillMode === 4) {\n      // Check if mesh is unindexed\n      if (!indices.length) {\n        return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n      }\n\n      return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);\n    } else {\n      // Check if mesh is unindexed\n      if (!indices.length && this._mesh._unIndexed) {\n        return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);\n      }\n\n      return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);\n    }\n  }\n  /**\n   * @internal\n   */\n\n\n  _intersectLines(ray, positions, indices, intersectionThreshold, fastCheck) {\n    let intersectInfo = null; // Line test\n\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {\n      const p0 = positions[indices[index]];\n      const p1 = positions[indices[index + 1]];\n      const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\n\n      if (length < 0) {\n        continue;\n      }\n\n      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\n        intersectInfo = new _intersectionInfo.IntersectionInfo(null, null, length);\n        intersectInfo.faceId = index / 2;\n\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n\n    return intersectInfo;\n  }\n  /**\n   * @internal\n   */\n\n\n  _intersectUnIndexedLines(ray, positions, indices, intersectionThreshold, fastCheck) {\n    let intersectInfo = null; // Line test\n\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {\n      const p0 = positions[index];\n      const p1 = positions[index + 1];\n      const length = ray.intersectionSegment(p0, p1, intersectionThreshold);\n\n      if (length < 0) {\n        continue;\n      }\n\n      if (fastCheck || !intersectInfo || length < intersectInfo.distance) {\n        intersectInfo = new _intersectionInfo.IntersectionInfo(null, null, length);\n        intersectInfo.faceId = index / 2;\n\n        if (fastCheck) {\n          break;\n        }\n      }\n    }\n\n    return intersectInfo;\n  }\n  /**\n   * @internal\n   */\n\n\n  _intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {\n    let intersectInfo = null; // Triangles test\n\n    let faceId = -1;\n\n    for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {\n      faceId++;\n      const indexA = indices[index];\n      const indexB = indices[index + 1];\n      const indexC = indices[index + 2];\n\n      if (checkStopper && indexC === 0xffffffff) {\n        index += 2;\n        continue;\n      }\n\n      const p0 = positions[indexA];\n      const p1 = positions[indexB];\n      const p2 = positions[indexC]; // stay defensive and don't check against undefined positions.\n\n      if (!p0 || !p1 || !p2) {\n        continue;\n      }\n\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {\n        continue;\n      }\n\n      const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = faceId;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    return intersectInfo;\n  }\n  /**\n   * @internal\n   */\n\n\n  _intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate) {\n    let intersectInfo = null; // Triangles test\n\n    for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {\n      const p0 = positions[index];\n      const p1 = positions[index + 1];\n      const p2 = positions[index + 2];\n\n      if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {\n        continue;\n      }\n\n      const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);\n\n      if (currentIntersectInfo) {\n        if (currentIntersectInfo.distance < 0) {\n          continue;\n        }\n\n        if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {\n          intersectInfo = currentIntersectInfo;\n          intersectInfo.faceId = index / 3;\n\n          if (fastCheck) {\n            break;\n          }\n        }\n      }\n    }\n\n    return intersectInfo;\n  }\n  /** @internal */\n\n\n  _rebuild() {\n    if (this._linesIndexBuffer) {\n      this._linesIndexBuffer = null;\n    }\n  } // Clone\n\n  /**\n   * Creates a new submesh from the passed mesh\n   * @param newMesh defines the new hosting mesh\n   * @param newRenderingMesh defines an optional rendering mesh\n   * @returns the new submesh\n   */\n\n\n  clone(newMesh, newRenderingMesh) {\n    const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);\n\n    if (!this.IsGlobal) {\n      const boundingInfo = this.getBoundingInfo();\n\n      if (!boundingInfo) {\n        return result;\n      }\n\n      result._boundingInfo = new _boundingInfo.BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);\n    }\n\n    return result;\n  } // Dispose\n\n  /**\n   * Release associated resources\n   */\n\n\n  dispose() {\n    if (this._linesIndexBuffer) {\n      this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);\n\n      this._linesIndexBuffer = null;\n    } // Remove from mesh\n\n\n    const index = this._mesh.subMeshes.indexOf(this);\n\n    this._mesh.subMeshes.splice(index, 1);\n\n    this.resetDrawCache();\n  }\n  /**\n   * Gets the class name\n   * @returns the string \"SubMesh\".\n   */\n\n\n  getClassName() {\n    return \"SubMesh\";\n  } // Statics\n\n  /**\n   * Creates a new submesh from indices data\n   * @param materialIndex the index of the main mesh material\n   * @param startIndex the index where to start the copy in the mesh indices array\n   * @param indexCount the number of indices to copy then from the startIndex\n   * @param mesh the main mesh to create the submesh from\n   * @param renderingMesh the optional rendering mesh\n   * @param createBoundingBox defines if bounding box should be created for this submesh\n   * @returns a new submesh\n   */\n\n\n  static CreateFromIndices(materialIndex, startIndex, indexCount, mesh, renderingMesh, createBoundingBox = true) {\n    let minVertexIndex = Number.MAX_VALUE;\n    let maxVertexIndex = -Number.MAX_VALUE;\n    const whatWillRender = renderingMesh || mesh;\n    const indices = whatWillRender.getIndices();\n\n    for (let index = startIndex; index < startIndex + indexCount; index++) {\n      const vertexIndex = indices[index];\n\n      if (vertexIndex < minVertexIndex) {\n        minVertexIndex = vertexIndex;\n      }\n\n      if (vertexIndex > maxVertexIndex) {\n        maxVertexIndex = vertexIndex;\n      }\n    }\n\n    return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);\n  }\n\n}\n\nexports.SubMesh = SubMesh;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","SubMesh","_buffer","_intersectionInfo","_boundingInfo","_mathFunctions","_drawWrapper","_a","_mainDrawWrapperOverride","defines","_getDrawWrapper","drawWrapper","undefined","passId","createIfNotExisting","_engine","currentRenderPassId","_drawWrappers","DrawWrapper","_mesh","getScene","getEngine","_removeDrawWrapper","disposeWrapper","dispose","_b","effect","_setMainDrawWrapperOverride","wrapper","setEffect","materialContext","resetContext","resetDrawCache","AddToMesh","materialIndex","verticesStart","verticesCount","indexStart","indexCount","mesh","renderingMesh","createBoundingBox","constructor","addToMesh","_linesIndexCount","_lastColliderTransformMatrix","_lastColliderWorldVertices","_linesIndexBuffer","_wasDispatched","_distanceToCamera","_alphaIndex","_renderId","_currentMaterial","_renderingMesh","subMeshes","push","_trianglePlanes","_id","length","refreshBoundingInfo","computeWorldMatrix","getTotalVertices","getTotalIndices","getBoundingInfo","IsGlobal","setBoundingInfo","boundingInfo","getMesh","getRenderingMesh","getReplacementMesh","_internalAbstractMeshDataInfo","_actAsRegularMesh","getEffectiveMesh","replacementMesh","getMaterial","getDefaultMaterial","rootMaterial","getMaterialForRenderPass","material","_isMultiMaterial","effectiveMaterial","getSubMaterial","defaultMaterial","data","geometry","getVerticesData","VertexBuffer","PositionKind","indices","getIndices","extend","minimum","clone","maximum","extractMinAndMaxIndexed","boundingBias","reConstruct","BoundingInfo","_checkCollision","collider","updateBoundingInfo","world","update","isInFrustum","frustumPlanes","cullingStrategy","isCompletelyInFrustum","render","enableAlphaMode","_getLinesIndexBuffer","engine","linesIndices","index","createIndexBuffer","canIntersects","ray","intersectsBox","boundingBox","intersects","positions","fastCheck","trianglePredicate","step","checkStopper","fillMode","_intersectLines","intersectionThreshold","_intersectUnIndexedLines","_unIndexed","_intersectUnIndexedTriangles","_intersectTriangles","intersectInfo","intersectionSegment","p0","p1","distance","IntersectionInfo","faceId","indexA","indexB","indexC","p2","currentIntersectInfo","intersectsTriangle","_rebuild","newMesh","newRenderingMesh","result","_releaseBuffer","indexOf","splice","getClassName","CreateFromIndices","startIndex","minVertexIndex","Number","MAX_VALUE","maxVertexIndex","vertexIndex"]
}
