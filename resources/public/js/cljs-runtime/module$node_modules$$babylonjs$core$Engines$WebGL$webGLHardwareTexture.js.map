{
"version":3,
"file":"module$node_modules$$babylonjs$core$Engines$WebGL$webGLHardwareTexture.js",
"lineCount":3,
"mappings":"AAAAA,cAAA,CAAA,sEAAA,CAA2F,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGnIC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,oBAAR,CAA+B,IAAK,EAGpC,MAAMA,qBAAN,CACM,sBAAqB,EAAA,CACvB,MAAO,KAAKC,CAAAA,aADW,CAIzBC,WAAW,CAACC,eAAA,CAAkB,IAAnB,CAAyBC,OAAzB,CAAkC,CAG3C,IAAKC,CAAAA,kBAAL,CAA0B,IAC1B,KAAKC,CAAAA,QAAL,CAAgBF,OAEhB,IAAI,CAACD,eAAL,GACEA,eAEI,CAFcC,OAAQG,CAAAA,aAAR,EAEd,CAAA,CAACJ,eAHP,EAII,KAAUK,MAAJ,CAAU,gCAAV,CAAN;AAIJ,IAAKC,CAAAA,GAAL,CAASN,eAAT,CAd2C,CAiB7CO,QAAQ,EAAG,EAEXD,GAAG,CAACE,eAAD,CAAkB,CACnB,IAAKV,CAAAA,aAAL,CAAqBU,eADF,CAIrBC,KAAK,EAAG,CAEN,IAAKP,CAAAA,kBAAL,CADA,IAAKJ,CAAAA,aACL,CADqB,IADf,CAKRY,mBAAmB,CAACC,MAAD,CAAS,CACrB,IAAKT,CAAAA,kBAAV,GACE,IAAKA,CAAAA,kBADP,CAC4B,EAD5B,CAIA,KAAKA,CAAAA,kBAAmBU,CAAAA,IAAxB,CAA6BD,MAA7B,CAL0B,CAQ5BE,wBAAwB,EAAG,CACzB,GAAI,IAAKX,CAAAA,kBAAT,CAA6B,CAC3B,IAAK,MAAMS,MAAX,GAAqB,KAAKT,CAAAA,kBAA1B,CACE,IAAKC,CAAAA,QAASW,CAAAA,kBAAd,CAAiCH,MAAjC,CAGF,KAAKT,CAAAA,kBAAL,CAA0B,IALC,CADJ,CAU3Ba,OAAO,EAAG,CACR,IAAKF,CAAAA,wBAAL,EAEI,KAAKf,CAAAA,aAAT;AACE,IAAKK,CAAAA,QAASa,CAAAA,aAAd,CAA4B,IAAKlB,CAAAA,aAAjC,CAGF,KAAKW,CAAAA,KAAL,EAPQ,CAnDZ,CA+DAhB,OAAQI,CAAAA,oBAAR,CAA+BA,oBAxEoG;",
"sources":["node_modules/@babylonjs/core/Engines/WebGL/webGLHardwareTexture.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$babylonjs$core$Engines$WebGL$webGLHardwareTexture\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.WebGLHardwareTexture = void 0;\n\n/** @internal */\nclass WebGLHardwareTexture {\n  get underlyingResource() {\n    return this._webGLTexture;\n  }\n\n  constructor(existingTexture = null, context) {\n    // There can be multiple buffers for a single WebGL texture because different layers of a 2DArrayTexture / 3DTexture\n    // or different faces of a cube texture can be bound to different render targets at the same time.\n    this._MSAARenderBuffers = null;\n    this._context = context;\n\n    if (!existingTexture) {\n      existingTexture = context.createTexture();\n\n      if (!existingTexture) {\n        throw new Error(\"Unable to create webGL texture\");\n      }\n    }\n\n    this.set(existingTexture);\n  }\n\n  setUsage() {}\n\n  set(hardwareTexture) {\n    this._webGLTexture = hardwareTexture;\n  }\n\n  reset() {\n    this._webGLTexture = null;\n    this._MSAARenderBuffers = null;\n  }\n\n  addMSAARenderBuffer(buffer) {\n    if (!this._MSAARenderBuffers) {\n      this._MSAARenderBuffers = [];\n    }\n\n    this._MSAARenderBuffers.push(buffer);\n  }\n\n  releaseMSAARenderBuffers() {\n    if (this._MSAARenderBuffers) {\n      for (const buffer of this._MSAARenderBuffers) {\n        this._context.deleteRenderbuffer(buffer);\n      }\n\n      this._MSAARenderBuffers = null;\n    }\n  }\n\n  release() {\n    this.releaseMSAARenderBuffers();\n\n    if (this._webGLTexture) {\n      this._context.deleteTexture(this._webGLTexture);\n    }\n\n    this.reset();\n  }\n\n}\n\nexports.WebGLHardwareTexture = WebGLHardwareTexture;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","WebGLHardwareTexture","_webGLTexture","constructor","existingTexture","context","_MSAARenderBuffers","_context","createTexture","Error","set","setUsage","hardwareTexture","reset","addMSAARenderBuffer","buffer","push","releaseMSAARenderBuffers","deleteRenderbuffer","release","deleteTexture"]
}
