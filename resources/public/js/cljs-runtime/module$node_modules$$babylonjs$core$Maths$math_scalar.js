shadow$provide.module$node_modules$$babylonjs$core$Maths$math_scalar=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Scalar=void 0;class Scalar{static WithinEpsilon(a,b,epsilon=1.401298E-45){return Math.abs(a-b)<=epsilon}static ToHex(i){const str=i.toString(16);return 15>=i?("0"+str).toUpperCase():str.toUpperCase()}static Sign(value){value=+value;return 0===value||isNaN(value)?value:0<value?1:-1}static Clamp(value,min=0,max=1){return Math.min(max,
Math.max(min,value))}static Log2(value){return Math.log(value)*Math.LOG2E}static ILog2(value){if(Math.log2)return Math.floor(Math.log2(value));if(0>value)return NaN;if(0===value)return-Infinity;let n=0;if(1>value){for(;1>value;)n++,value*=2;n=-n}else if(1<value)for(;1<value;)n++,value=Math.floor(value/2);return n}static Repeat(value,length){return value-Math.floor(value/length)*length}static Normalize(value,min,max){return(value-min)/(max-min)}static Denormalize(normalized,min,max){return normalized*
(max-min)+min}static DeltaAngle(current,target){current=Scalar.Repeat(target-current,360);180<current&&(current-=360);return current}static PingPong(tx,length){tx=Scalar.Repeat(tx,2*length);return length-Math.abs(tx-length)}static SmoothStep(from,to,tx){tx=Scalar.Clamp(tx);tx=-2*tx*tx*tx+3*tx*tx;return to*tx+from*(1-tx)}static MoveTowards(current,target,maxDelta){return Math.abs(target-current)<=maxDelta?target:current+Scalar.Sign(target-current)*maxDelta}static MoveTowardsAngle(current,target,maxDelta){const num=
Scalar.DeltaAngle(current,target);-maxDelta<num&&num<maxDelta?current=target:(target=current+num,current=Scalar.MoveTowards(current,target,maxDelta));return current}static Lerp(start,end,amount){return start+(end-start)*amount}static LerpAngle(start,end,amount){end=Scalar.Repeat(end-start,360);180<end&&(end-=360);return start+end*Scalar.Clamp(amount)}static InverseLerp(a,b,value){return a!=b?Scalar.Clamp((value-a)/(b-a)):0}static Hermite(value1,tangent1,value2,tangent2,amount){const squared=amount*
amount,cubed=amount*squared;return value1*(2*cubed-3*squared+1)+value2*(-2*cubed+3*squared)+tangent1*(cubed-2*squared+amount)+tangent2*(cubed-squared)}static Hermite1stDerivative(value1,tangent1,value2,tangent2,time){const t2=time*time;return 6*(t2-time)*value1+(3*t2-4*time+1)*tangent1+6*(-t2+time)*value2+(3*t2-2*time)*tangent2}static RandomRange(min,max){return min===max?min:Math.random()*(max-min)+min}static RangeToPercent(number,min,max){return(number-min)/(max-min)}static PercentToRange(percent,
min,max){return(max-min)*percent+min}static NormalizeRadians(angle){return angle-=Scalar.TwoPi*Math.floor((angle+Math.PI)/Scalar.TwoPi)}static HCF(a,b){a%=b;return 0===a?b:Scalar.HCF(b,a)}}exports.Scalar=Scalar;Scalar.TwoPi=2*Math.PI}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Maths$math_scalar.js.map
