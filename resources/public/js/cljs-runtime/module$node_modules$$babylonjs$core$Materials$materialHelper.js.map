{
"version":3,
"file":"module$node_modules$$babylonjs$core$Materials$materialHelper.js",
"lineCount":38,
"mappings":"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",
"sources":["node_modules/@babylonjs/core/Materials/materialHelper.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$babylonjs$core$Materials$materialHelper\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MaterialHelper = void 0;\n\nvar _logger = require(\"../Misc/logger.js\");\n\nvar _camera = require(\"../Cameras/camera.js\");\n\nvar _scene = require(\"../scene.js\");\n\nvar _engineStore = require(\"../Engines/engineStore.js\");\n\nvar _buffer = require(\"../Buffers/buffer.js\");\n\nvar _lightConstants = require(\"../Lights/lightConstants.js\");\n\nvar _mathColor = require(\"../Maths/math.color.js\");\n\nvar _clipPlaneMaterialHelper = require(\"./clipPlaneMaterialHelper.js\");\n\n/**\n * \"Static Class\" containing the most commonly used helper while dealing with material for rendering purpose.\n *\n * It contains the basic tools to help defining defines, binding uniform for the common part of the materials.\n *\n * This works by convention in BabylonJS but is meant to be use only with shader following the in place naming rules and conventions.\n */\nclass MaterialHelper {\n  /**\n   * Binds the scene's uniform buffer to the effect.\n   * @param effect defines the effect to bind to the scene uniform buffer\n   * @param sceneUbo defines the uniform buffer storing scene data\n   */\n  static BindSceneUniformBuffer(effect, sceneUbo) {\n    sceneUbo.bindToEffect(effect, \"Scene\");\n  }\n  /**\n   * Helps preparing the defines values about the UVs in used in the effect.\n   * UVs are shared as much as we can across channels in the shaders.\n   * @param texture The texture we are preparing the UVs for\n   * @param defines The defines to update\n   * @param key The channel key \"diffuse\", \"specular\"... used in the shader\n   */\n\n\n  static PrepareDefinesForMergedUV(texture, defines, key) {\n    defines._needUVs = true;\n    defines[key] = true;\n\n    if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {\n      defines[key + \"DIRECTUV\"] = texture.coordinatesIndex + 1;\n      defines[\"MAINUV\" + (texture.coordinatesIndex + 1)] = true;\n    } else {\n      defines[key + \"DIRECTUV\"] = 0;\n    }\n  }\n  /**\n   * Binds a texture matrix value to its corresponding uniform\n   * @param texture The texture to bind the matrix for\n   * @param uniformBuffer The uniform buffer receiving the data\n   * @param key The channel key \"diffuse\", \"specular\"... used in the shader\n   */\n\n\n  static BindTextureMatrix(texture, uniformBuffer, key) {\n    const matrix = texture.getTextureMatrix();\n    uniformBuffer.updateMatrix(key + \"Matrix\", matrix);\n  }\n  /**\n   * Gets the current status of the fog (should it be enabled?)\n   * @param mesh defines the mesh to evaluate for fog support\n   * @param scene defines the hosting scene\n   * @returns true if fog must be enabled\n   */\n\n\n  static GetFogState(mesh, scene) {\n    return scene.fogEnabled && mesh.applyFog && scene.fogMode !== _scene.Scene.FOGMODE_NONE;\n  }\n  /**\n   * Helper used to prepare the list of defines associated with misc. values for shader compilation\n   * @param mesh defines the current mesh\n   * @param scene defines the current scene\n   * @param useLogarithmicDepth defines if logarithmic depth has to be turned on\n   * @param pointsCloud defines if point cloud rendering has to be turned on\n   * @param fogEnabled defines if fog has to be turned on\n   * @param alphaTest defines if alpha testing has to be turned on\n   * @param defines defines the current list of defines\n   */\n\n\n  static PrepareDefinesForMisc(mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines) {\n    if (defines._areMiscDirty) {\n      defines[\"LOGARITHMICDEPTH\"] = useLogarithmicDepth;\n      defines[\"POINTSIZE\"] = pointsCloud;\n      defines[\"FOG\"] = fogEnabled && this.GetFogState(mesh, scene);\n      defines[\"NONUNIFORMSCALING\"] = mesh.nonUniformScaling;\n      defines[\"ALPHATEST\"] = alphaTest;\n    }\n  }\n  /**\n   * Helper used to prepare the defines relative to the active camera\n   * @param scene defines the current scene\n   * @param defines specifies the list of active defines\n   * @returns true if the defines have been updated, else false\n   */\n\n\n  static PrepareDefinesForCamera(scene, defines) {\n    let changed = false;\n\n    if (scene.activeCamera) {\n      const wasOrtho = defines[\"CAMERA_ORTHOGRAPHIC\"] ? 1 : 0;\n      const wasPersp = defines[\"CAMERA_PERSPECTIVE\"] ? 1 : 0;\n      const isOrtho = scene.activeCamera.mode === _camera.Camera.ORTHOGRAPHIC_CAMERA ? 1 : 0;\n      const isPersp = scene.activeCamera.mode === _camera.Camera.PERSPECTIVE_CAMERA ? 1 : 0;\n\n      if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {\n        defines[\"CAMERA_ORTHOGRAPHIC\"] = isOrtho === 1;\n        defines[\"CAMERA_PERSPECTIVE\"] = isPersp === 1;\n        changed = true;\n      }\n    }\n\n    return changed;\n  }\n  /**\n   * Helper used to prepare the list of defines associated with frame values for shader compilation\n   * @param scene defines the current scene\n   * @param engine defines the current engine\n   * @param material defines the material we are compiling the shader for\n   * @param defines specifies the list of active defines\n   * @param useInstances defines if instances have to be turned on\n   * @param useClipPlane defines if clip plane have to be turned on\n   * @param useThinInstances defines if thin instances have to be turned on\n   */\n\n\n  static PrepareDefinesForFrameBoundValues(scene, engine, material, defines, useInstances, useClipPlane = null, useThinInstances = false) {\n    let changed = MaterialHelper.PrepareDefinesForCamera(scene, defines);\n\n    if (useClipPlane !== false) {\n      changed = (0, _clipPlaneMaterialHelper.prepareDefinesForClipPlanes)(material, scene, defines);\n    }\n\n    if (defines[\"DEPTHPREPASS\"] !== !engine.getColorWrite()) {\n      defines[\"DEPTHPREPASS\"] = !defines[\"DEPTHPREPASS\"];\n      changed = true;\n    }\n\n    if (defines[\"INSTANCES\"] !== useInstances) {\n      defines[\"INSTANCES\"] = useInstances;\n      changed = true;\n    }\n\n    if (defines[\"THIN_INSTANCES\"] !== useThinInstances) {\n      defines[\"THIN_INSTANCES\"] = useThinInstances;\n      changed = true;\n    }\n\n    if (changed) {\n      defines.markAsUnprocessed();\n    }\n  }\n  /**\n   * Prepares the defines for bones\n   * @param mesh The mesh containing the geometry data we will draw\n   * @param defines The defines to update\n   */\n\n\n  static PrepareDefinesForBones(mesh, defines) {\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      defines[\"NUM_BONE_INFLUENCERS\"] = mesh.numBoneInfluencers;\n      const materialSupportsBoneTexture = defines[\"BONETEXTURE\"] !== undefined;\n\n      if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {\n        defines[\"BONETEXTURE\"] = true;\n      } else {\n        defines[\"BonesPerMesh\"] = mesh.skeleton.bones.length + 1;\n        defines[\"BONETEXTURE\"] = materialSupportsBoneTexture ? false : undefined;\n        const prePassRenderer = mesh.getScene().prePassRenderer;\n\n        if (prePassRenderer && prePassRenderer.enabled) {\n          const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;\n          defines[\"BONES_VELOCITY_ENABLED\"] = nonExcluded;\n        }\n      }\n    } else {\n      defines[\"NUM_BONE_INFLUENCERS\"] = 0;\n      defines[\"BonesPerMesh\"] = 0;\n\n      if (defines[\"BONETEXTURE\"] !== undefined) {\n        defines[\"BONETEXTURE\"] = false;\n      }\n    }\n  }\n  /**\n   * Prepares the defines for morph targets\n   * @param mesh The mesh containing the geometry data we will draw\n   * @param defines The defines to update\n   */\n\n\n  static PrepareDefinesForMorphTargets(mesh, defines) {\n    const manager = mesh.morphTargetManager;\n\n    if (manager) {\n      defines[\"MORPHTARGETS_UV\"] = manager.supportsUVs && defines[\"UV1\"];\n      defines[\"MORPHTARGETS_TANGENT\"] = manager.supportsTangents && defines[\"TANGENT\"];\n      defines[\"MORPHTARGETS_NORMAL\"] = manager.supportsNormals && defines[\"NORMAL\"];\n      defines[\"MORPHTARGETS\"] = manager.numInfluencers > 0;\n      defines[\"NUM_MORPH_INFLUENCERS\"] = manager.numInfluencers;\n      defines[\"MORPHTARGETS_TEXTURE\"] = manager.isUsingTextureForTargets;\n    } else {\n      defines[\"MORPHTARGETS_UV\"] = false;\n      defines[\"MORPHTARGETS_TANGENT\"] = false;\n      defines[\"MORPHTARGETS_NORMAL\"] = false;\n      defines[\"MORPHTARGETS\"] = false;\n      defines[\"NUM_MORPH_INFLUENCERS\"] = 0;\n    }\n  }\n  /**\n   * Prepares the defines for baked vertex animation\n   * @param mesh The mesh containing the geometry data we will draw\n   * @param defines The defines to update\n   */\n\n\n  static PrepareDefinesForBakedVertexAnimation(mesh, defines) {\n    const manager = mesh.bakedVertexAnimationManager;\n    defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] = manager && manager.isEnabled ? true : false;\n  }\n  /**\n   * Prepares the defines used in the shader depending on the attributes data available in the mesh\n   * @param mesh The mesh containing the geometry data we will draw\n   * @param defines The defines to update\n   * @param useVertexColor Precise whether vertex colors should be used or not (override mesh info)\n   * @param useBones Precise whether bones should be used or not (override mesh info)\n   * @param useMorphTargets Precise whether morph targets should be used or not (override mesh info)\n   * @param useVertexAlpha Precise whether vertex alpha should be used or not (override mesh info)\n   * @param useBakedVertexAnimation Precise whether baked vertex animation should be used or not (override mesh info)\n   * @returns false if defines are considered not dirty and have not been checked\n   */\n\n\n  static PrepareDefinesForAttributes(mesh, defines, useVertexColor, useBones, useMorphTargets = false, useVertexAlpha = true, useBakedVertexAnimation = true) {\n    if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {\n      return false;\n    }\n\n    defines._normals = defines._needNormals;\n    defines._uvs = defines._needUVs;\n    defines[\"NORMAL\"] = defines._needNormals && mesh.isVerticesDataPresent(_buffer.VertexBuffer.NormalKind);\n\n    if (defines._needNormals && mesh.isVerticesDataPresent(_buffer.VertexBuffer.TangentKind)) {\n      defines[\"TANGENT\"] = true;\n    }\n\n    for (let i = 1; i <= 6; ++i) {\n      defines[\"UV\" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? \"\" : i}`) : false;\n    }\n\n    if (useVertexColor) {\n      const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(_buffer.VertexBuffer.ColorKind);\n      defines[\"VERTEXCOLOR\"] = hasVertexColors;\n      defines[\"VERTEXALPHA\"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;\n    }\n\n    if (mesh.isVerticesDataPresent(_buffer.VertexBuffer.ColorInstanceKind) && (mesh.hasInstances || mesh.hasThinInstances)) {\n      defines[\"INSTANCESCOLOR\"] = true;\n    }\n\n    if (useBones) {\n      this.PrepareDefinesForBones(mesh, defines);\n    }\n\n    if (useMorphTargets) {\n      this.PrepareDefinesForMorphTargets(mesh, defines);\n    }\n\n    if (useBakedVertexAnimation) {\n      this.PrepareDefinesForBakedVertexAnimation(mesh, defines);\n    }\n\n    return true;\n  }\n  /**\n   * Prepares the defines related to multiview\n   * @param scene The scene we are intending to draw\n   * @param defines The defines to update\n   */\n\n\n  static PrepareDefinesForMultiview(scene, defines) {\n    if (scene.activeCamera) {\n      const previousMultiview = defines.MULTIVIEW;\n      defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;\n\n      if (defines.MULTIVIEW != previousMultiview) {\n        defines.markAsUnprocessed();\n      }\n    }\n  }\n  /**\n   * Prepares the defines related to order independant transparency\n   * @param scene The scene we are intending to draw\n   * @param defines The defines to update\n   * @param needAlphaBlending Determines if the material needs alpha blending\n   */\n\n\n  static PrepareDefinesForOIT(scene, defines, needAlphaBlending) {\n    const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;\n    const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;\n    defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;\n    defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;\n\n    if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {\n      defines.markAsUnprocessed();\n    }\n  }\n  /**\n   * Prepares the defines related to the prepass\n   * @param scene The scene we are intending to draw\n   * @param defines The defines to update\n   * @param canRenderToMRT Indicates if this material renders to several textures in the prepass\n   */\n\n\n  static PrepareDefinesForPrePass(scene, defines, canRenderToMRT) {\n    const previousPrePass = defines.PREPASS;\n\n    if (!defines._arePrePassDirty) {\n      return;\n    }\n\n    const texturesList = [{\n      type: 1,\n      define: \"PREPASS_POSITION\",\n      index: \"PREPASS_POSITION_INDEX\"\n    }, {\n      type: 2,\n      define: \"PREPASS_VELOCITY\",\n      index: \"PREPASS_VELOCITY_INDEX\"\n    }, {\n      type: 3,\n      define: \"PREPASS_REFLECTIVITY\",\n      index: \"PREPASS_REFLECTIVITY_INDEX\"\n    }, {\n      type: 0,\n      define: \"PREPASS_IRRADIANCE\",\n      index: \"PREPASS_IRRADIANCE_INDEX\"\n    }, {\n      type: 7,\n      define: \"PREPASS_ALBEDO_SQRT\",\n      index: \"PREPASS_ALBEDO_SQRT_INDEX\"\n    }, {\n      type: 5,\n      define: \"PREPASS_DEPTH\",\n      index: \"PREPASS_DEPTH_INDEX\"\n    }, {\n      type: 6,\n      define: \"PREPASS_NORMAL\",\n      index: \"PREPASS_NORMAL_INDEX\"\n    }];\n\n    if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {\n      defines.PREPASS = true;\n      defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;\n\n      for (let i = 0; i < texturesList.length; i++) {\n        const index = scene.prePassRenderer.getIndex(texturesList[i].type);\n\n        if (index !== -1) {\n          defines[texturesList[i].define] = true;\n          defines[texturesList[i].index] = index;\n        } else {\n          defines[texturesList[i].define] = false;\n        }\n      }\n    } else {\n      defines.PREPASS = false;\n\n      for (let i = 0; i < texturesList.length; i++) {\n        defines[texturesList[i].define] = false;\n      }\n    }\n\n    if (defines.PREPASS != previousPrePass) {\n      defines.markAsUnprocessed();\n      defines.markAsImageProcessingDirty();\n    }\n  }\n  /**\n   * Prepares the defines related to the light information passed in parameter\n   * @param scene The scene we are intending to draw\n   * @param mesh The mesh the effect is compiling for\n   * @param light The light the effect is compiling for\n   * @param lightIndex The index of the light\n   * @param defines The defines to update\n   * @param specularSupported Specifies whether specular is supported or not (override lights data)\n   * @param state Defines the current state regarding what is needed (normals, etc...)\n   * @param state.needNormals\n   * @param state.needRebuild\n   * @param state.shadowEnabled\n   * @param state.specularEnabled\n   * @param state.lightmapMode\n   */\n\n\n  static PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state) {\n    var _a;\n\n    state.needNormals = true;\n\n    if (defines[\"LIGHT\" + lightIndex] === undefined) {\n      state.needRebuild = true;\n    }\n\n    defines[\"LIGHT\" + lightIndex] = true;\n    defines[\"SPOTLIGHT\" + lightIndex] = false;\n    defines[\"HEMILIGHT\" + lightIndex] = false;\n    defines[\"POINTLIGHT\" + lightIndex] = false;\n    defines[\"DIRLIGHT\" + lightIndex] = false;\n    light.prepareLightSpecificDefines(defines, lightIndex); // FallOff.\n\n    defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = false;\n    defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = false;\n    defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = false;\n\n    switch (light.falloffType) {\n      case _lightConstants.LightConstants.FALLOFF_GLTF:\n        defines[\"LIGHT_FALLOFF_GLTF\" + lightIndex] = true;\n        break;\n\n      case _lightConstants.LightConstants.FALLOFF_PHYSICAL:\n        defines[\"LIGHT_FALLOFF_PHYSICAL\" + lightIndex] = true;\n        break;\n\n      case _lightConstants.LightConstants.FALLOFF_STANDARD:\n        defines[\"LIGHT_FALLOFF_STANDARD\" + lightIndex] = true;\n        break;\n    } // Specular\n\n\n    if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {\n      state.specularEnabled = true;\n    } // Shadows\n\n\n    defines[\"SHADOW\" + lightIndex] = false;\n    defines[\"SHADOWCSM\" + lightIndex] = false;\n    defines[\"SHADOWCSMDEBUG\" + lightIndex] = false;\n    defines[\"SHADOWCSMNUM_CASCADES\" + lightIndex] = false;\n    defines[\"SHADOWCSMUSESHADOWMAXZ\" + lightIndex] = false;\n    defines[\"SHADOWCSMNOBLEND\" + lightIndex] = false;\n    defines[\"SHADOWCSM_RIGHTHANDED\" + lightIndex] = false;\n    defines[\"SHADOWPCF\" + lightIndex] = false;\n    defines[\"SHADOWPCSS\" + lightIndex] = false;\n    defines[\"SHADOWPOISSON\" + lightIndex] = false;\n    defines[\"SHADOWESM\" + lightIndex] = false;\n    defines[\"SHADOWCLOSEESM\" + lightIndex] = false;\n    defines[\"SHADOWCUBE\" + lightIndex] = false;\n    defines[\"SHADOWLOWQUALITY\" + lightIndex] = false;\n    defines[\"SHADOWMEDIUMQUALITY\" + lightIndex] = false;\n\n    if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {\n      const shadowGenerator = (_a = light.getShadowGenerator(scene.activeCamera)) !== null && _a !== void 0 ? _a : light.getShadowGenerator();\n\n      if (shadowGenerator) {\n        const shadowMap = shadowGenerator.getShadowMap();\n\n        if (shadowMap) {\n          if (shadowMap.renderList && shadowMap.renderList.length > 0) {\n            state.shadowEnabled = true;\n            shadowGenerator.prepareDefines(defines, lightIndex);\n          }\n        }\n      }\n    }\n\n    if (light.lightmapMode != _lightConstants.LightConstants.LIGHTMAP_DEFAULT) {\n      state.lightmapMode = true;\n      defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = true;\n      defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = light.lightmapMode == _lightConstants.LightConstants.LIGHTMAP_SHADOWSONLY;\n    } else {\n      defines[\"LIGHTMAPEXCLUDED\" + lightIndex] = false;\n      defines[\"LIGHTMAPNOSPECULAR\" + lightIndex] = false;\n    }\n  }\n  /**\n   * Prepares the defines related to the light information passed in parameter\n   * @param scene The scene we are intending to draw\n   * @param mesh The mesh the effect is compiling for\n   * @param defines The defines to update\n   * @param specularSupported Specifies whether specular is supported or not (override lights data)\n   * @param maxSimultaneousLights Specifies how manuy lights can be added to the effect at max\n   * @param disableLighting Specifies whether the lighting is disabled (override scene and light)\n   * @returns true if normals will be required for the rest of the effect\n   */\n\n\n  static PrepareDefinesForLights(scene, mesh, defines, specularSupported, maxSimultaneousLights = 4, disableLighting = false) {\n    if (!defines._areLightsDirty) {\n      return defines._needNormals;\n    }\n\n    let lightIndex = 0;\n    const state = {\n      needNormals: defines._needNormals,\n      needRebuild: false,\n      lightmapMode: false,\n      shadowEnabled: false,\n      specularEnabled: false\n    };\n\n    if (scene.lightsEnabled && !disableLighting) {\n      for (const light of mesh.lightSources) {\n        this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);\n        lightIndex++;\n\n        if (lightIndex === maxSimultaneousLights) {\n          break;\n        }\n      }\n    }\n\n    defines[\"SPECULARTERM\"] = state.specularEnabled;\n    defines[\"SHADOWS\"] = state.shadowEnabled; // Resetting all other lights if any\n\n    for (let index = lightIndex; index < maxSimultaneousLights; index++) {\n      if (defines[\"LIGHT\" + index] !== undefined) {\n        defines[\"LIGHT\" + index] = false;\n        defines[\"HEMILIGHT\" + index] = false;\n        defines[\"POINTLIGHT\" + index] = false;\n        defines[\"DIRLIGHT\" + index] = false;\n        defines[\"SPOTLIGHT\" + index] = false;\n        defines[\"SHADOW\" + index] = false;\n        defines[\"SHADOWCSM\" + index] = false;\n        defines[\"SHADOWCSMDEBUG\" + index] = false;\n        defines[\"SHADOWCSMNUM_CASCADES\" + index] = false;\n        defines[\"SHADOWCSMUSESHADOWMAXZ\" + index] = false;\n        defines[\"SHADOWCSMNOBLEND\" + index] = false;\n        defines[\"SHADOWCSM_RIGHTHANDED\" + index] = false;\n        defines[\"SHADOWPCF\" + index] = false;\n        defines[\"SHADOWPCSS\" + index] = false;\n        defines[\"SHADOWPOISSON\" + index] = false;\n        defines[\"SHADOWESM\" + index] = false;\n        defines[\"SHADOWCLOSEESM\" + index] = false;\n        defines[\"SHADOWCUBE\" + index] = false;\n        defines[\"SHADOWLOWQUALITY\" + index] = false;\n        defines[\"SHADOWMEDIUMQUALITY\" + index] = false;\n      }\n    }\n\n    const caps = scene.getEngine().getCaps();\n\n    if (defines[\"SHADOWFLOAT\"] === undefined) {\n      state.needRebuild = true;\n    }\n\n    defines[\"SHADOWFLOAT\"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);\n    defines[\"LIGHTMAPEXCLUDED\"] = state.lightmapMode;\n\n    if (state.needRebuild) {\n      defines.rebuild();\n    }\n\n    return state.needNormals;\n  }\n  /**\n   * Prepares the uniforms and samplers list to be used in the effect (for a specific light)\n   * @param lightIndex defines the light index\n   * @param uniformsList The uniform list\n   * @param samplersList The sampler list\n   * @param projectedLightTexture defines if projected texture must be used\n   * @param uniformBuffersList defines an optional list of uniform buffers\n   * @param updateOnlyBuffersList True to only update the uniformBuffersList array\n   */\n\n\n  static PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList = null, updateOnlyBuffersList = false) {\n    if (uniformBuffersList) {\n      uniformBuffersList.push(\"Light\" + lightIndex);\n    }\n\n    if (updateOnlyBuffersList) {\n      return;\n    }\n\n    uniformsList.push(\"vLightData\" + lightIndex, \"vLightDiffuse\" + lightIndex, \"vLightSpecular\" + lightIndex, \"vLightDirection\" + lightIndex, \"vLightFalloff\" + lightIndex, \"vLightGround\" + lightIndex, \"lightMatrix\" + lightIndex, \"shadowsInfo\" + lightIndex, \"depthValues\" + lightIndex);\n    samplersList.push(\"shadowSampler\" + lightIndex);\n    samplersList.push(\"depthSampler\" + lightIndex);\n    uniformsList.push(\"viewFrustumZ\" + lightIndex, \"cascadeBlendFactor\" + lightIndex, \"lightSizeUVCorrection\" + lightIndex, \"depthCorrection\" + lightIndex, \"penumbraDarkness\" + lightIndex, \"frustumLengths\" + lightIndex);\n\n    if (projectedLightTexture) {\n      samplersList.push(\"projectionLightSampler\" + lightIndex);\n      uniformsList.push(\"textureProjectionMatrix\" + lightIndex);\n    }\n  }\n  /**\n   * Prepares the uniforms and samplers list to be used in the effect\n   * @param uniformsListOrOptions The uniform names to prepare or an EffectCreationOptions containing the list and extra information\n   * @param samplersList The sampler list\n   * @param defines The defines helping in the list generation\n   * @param maxSimultaneousLights The maximum number of simultaneous light allowed in the effect\n   */\n\n\n  static PrepareUniformsAndSamplersList(uniformsListOrOptions, samplersList, defines, maxSimultaneousLights = 4) {\n    let uniformsList;\n    let uniformBuffersList = null;\n\n    if (uniformsListOrOptions.uniformsNames) {\n      const options = uniformsListOrOptions;\n      uniformsList = options.uniformsNames;\n      uniformBuffersList = options.uniformBuffersNames;\n      samplersList = options.samplers;\n      defines = options.defines;\n      maxSimultaneousLights = options.maxSimultaneousLights || 0;\n    } else {\n      uniformsList = uniformsListOrOptions;\n\n      if (!samplersList) {\n        samplersList = [];\n      }\n    }\n\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n\n      this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines[\"PROJECTEDLIGHTTEXTURE\" + lightIndex], uniformBuffersList);\n    }\n\n    if (defines[\"NUM_MORPH_INFLUENCERS\"]) {\n      uniformsList.push(\"morphTargetInfluences\");\n    }\n\n    if (defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"]) {\n      uniformsList.push(\"bakedVertexAnimationSettings\");\n      uniformsList.push(\"bakedVertexAnimationTextureSizeInverted\");\n      uniformsList.push(\"bakedVertexAnimationTime\");\n      samplersList.push(\"bakedVertexAnimationTexture\");\n    }\n  }\n  /**\n   * This helps decreasing rank by rank the shadow quality (0 being the highest rank and quality)\n   * @param defines The defines to update while falling back\n   * @param fallbacks The authorized effect fallbacks\n   * @param maxSimultaneousLights The maximum number of lights allowed\n   * @param rank the current rank of the Effect\n   * @returns The newly affected rank\n   */\n\n\n  static HandleFallbacksForShadows(defines, fallbacks, maxSimultaneousLights = 4, rank = 0) {\n    let lightFallbackRank = 0;\n\n    for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {\n      if (!defines[\"LIGHT\" + lightIndex]) {\n        break;\n      }\n\n      if (lightIndex > 0) {\n        lightFallbackRank = rank + lightIndex;\n        fallbacks.addFallback(lightFallbackRank, \"LIGHT\" + lightIndex);\n      }\n\n      if (!defines[\"SHADOWS\"]) {\n        if (defines[\"SHADOW\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOW\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWPCF\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPCF\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWPCSS\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPCSS\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWPOISSON\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWPOISSON\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWESM\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWESM\" + lightIndex);\n        }\n\n        if (defines[\"SHADOWCLOSEESM\" + lightIndex]) {\n          fallbacks.addFallback(rank, \"SHADOWCLOSEESM\" + lightIndex);\n        }\n      }\n    }\n\n    return lightFallbackRank++;\n  }\n  /**\n   * Prepares the list of attributes required for morph targets according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param mesh The mesh to prepare the morph targets attributes for\n   * @param influencers The number of influencers\n   */\n\n\n  static PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, influencers) {\n    this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;\n    this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);\n  }\n  /**\n   * Prepares the list of attributes required for morph targets according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param mesh The mesh to prepare the morph targets attributes for\n   * @param defines The current Defines of the effect\n   */\n\n\n  static PrepareAttributesForMorphTargets(attribs, mesh, defines) {\n    const influencers = defines[\"NUM_MORPH_INFLUENCERS\"];\n\n    if (influencers > 0 && _engineStore.EngineStore.LastCreatedEngine) {\n      const maxAttributesCount = _engineStore.EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;\n\n      const manager = mesh.morphTargetManager;\n\n      if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {\n        return;\n      }\n\n      const normal = manager && manager.supportsNormals && defines[\"NORMAL\"];\n      const tangent = manager && manager.supportsTangents && defines[\"TANGENT\"];\n      const uv = manager && manager.supportsUVs && defines[\"UV1\"];\n\n      for (let index = 0; index < influencers; index++) {\n        attribs.push(_buffer.VertexBuffer.PositionKind + index);\n\n        if (normal) {\n          attribs.push(_buffer.VertexBuffer.NormalKind + index);\n        }\n\n        if (tangent) {\n          attribs.push(_buffer.VertexBuffer.TangentKind + index);\n        }\n\n        if (uv) {\n          attribs.push(_buffer.VertexBuffer.UVKind + \"_\" + index);\n        }\n\n        if (attribs.length > maxAttributesCount) {\n          _logger.Logger.Error(\"Cannot add more vertex attributes for mesh \" + mesh.name);\n        }\n      }\n    }\n  }\n  /**\n   * Prepares the list of attributes required for baked vertex animations according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param mesh The mesh to prepare the morph targets attributes for\n   * @param defines The current Defines of the effect\n   */\n\n\n  static PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines) {\n    const enabled = defines[\"BAKED_VERTEX_ANIMATION_TEXTURE\"] && defines[\"INSTANCES\"];\n\n    if (enabled) {\n      attribs.push(\"bakedVertexAnimationSettingsInstanced\");\n    }\n  }\n  /**\n   * Prepares the list of attributes required for bones according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param mesh The mesh to prepare the bones attributes for\n   * @param defines The current Defines of the effect\n   * @param fallbacks The current effect fallback strategy\n   */\n\n\n  static PrepareAttributesForBones(attribs, mesh, defines, fallbacks) {\n    if (defines[\"NUM_BONE_INFLUENCERS\"] > 0) {\n      fallbacks.addCPUSkinningFallback(0, mesh);\n      attribs.push(_buffer.VertexBuffer.MatricesIndicesKind);\n      attribs.push(_buffer.VertexBuffer.MatricesWeightsKind);\n\n      if (defines[\"NUM_BONE_INFLUENCERS\"] > 4) {\n        attribs.push(_buffer.VertexBuffer.MatricesIndicesExtraKind);\n        attribs.push(_buffer.VertexBuffer.MatricesWeightsExtraKind);\n      }\n    }\n  }\n  /**\n   * Check and prepare the list of attributes required for instances according to the effect defines.\n   * @param attribs The current list of supported attribs\n   * @param defines The current MaterialDefines of the effect\n   */\n\n\n  static PrepareAttributesForInstances(attribs, defines) {\n    if (defines[\"INSTANCES\"] || defines[\"THIN_INSTANCES\"]) {\n      this.PushAttributesForInstances(attribs, !!defines[\"PREPASS_VELOCITY\"]);\n    }\n\n    if (defines.INSTANCESCOLOR) {\n      attribs.push(_buffer.VertexBuffer.ColorInstanceKind);\n    }\n  }\n  /**\n   * Add the list of attributes required for instances to the attribs array.\n   * @param attribs The current list of supported attribs\n   * @param needsPreviousMatrices If the shader needs previous matrices\n   */\n\n\n  static PushAttributesForInstances(attribs, needsPreviousMatrices = false) {\n    attribs.push(\"world0\");\n    attribs.push(\"world1\");\n    attribs.push(\"world2\");\n    attribs.push(\"world3\");\n\n    if (needsPreviousMatrices) {\n      attribs.push(\"previousWorld0\");\n      attribs.push(\"previousWorld1\");\n      attribs.push(\"previousWorld2\");\n      attribs.push(\"previousWorld3\");\n    }\n  }\n  /**\n   * Binds the light information to the effect.\n   * @param light The light containing the generator\n   * @param effect The effect we are binding the data to\n   * @param lightIndex The light index in the effect used to render\n   */\n\n\n  static BindLightProperties(light, effect, lightIndex) {\n    light.transferToEffect(effect, lightIndex + \"\");\n  }\n  /**\n   * Binds the lights information from the scene to the effect for the given mesh.\n   * @param light Light to bind\n   * @param lightIndex Light index\n   * @param scene The scene where the light belongs to\n   * @param effect The effect we are binding the data to\n   * @param useSpecular Defines if specular is supported\n   * @param receiveShadows Defines if the effect (mesh) we bind the light for receives shadows\n   */\n\n\n  static BindLight(light, lightIndex, scene, effect, useSpecular, receiveShadows = true) {\n    light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);\n  }\n  /**\n   * Binds the lights information from the scene to the effect for the given mesh.\n   * @param scene The scene the lights belongs to\n   * @param mesh The mesh we are binding the information to render\n   * @param effect The effect we are binding the data to\n   * @param defines The generated defines for the effect\n   * @param maxSimultaneousLights The maximum number of light that can be bound to the effect\n   */\n\n\n  static BindLights(scene, mesh, effect, defines, maxSimultaneousLights = 4) {\n    const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);\n\n    for (let i = 0; i < len; i++) {\n      const light = mesh.lightSources[i];\n      this.BindLight(light, i, scene, effect, typeof defines === \"boolean\" ? defines : defines[\"SPECULARTERM\"], mesh.receiveShadows);\n    }\n  }\n  /**\n   * Binds the fog information from the scene to the effect for the given mesh.\n   * @param scene The scene the lights belongs to\n   * @param mesh The mesh we are binding the information to render\n   * @param effect The effect we are binding the data to\n   * @param linearSpace Defines if the fog effect is applied in linear space\n   */\n\n\n  static BindFogParameters(scene, mesh, effect, linearSpace = false) {\n    if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== _scene.Scene.FOGMODE_NONE) {\n      effect.setFloat4(\"vFogInfos\", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity); // Convert fog color to linear space if used in a linear space computed shader.\n\n      if (linearSpace) {\n        scene.fogColor.toLinearSpaceToRef(this._TempFogColor, scene.getEngine().useExactSrgbConversions);\n        effect.setColor3(\"vFogColor\", this._TempFogColor);\n      } else {\n        effect.setColor3(\"vFogColor\", scene.fogColor);\n      }\n    }\n  }\n  /**\n   * Binds the bones information from the mesh to the effect.\n   * @param mesh The mesh we are binding the information to render\n   * @param effect The effect we are binding the data to\n   * @param prePassConfiguration Configuration for the prepass, in case prepass is activated\n   */\n\n\n  static BindBonesParameters(mesh, effect, prePassConfiguration) {\n    if (!effect || !mesh) {\n      return;\n    }\n\n    if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {\n      mesh.computeBonesUsingShaders = false;\n    }\n\n    if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {\n      const skeleton = mesh.skeleton;\n\n      if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex(\"boneTextureWidth\") > -1) {\n        const boneTexture = skeleton.getTransformMatrixTexture(mesh);\n        effect.setTexture(\"boneSampler\", boneTexture);\n        effect.setFloat(\"boneTextureWidth\", 4.0 * (skeleton.bones.length + 1));\n      } else {\n        const matrices = skeleton.getTransformMatrices(mesh);\n\n        if (matrices) {\n          effect.setMatrices(\"mBones\", matrices);\n\n          if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {\n            if (!prePassConfiguration.previousBones[mesh.uniqueId]) {\n              prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();\n            }\n\n            effect.setMatrices(\"mPreviousBones\", prePassConfiguration.previousBones[mesh.uniqueId]);\n\n            MaterialHelper._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);\n          }\n        }\n      }\n    }\n  } // Copies the bones transformation matrices into the target array and returns the target's reference\n\n\n  static _CopyBonesTransformationMatrices(source, target) {\n    target.set(source);\n    return target;\n  }\n  /**\n   * Binds the morph targets information from the mesh to the effect.\n   * @param abstractMesh The mesh we are binding the information to render\n   * @param effect The effect we are binding the data to\n   */\n\n\n  static BindMorphTargetParameters(abstractMesh, effect) {\n    const manager = abstractMesh.morphTargetManager;\n\n    if (!abstractMesh || !manager) {\n      return;\n    }\n\n    effect.setFloatArray(\"morphTargetInfluences\", manager.influences);\n  }\n  /**\n   * Binds the logarithmic depth information from the scene to the effect for the given defines.\n   * @param defines The generated defines used in the effect\n   * @param effect The effect we are binding the data to\n   * @param scene The scene we are willing to render with logarithmic scale for\n   */\n\n\n  static BindLogDepth(defines, effect, scene) {\n    if (!defines || defines[\"LOGARITHMICDEPTH\"] || defines.indexOf && defines.indexOf(\"LOGARITHMICDEPTH\") >= 0) {\n      const camera = scene.activeCamera;\n\n      if (camera.mode === _camera.Camera.ORTHOGRAPHIC_CAMERA) {\n        _logger.Logger.Error(\"Logarithmic depth is not compatible with orthographic cameras!\", 20);\n      }\n\n      effect.setFloat(\"logarithmicDepthConstant\", 2.0 / (Math.log(camera.maxZ + 1.0) / Math.LN2));\n    }\n  }\n\n} // eslint-disable-next-line @typescript-eslint/naming-convention\n\n\nexports.MaterialHelper = MaterialHelper;\nMaterialHelper._TmpMorphInfluencers = {\n  NUM_MORPH_INFLUENCERS: 0\n};\nMaterialHelper._TempFogColor = _mathColor.Color3.Black();\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","MaterialHelper","_logger","_camera","_scene","_engineStore","_buffer","_lightConstants","_mathColor","_clipPlaneMaterialHelper","BindSceneUniformBuffer","effect","sceneUbo","bindToEffect","PrepareDefinesForMergedUV","texture","defines","key","_needUVs","optimizeUVAllocation","getTextureMatrix","isIdentityAs3x2","coordinatesIndex","BindTextureMatrix","uniformBuffer","matrix","updateMatrix","GetFogState","mesh","scene","fogEnabled","applyFog","fogMode","Scene","FOGMODE_NONE","PrepareDefinesForMisc","useLogarithmicDepth","pointsCloud","alphaTest","_areMiscDirty","nonUniformScaling","PrepareDefinesForCamera","changed","activeCamera","wasPersp","isOrtho","mode","Camera","ORTHOGRAPHIC_CAMERA","isPersp","PERSPECTIVE_CAMERA","wasOrtho","PrepareDefinesForFrameBoundValues","engine","material","useInstances","useClipPlane","useThinInstances","prepareDefinesForClipPlanes","getColorWrite","markAsUnprocessed","PrepareDefinesForBones","useBones","computeBonesUsingShaders","skeleton","numBoneInfluencers","materialSupportsBoneTexture","undefined","isUsingTextureForMatrices","bones","length","prePassRenderer","getScene","enabled","nonExcluded","excludedSkinnedMesh","indexOf","PrepareDefinesForMorphTargets","manager","morphTargetManager","supportsUVs","supportsTangents","supportsNormals","numInfluencers","isUsingTextureForTargets","PrepareDefinesForBakedVertexAnimation","bakedVertexAnimationManager","isEnabled","PrepareDefinesForAttributes","useVertexColor","useMorphTargets","useVertexAlpha","useBakedVertexAnimation","_areAttributesDirty","_needNormals","_normals","_uvs","isVerticesDataPresent","VertexBuffer","NormalKind","TangentKind","i","hasVertexColors","useVertexColors","ColorKind","hasVertexAlpha","ColorInstanceKind","hasInstances","hasThinInstances","PrepareDefinesForMultiview","previousMultiview","MULTIVIEW","outputRenderTarget","getViewCount","PrepareDefinesForOIT","needAlphaBlending","previousDefine","ORDER_INDEPENDENT_TRANSPARENCY","previousDefine16Bits","ORDER_INDEPENDENT_TRANSPARENCY_16BITS","useOrderIndependentTransparency","getEngine","getCaps","textureFloatLinearFiltering","PrepareDefinesForPrePass","canRenderToMRT","previousPrePass","PREPASS","_arePrePassDirty","texturesList","type","define","index","SCENE_MRT_COUNT","mrtCount","getIndex","markAsImageProcessingDirty","PrepareDefinesForLight","light","lightIndex","specularSupported","state","_a","needNormals","needRebuild","prepareLightSpecificDefines","falloffType","LightConstants","FALLOFF_GLTF","FALLOFF_PHYSICAL","FALLOFF_STANDARD","specular","equalsFloats","specularEnabled","receiveShadows","shadowsEnabled","shadowEnabled","shadowGenerator","getShadowGenerator","shadowMap","getShadowMap","renderList","prepareDefines","lightmapMode","LIGHTMAP_DEFAULT","LIGHTMAP_SHADOWSONLY","PrepareDefinesForLights","maxSimultaneousLights","disableLighting","_areLightsDirty","lightsEnabled","lightSources","caps","textureFloatRender","textureHalfFloatRender","textureHalfFloatLinearFiltering","rebuild","PrepareUniformsAndSamplersForLight","uniformsList","samplersList","projectedLightTexture","uniformBuffersList","updateOnlyBuffersList","push","PrepareUniformsAndSamplersList","uniformsListOrOptions","uniformsNames","uniformBuffersNames","samplers","HandleFallbacksForShadows","fallbacks","rank","lightFallbackRank","addFallback","PrepareAttributesForMorphTargetsInfluencers","attribs","influencers","_TmpMorphInfluencers","NUM_MORPH_INFLUENCERS","PrepareAttributesForMorphTargets","EngineStore","LastCreatedEngine","maxAttributesCount","maxVertexAttribs","normal","tangent","uv","PositionKind","UVKind","Logger","Error","name","PrepareAttributesForBakedVertexAnimation","PrepareAttributesForBones","addCPUSkinningFallback","MatricesIndicesKind","MatricesWeightsKind","MatricesIndicesExtraKind","MatricesWeightsExtraKind","PrepareAttributesForInstances","PushAttributesForInstances","INSTANCESCOLOR","needsPreviousMatrices","BindLightProperties","transferToEffect","BindLight","useSpecular","_bindLight","BindLights","len","Math","min","BindFogParameters","linearSpace","setFloat4","fogStart","fogEnd","fogDensity","fogColor","toLinearSpaceToRef","_TempFogColor","useExactSrgbConversions","setColor3","BindBonesParameters","prePassConfiguration","_bonesComputationForcedToCPU","getUniformIndex","boneTexture","getTransformMatrixTexture","setTexture","setFloat","matrices","getTransformMatrices","setMatrices","previousBones","uniqueId","slice","_CopyBonesTransformationMatrices","source","target","set","BindMorphTargetParameters","abstractMesh","setFloatArray","influences","BindLogDepth","camera","log","maxZ","LN2","Color3","Black"]
}
