shadow$provide.module$node_modules$$babylonjs$core$Engines$Processors$shaderProcessor=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.ShaderProcessor=void 0;var _shaderCodeNode=require("module$node_modules$$babylonjs$core$Engines$Processors$shaderCodeNode"),_shaderCodeCursor=require("module$node_modules$$babylonjs$core$Engines$Processors$shaderCodeCursor"),_shaderCodeConditionNode=require("module$node_modules$$babylonjs$core$Engines$Processors$shaderCodeConditionNode"),
_shaderCodeTestNode=require("module$node_modules$$babylonjs$core$Engines$Processors$shaderCodeTestNode"),_shaderDefineIsDefinedOperator=require("module$node_modules$$babylonjs$core$Engines$Processors$Expressions$Operators$shaderDefineIsDefinedOperator"),_shaderDefineOrOperator=require("module$node_modules$$babylonjs$core$Engines$Processors$Expressions$Operators$shaderDefineOrOperator"),_shaderDefineAndOperator=require("module$node_modules$$babylonjs$core$Engines$Processors$Expressions$Operators$shaderDefineAndOperator"),
_shaderDefineExpression=require("module$node_modules$$babylonjs$core$Engines$Processors$Expressions$shaderDefineExpression"),_shaderDefineArithmeticOperator=require("module$node_modules$$babylonjs$core$Engines$Processors$Expressions$Operators$shaderDefineArithmeticOperator"),_devTools=require("module$node_modules$$babylonjs$core$Misc$devTools"),_shaderLanguage=require("module$node_modules$$babylonjs$core$Materials$shaderLanguage");const regexSE=/defined\s*?\((.+?)\)/g,regexSERevert=/defined\s*?\[(.+?)\]/g,
regexShaderInclude=/#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g,regexShaderDecl=/__decl__/,regexLightX=/light\{X\}.(\w*)/g,regexX=/\{X\}/g,reusableMatches=[];class ShaderProcessor{static Initialize(options){options.processor&&options.processor.initializeShaders&&options.processor.initializeShaders(options.processingContext)}static Process(sourceCode,options,callback,engine){var _a;if(null===(_a=options.processor)||void 0===_a?0:_a.preProcessShaderCode)sourceCode=options.processor.preProcessShaderCode(sourceCode,
options.isFragment);this._ProcessIncludes(sourceCode,options,codeWithIncludes=>{options.processCodeAfterIncludes&&(codeWithIncludes=options.processCodeAfterIncludes(options.isFragment?"fragment":"vertex",codeWithIncludes));const migratedCode=this._ProcessShaderConversion(codeWithIncludes,options,engine);callback(migratedCode,codeWithIncludes)})}static PreProcess(sourceCode,options,callback,engine){var _a;if(null===(_a=options.processor)||void 0===_a?0:_a.preProcessShaderCode)sourceCode=options.processor.preProcessShaderCode(sourceCode,
options.isFragment);this._ProcessIncludes(sourceCode,options,codeWithIncludes=>{options.processCodeAfterIncludes&&(codeWithIncludes=options.processCodeAfterIncludes(options.isFragment?"fragment":"vertex",codeWithIncludes));const migratedCode=this._ApplyPreProcessing(codeWithIncludes,options,engine);callback(migratedCode,codeWithIncludes)})}static Finalize(vertexCode,fragmentCode,options){return options.processor&&options.processor.finalizeShaders?options.processor.finalizeShaders(vertexCode,fragmentCode,
options.processingContext):{vertexCode,fragmentCode}}static _ProcessPrecision(source,options){var _a;if(null===(_a=options.processor)||void 0===_a?0:_a.noPrecision)return source;options=options.shouldUseHighPrecisionShader;-1===source.indexOf("precision highp float")?source=options?"precision highp float;\n"+source:"precision mediump float;\n"+source:options||(source=source.replace("precision highp float","precision mediump float"));return source}static _ExtractOperation(expression){var match=/defined\((.+)\)/.exec(expression);
if(match&&match.length)return new _shaderDefineIsDefinedOperator.ShaderDefineIsDefinedOperator(match[1].trim(),"!"===expression[0]);var operators="\x3d\x3d !\x3d \x3e\x3d \x3c\x3d \x3c \x3e".split(" ");match="";let indexOperator=0;for(match of operators)if(indexOperator=expression.indexOf(match),-1<indexOperator)break;if(-1===indexOperator)return new _shaderDefineIsDefinedOperator.ShaderDefineIsDefinedOperator(expression);operators=expression.substring(0,indexOperator).trim();expression=expression.substring(indexOperator+
match.length).trim();return new _shaderDefineArithmeticOperator.ShaderDefineArithmeticOperator(operators,match,expression)}static _BuildSubExpression(expression){expression=expression.replace(regexSE,"defined[$1]");var postfix=_shaderDefineExpression.ShaderDefineExpression.infixToPostfix(expression);expression=[];for(var c of postfix)if("||"!==c&&"\x26\x26"!==c)expression.push(c);else if(2<=expression.length){postfix=expression[expression.length-1];let v2=expression[expression.length-2];expression.length-=
2;const operator="\x26\x26"==c?new _shaderDefineAndOperator.ShaderDefineAndOperator:new _shaderDefineOrOperator.ShaderDefineOrOperator;"string"===typeof postfix&&(postfix=postfix.replace(regexSERevert,"defined($1)"));"string"===typeof v2&&(v2=v2.replace(regexSERevert,"defined($1)"));operator.leftOperand="string"===typeof v2?this._ExtractOperation(v2):v2;operator.rightOperand="string"===typeof postfix?this._ExtractOperation(postfix):postfix;expression.push(operator)}c=expression[expression.length-
1];"string"===typeof c&&(c=c.replace(regexSERevert,"defined($1)"));return"string"===typeof c?this._ExtractOperation(c):c}static _BuildExpression(line,start){const node=new _shaderCodeTestNode.ShaderCodeTestNode,command=line.substring(0,start);line=line.substring(start);line=line.substring(0,(line.indexOf("//")+1||line.length+1)-1).trim();node.testExpression="#ifdef"===command?new _shaderDefineIsDefinedOperator.ShaderDefineIsDefinedOperator(line):"#ifndef"===command?new _shaderDefineIsDefinedOperator.ShaderDefineIsDefinedOperator(line,
!0):this._BuildSubExpression(line);return node}static _MoveCursorWithinIf(cursor,rootNode,ifNode){let line;for(;this._MoveCursor(cursor,ifNode);){line=cursor.currentLine;const first5=line.substring(0,5).toLowerCase();if("#else"===first5){ifNode=new _shaderCodeNode.ShaderCodeNode;rootNode.children.push(ifNode);this._MoveCursor(cursor,ifNode);break}else"#elif"===first5&&(ifNode=this._BuildExpression(line,5),rootNode.children.push(ifNode))}}static _MoveCursor(cursor,rootNode){for(;cursor.canRead;){cursor.lineIndex++;
var line=cursor.currentLine;if(0<=line.indexOf("#")){var matches=ShaderProcessor._MoveCursorRegex.exec(line);if(matches&&matches.length){switch(matches[0]){case "#ifdef":matches=new _shaderCodeConditionNode.ShaderCodeConditionNode;rootNode.children.push(matches);line=this._BuildExpression(line,6);matches.children.push(line);this._MoveCursorWithinIf(cursor,matches,line);break;case "#else":case "#elif":return!0;case "#endif":return!1;case "#ifndef":matches=new _shaderCodeConditionNode.ShaderCodeConditionNode;
rootNode.children.push(matches);line=this._BuildExpression(line,7);matches.children.push(line);this._MoveCursorWithinIf(cursor,matches,line);break;case "#if":matches=new _shaderCodeConditionNode.ShaderCodeConditionNode,line=this._BuildExpression(line,3),rootNode.children.push(matches),matches.children.push(line),this._MoveCursorWithinIf(cursor,matches,line)}continue}}matches=new _shaderCodeNode.ShaderCodeNode;matches.line=line;rootNode.children.push(matches);"#"===line[0]&&"d"===line[1]&&(line=line.replace(";",
"").split(" "),matches.additionalDefineKey=line[1],3===line.length&&(matches.additionalDefineValue=line[2]))}return!1}static _EvaluatePreProcessors(sourceCode,preprocessors,options){const rootNode=new _shaderCodeNode.ShaderCodeNode,cursor=new _shaderCodeCursor.ShaderCodeCursor;cursor.lineIndex=-1;cursor.lines=sourceCode.split("\n");this._MoveCursor(cursor,rootNode);return rootNode.process(preprocessors,options)}static _PreparePreProcessors(options,engine){var _a,defines=options.defines;const preprocessors=
{};for(const define of defines)defines=define.replace("#define","").replace(";","").trim().split(" "),preprocessors[defines[0]]=1<defines.length?defines[1]:"";(null===(_a=options.processor)||void 0===_a?void 0:_a.shaderLanguage)===_shaderLanguage.ShaderLanguage.GLSL&&(preprocessors.GL_ES="true");preprocessors.__VERSION__=options.version;preprocessors[options.platformName]="true";engine._getGlobalDefines(preprocessors);return preprocessors}static _ProcessShaderConversion(sourceCode,options,engine){sourceCode=
this._ProcessPrecision(sourceCode,options);if(!options.processor||options.processor.shaderLanguage===_shaderLanguage.ShaderLanguage.GLSL&&-1!==sourceCode.indexOf("#version 3")&&(sourceCode=sourceCode.replace("#version 300 es",""),!options.processor.parseGLES3))return sourceCode;const defines=options.defines,preprocessors=this._PreparePreProcessors(options,engine);options.processor.preProcessor&&(sourceCode=options.processor.preProcessor(sourceCode,defines,options.isFragment,options.processingContext));
sourceCode=this._EvaluatePreProcessors(sourceCode,preprocessors,options);options.processor.postProcessor&&(sourceCode=options.processor.postProcessor(sourceCode,defines,options.isFragment,options.processingContext,engine));engine._features.needShaderCodeInlining&&(sourceCode=engine.inlineShaderCode(sourceCode));return sourceCode}static _ApplyPreProcessing(sourceCode,options,engine){var _a,_b;const defines=options.defines,preprocessors=this._PreparePreProcessors(options,engine);if(null===(_a=options.processor)||
void 0===_a?0:_a.preProcessor)sourceCode=options.processor.preProcessor(sourceCode,defines,options.isFragment,options.processingContext);sourceCode=this._EvaluatePreProcessors(sourceCode,preprocessors,options);if(null===(_b=options.processor)||void 0===_b?0:_b.postProcessor)sourceCode=options.processor.postProcessor(sourceCode,defines,options.isFragment,options.processingContext,engine);engine._features.needShaderCodeInlining&&(sourceCode=engine.inlineShaderCode(sourceCode));return sourceCode}static _ProcessIncludes(sourceCode,
options,callback){reusableMatches.length=0;for(var match$jscomp$0;null!==(match$jscomp$0=regexShaderInclude.exec(sourceCode));)reusableMatches.push(match$jscomp$0);match$jscomp$0=String(sourceCode);let parts=[sourceCode];sourceCode=!1;for(const match of reusableMatches){let includeFile=match[1];-1!==includeFile.indexOf("__decl__")&&(includeFile=includeFile.replace(regexShaderDecl,""),options.supportsUniformBuffers&&(includeFile=includeFile.replace("Vertex","Ubo").replace("Fragment","Ubo")),includeFile+=
"Declaration");if(options.includesShadersStore[includeFile]){match$jscomp$0=options.includesShadersStore[includeFile];if(match[2]){var splits=match[3].split(",");for(var index=0;index<splits.length;index+=2)match$jscomp$0=match$jscomp$0.replace(new RegExp(splits[index],"g"),splits[index+1])}if(match[4])if(splits=match[5],-1!==splits.indexOf("..")){var indexSplits=splits.split("..");const minIndex=parseInt(indexSplits[0]);splits=parseInt(indexSplits[1]);index=match$jscomp$0.slice(0);match$jscomp$0=
"";isNaN(splits)&&(splits=options.indexParameters[indexSplits[1]]);for(indexSplits=minIndex;indexSplits<splits;indexSplits++)options.supportsUniformBuffers||(index=index.replace(regexLightX,(str,p1)=>p1+"{X}")),match$jscomp$0+=index.replace(regexX,indexSplits.toString())+"\n"}else options.supportsUniformBuffers||(match$jscomp$0=match$jscomp$0.replace(regexLightX,(str,p1)=>p1+"{X}")),match$jscomp$0=match$jscomp$0.replace(regexX,splits);splits=[];for(const part of parts){index=part.split(match[0]);
for(indexSplits=0;indexSplits<index.length-1;indexSplits++)splits.push(index[indexSplits]),splits.push(match$jscomp$0);splits.push(index[index.length-1])}parts=splits;sourceCode=sourceCode||0<=match$jscomp$0.indexOf("#include\x3c")||0<=match$jscomp$0.indexOf("#include \x3c")}else{ShaderProcessor._FileToolsLoadFile(options.shadersRepository+"ShadersInclude/"+includeFile+".fx",fileContent=>{options.includesShadersStore[includeFile]=fileContent;this._ProcessIncludes(parts.join(""),options,callback)});
return}}reusableMatches.length=0;match$jscomp$0=parts.join("");sourceCode?this._ProcessIncludes(match$jscomp$0.toString(),options,callback):callback(match$jscomp$0)}static _FileToolsLoadFile(url,onSuccess,onProgress,offlineProvider,useArrayBuffer,onError){throw(0,_devTools._WarnImport)("FileTools");}}exports.ShaderProcessor=ShaderProcessor;ShaderProcessor._MoveCursorRegex=/(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Engines$Processors$shaderProcessor.js.map
