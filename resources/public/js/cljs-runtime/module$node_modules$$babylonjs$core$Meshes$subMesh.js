shadow$provide.module$node_modules$$babylonjs$core$Meshes$subMesh=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.SubMesh=void 0;var _buffer=require("module$node_modules$$babylonjs$core$Buffers$buffer"),_intersectionInfo=require("module$node_modules$$babylonjs$core$Collisions$intersectionInfo"),_boundingInfo=require("module$node_modules$$babylonjs$core$Culling$boundingInfo"),_mathFunctions=require("module$node_modules$$babylonjs$core$Maths$math_functions"),
_drawWrapper=require("module$node_modules$$babylonjs$core$Materials$drawWrapper");class SubMesh{get materialDefines(){var _a;return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.defines:null===(_a=this._getDrawWrapper())||void 0===_a?void 0:_a.defines}set materialDefines(defines){var _a;(null!==(_a=this._mainDrawWrapperOverride)&&void 0!==_a?_a:this._getDrawWrapper(void 0,!0)).defines=defines}_getDrawWrapper(passId,createIfNotExisting=!1){passId=null!==passId&&void 0!==passId?passId:
this._engine.currentRenderPassId;let drawWrapper=this._drawWrappers[passId];!drawWrapper&&createIfNotExisting&&(this._drawWrappers[passId]=drawWrapper=new _drawWrapper.DrawWrapper(this._mesh.getScene().getEngine()));return drawWrapper}_removeDrawWrapper(passId,disposeWrapper=!0){var _a;disposeWrapper&&(null===(_a=this._drawWrappers[passId])||void 0===_a?void 0:_a.dispose());this._drawWrappers[passId]=void 0}get effect(){var _a,_b;return this._mainDrawWrapperOverride?this._mainDrawWrapperOverride.effect:
null!==(_b=null===(_a=this._getDrawWrapper())||void 0===_a?void 0:_a.effect)&&void 0!==_b?_b:null}get _drawWrapper(){var _a;return null!==(_a=this._mainDrawWrapperOverride)&&void 0!==_a?_a:this._getDrawWrapper(void 0,!0)}get _drawWrapperOverride(){return this._mainDrawWrapperOverride}_setMainDrawWrapperOverride(wrapper){this._mainDrawWrapperOverride=wrapper}setEffect(effect,defines=null,materialContext,resetContext=!0){const drawWrapper=this._drawWrapper;drawWrapper.setEffect(effect,defines,resetContext);
void 0!==materialContext&&(drawWrapper.materialContext=materialContext);effect||(drawWrapper.defines=null,drawWrapper.materialContext=void 0)}resetDrawCache(passId){if(this._drawWrappers){if(void 0!==passId){this._removeDrawWrapper(passId);return}for(const drawWrapper of this._drawWrappers)null===drawWrapper||void 0===drawWrapper?void 0:drawWrapper.dispose()}this._drawWrappers=[]}static AddToMesh(materialIndex,verticesStart,verticesCount,indexStart,indexCount,mesh,renderingMesh,createBoundingBox=
!0){return new SubMesh(materialIndex,verticesStart,verticesCount,indexStart,indexCount,mesh,renderingMesh,createBoundingBox)}constructor(materialIndex,verticesStart,verticesCount,indexStart,indexCount,mesh,renderingMesh,createBoundingBox=!0,addToMesh=!0){this.materialIndex=materialIndex;this.verticesStart=verticesStart;this.verticesCount=verticesCount;this.indexStart=indexStart;this.indexCount=indexCount;this._mainDrawWrapperOverride=null;this._linesIndexCount=0;this._lastColliderTransformMatrix=
this._lastColliderWorldVertices=this._linesIndexBuffer=null;this._wasDispatched=!1;this._distanceToCamera=this._alphaIndex=this._renderId=0;this._currentMaterial=null;this._mesh=mesh;this._renderingMesh=renderingMesh||mesh;addToMesh&&mesh.subMeshes.push(this);this._engine=this._mesh.getScene().getEngine();this.resetDrawCache();this._trianglePlanes=[];this._id=mesh.subMeshes.length-1;createBoundingBox&&(this.refreshBoundingInfo(),mesh.computeWorldMatrix(!0))}get IsGlobal(){return 0===this.verticesStart&&
this.verticesCount===this._mesh.getTotalVertices()&&0===this.indexStart&&this.indexCount===this._mesh.getTotalIndices()}getBoundingInfo(){return this.IsGlobal?this._mesh.getBoundingInfo():this._boundingInfo}setBoundingInfo(boundingInfo){this._boundingInfo=boundingInfo;return this}getMesh(){return this._mesh}getRenderingMesh(){return this._renderingMesh}getReplacementMesh(){return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:null}getEffectiveMesh(){const replacementMesh=this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?
this._mesh:null;return replacementMesh?replacementMesh:this._renderingMesh}getMaterial(getDefaultMaterial=!0){var _a;const rootMaterial=null!==(_a=this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId))&&void 0!==_a?_a:this._renderingMesh.material;return rootMaterial?this._isMultiMaterial(rootMaterial)?(getDefaultMaterial=rootMaterial.getSubMaterial(this.materialIndex),this._currentMaterial!==getDefaultMaterial&&(this._currentMaterial=getDefaultMaterial,this.resetDrawCache()),
getDefaultMaterial):rootMaterial:getDefaultMaterial?this._mesh.getScene().defaultMaterial:null}_isMultiMaterial(material){return void 0!==material.getSubMaterial}refreshBoundingInfo(data=null){this._lastColliderWorldVertices=null;if(this.IsGlobal||!this._renderingMesh||!this._renderingMesh.geometry)return this;data||(data=this._renderingMesh.getVerticesData(_buffer.VertexBuffer.PositionKind));if(!data)return this._boundingInfo=this._mesh.getBoundingInfo(),this;const indices=this._renderingMesh.getIndices();
0===this.indexStart&&this.indexCount===indices.length?(data=this._renderingMesh.getBoundingInfo(),data={minimum:data.minimum.clone(),maximum:data.maximum.clone()}):data=(0,_mathFunctions.extractMinAndMaxIndexed)(data,indices,this.indexStart,this.indexCount,this._renderingMesh.geometry.boundingBias);this._boundingInfo?this._boundingInfo.reConstruct(data.minimum,data.maximum):this._boundingInfo=new _boundingInfo.BoundingInfo(data.minimum,data.maximum);return this}_checkCollision(collider){return this.getBoundingInfo()._checkCollision(collider)}updateBoundingInfo(world){let boundingInfo=
this.getBoundingInfo();boundingInfo||(this.refreshBoundingInfo(),boundingInfo=this.getBoundingInfo());boundingInfo&&boundingInfo.update(world);return this}isInFrustum(frustumPlanes){const boundingInfo=this.getBoundingInfo();return boundingInfo?boundingInfo.isInFrustum(frustumPlanes,this._mesh.cullingStrategy):!1}isCompletelyInFrustum(frustumPlanes){const boundingInfo=this.getBoundingInfo();return boundingInfo?boundingInfo.isCompletelyInFrustum(frustumPlanes):!1}render(enableAlphaMode){this._renderingMesh.render(this,
enableAlphaMode,this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh?this._mesh:void 0);return this}_getLinesIndexBuffer(indices,engine){if(!this._linesIndexBuffer){const linesIndices=[];for(let index=this.indexStart;index<this.indexStart+this.indexCount;index+=3)linesIndices.push(indices[index],indices[index+1],indices[index+1],indices[index+2],indices[index+2],indices[index]);this._linesIndexBuffer=engine.createIndexBuffer(linesIndices);this._linesIndexCount=linesIndices.length}return this._linesIndexBuffer}canIntersects(ray){const boundingInfo=
this.getBoundingInfo();return boundingInfo?ray.intersectsBox(boundingInfo.boundingBox):!1}intersects(ray,positions,indices,fastCheck,trianglePredicate){const material=this.getMaterial();if(!material)return null;let step=3,checkStopper=!1;switch(material.fillMode){case 3:case 5:case 6:case 8:return null;case 7:step=1,checkStopper=!0}return 4===material.fillMode?indices.length?this._intersectLines(ray,positions,indices,this._mesh.intersectionThreshold,fastCheck):this._intersectUnIndexedLines(ray,positions,
indices,this._mesh.intersectionThreshold,fastCheck):!indices.length&&this._mesh._unIndexed?this._intersectUnIndexedTriangles(ray,positions,indices,fastCheck,trianglePredicate):this._intersectTriangles(ray,positions,indices,step,checkStopper,fastCheck,trianglePredicate)}_intersectLines(ray,positions,indices,intersectionThreshold,fastCheck){let intersectInfo=null;for(let index=this.indexStart;index<this.indexStart+this.indexCount;index+=2){const length=ray.intersectionSegment(positions[indices[index]],
positions[indices[index+1]],intersectionThreshold);if(!(0>length)&&(fastCheck||!intersectInfo||length<intersectInfo.distance)&&(intersectInfo=new _intersectionInfo.IntersectionInfo(null,null,length),intersectInfo.faceId=index/2,fastCheck))break}return intersectInfo}_intersectUnIndexedLines(ray,positions,indices,intersectionThreshold,fastCheck){indices=null;for(let index=this.verticesStart;index<this.verticesStart+this.verticesCount;index+=2){const length=ray.intersectionSegment(positions[index],positions[index+
1],intersectionThreshold);if(!(0>length)&&(fastCheck||!indices||length<indices.distance)&&(indices=new _intersectionInfo.IntersectionInfo(null,null,length),indices.faceId=index/2,fastCheck))break}return indices}_intersectTriangles(ray,positions,indices,step,checkStopper,fastCheck,trianglePredicate){let intersectInfo=null,faceId=-1;for(let index=this.indexStart;index<this.indexStart+this.indexCount-(3-step);index+=step){faceId++;var indexA=indices[index];const indexB=indices[index+1],indexC=indices[index+
2];if(checkStopper&&4294967295===indexC){index+=2;continue}const p0=positions[indexA],p1=positions[indexB],p2=positions[indexC];if(p0&&p1&&p2&&(!trianglePredicate||trianglePredicate(p0,p1,p2,ray,indexA,indexB,indexC))&&(indexA=ray.intersectsTriangle(p0,p1,p2))&&!(0>indexA.distance)&&(fastCheck||!intersectInfo||indexA.distance<intersectInfo.distance)&&(intersectInfo=indexA,intersectInfo.faceId=faceId,fastCheck))break}return intersectInfo}_intersectUnIndexedTriangles(ray,positions,indices,fastCheck,
trianglePredicate){indices=null;for(let index=this.verticesStart;index<this.verticesStart+this.verticesCount;index+=3){var p0=positions[index];const p1=positions[index+1],p2=positions[index+2];if(!(trianglePredicate&&!trianglePredicate(p0,p1,p2,ray,-1,-1,-1)||!(p0=ray.intersectsTriangle(p0,p1,p2))||0>p0.distance)&&(fastCheck||!indices||p0.distance<indices.distance)&&(indices=p0,indices.faceId=index/3,fastCheck))break}return indices}_rebuild(){this._linesIndexBuffer&&(this._linesIndexBuffer=null)}clone(newMesh,
newRenderingMesh){newMesh=new SubMesh(this.materialIndex,this.verticesStart,this.verticesCount,this.indexStart,this.indexCount,newMesh,newRenderingMesh,!1);if(!this.IsGlobal){newRenderingMesh=this.getBoundingInfo();if(!newRenderingMesh)return newMesh;newMesh._boundingInfo=new _boundingInfo.BoundingInfo(newRenderingMesh.minimum,newRenderingMesh.maximum)}return newMesh}dispose(){this._linesIndexBuffer&&(this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer),this._linesIndexBuffer=
null);const index=this._mesh.subMeshes.indexOf(this);this._mesh.subMeshes.splice(index,1);this.resetDrawCache()}getClassName(){return"SubMesh"}static CreateFromIndices(materialIndex,startIndex,indexCount,mesh,renderingMesh,createBoundingBox=!0){let minVertexIndex=Number.MAX_VALUE,maxVertexIndex=-Number.MAX_VALUE;const indices=(renderingMesh||mesh).getIndices();for(let index=startIndex;index<startIndex+indexCount;index++){const vertexIndex=indices[index];vertexIndex<minVertexIndex&&(minVertexIndex=
vertexIndex);vertexIndex>maxVertexIndex&&(maxVertexIndex=vertexIndex)}return new SubMesh(materialIndex,minVertexIndex,maxVertexIndex-minVertexIndex+1,startIndex,indexCount,mesh,renderingMesh,createBoundingBox)}}exports.SubMesh=SubMesh}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Meshes$subMesh.js.map
