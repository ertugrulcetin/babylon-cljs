shadow$provide.module$node_modules$$babylonjs$core$Culling$boundingInfo=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.BoundingInfo=void 0;global=require("module$node_modules$$babylonjs$core$Misc$arrayTools");var _mathVector=require("module$node_modules$$babylonjs$core$Maths$math_vector"),_boundingBox=require("module$node_modules$$babylonjs$core$Culling$boundingBox"),_boundingSphere=require("module$node_modules$$babylonjs$core$Culling$boundingSphere");
const _result0={min:0,max:0},_result1={min:0,max:0},computeBoxExtents=(axis,box,result)=>{const p=_mathVector.Vector3.Dot(box.centerWorld,axis);var r0=Math.abs(_mathVector.Vector3.Dot(box.directions[0],axis))*box.extendSize.x;const r1=Math.abs(_mathVector.Vector3.Dot(box.directions[1],axis))*box.extendSize.y;axis=Math.abs(_mathVector.Vector3.Dot(box.directions[2],axis))*box.extendSize.z;r0=r0+r1+axis;result.min=p-r0;result.max=p+r0},axisOverlap=(axis,box0,box1)=>{computeBoxExtents(axis,box0,_result0);
computeBoxExtents(axis,box1,_result1);return!(_result0.min>_result1.max||_result1.min>_result0.max)};class BoundingInfo{constructor(minimum,maximum,worldMatrix){this._isLocked=!1;this.boundingBox=new _boundingBox.BoundingBox(minimum,maximum,worldMatrix);this.boundingSphere=new _boundingSphere.BoundingSphere(minimum,maximum,worldMatrix)}reConstruct(min,max,worldMatrix){this.boundingBox.reConstruct(min,max,worldMatrix);this.boundingSphere.reConstruct(min,max,worldMatrix)}get minimum(){return this.boundingBox.minimum}get maximum(){return this.boundingBox.maximum}get isLocked(){return this._isLocked}set isLocked(value){this._isLocked=
value}update(world){this._isLocked||(this.boundingBox._update(world),this.boundingSphere._update(world))}centerOn(center,extend){const minimum=BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);center=BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);this.boundingBox.reConstruct(minimum,center,this.boundingBox.getWorldMatrix());this.boundingSphere.reConstruct(minimum,center,this.boundingBox.getWorldMatrix());return this}encapsulate(point){const minimum=_mathVector.Vector3.Minimize(this.minimum,
point);point=_mathVector.Vector3.Maximize(this.maximum,point);this.reConstruct(minimum,point,this.boundingBox.getWorldMatrix());return this}encapsulateBoundingInfo(toEncapsulate){const invw=_mathVector.TmpVectors.Matrix[0];this.boundingBox.getWorldMatrix().invertToRef(invw);const v=_mathVector.TmpVectors.Vector3[0];_mathVector.Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.minimumWorld,invw,v);this.encapsulate(v);_mathVector.Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.maximumWorld,
invw,v);this.encapsulate(v);return this}scale(factor){this.boundingBox.scale(factor);this.boundingSphere.scale(factor);return this}isInFrustum(frustumPlanes,strategy=0){return 2!==strategy&&3!==strategy||!this.boundingSphere.isCenterInFrustum(frustumPlanes)?this.boundingSphere.isInFrustum(frustumPlanes)?1===strategy||3===strategy?!0:this.boundingBox.isInFrustum(frustumPlanes):!1:!0}get diagonalLength(){const boundingBox=this.boundingBox;return boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld,
BoundingInfo._TmpVector3[0]).length()}isCompletelyInFrustum(frustumPlanes){return this.boundingBox.isCompletelyInFrustum(frustumPlanes)}_checkCollision(collider){return collider._canDoCollision(this.boundingSphere.centerWorld,this.boundingSphere.radiusWorld,this.boundingBox.minimumWorld,this.boundingBox.maximumWorld)}intersectsPoint(point){return this.boundingSphere.centerWorld&&this.boundingSphere.intersectsPoint(point)&&this.boundingBox.intersectsPoint(point)?!0:!1}intersects(boundingInfo,precise){if(!_boundingSphere.BoundingSphere.Intersects(this.boundingSphere,
boundingInfo.boundingSphere)||!_boundingBox.BoundingBox.Intersects(this.boundingBox,boundingInfo.boundingBox))return!1;if(!precise)return!0;precise=this.boundingBox;boundingInfo=boundingInfo.boundingBox;return axisOverlap(precise.directions[0],precise,boundingInfo)&&axisOverlap(precise.directions[1],precise,boundingInfo)&&axisOverlap(precise.directions[2],precise,boundingInfo)&&axisOverlap(boundingInfo.directions[0],precise,boundingInfo)&&axisOverlap(boundingInfo.directions[1],precise,boundingInfo)&&
axisOverlap(boundingInfo.directions[2],precise,boundingInfo)&&axisOverlap(_mathVector.Vector3.Cross(precise.directions[0],boundingInfo.directions[0]),precise,boundingInfo)&&axisOverlap(_mathVector.Vector3.Cross(precise.directions[0],boundingInfo.directions[1]),precise,boundingInfo)&&axisOverlap(_mathVector.Vector3.Cross(precise.directions[0],boundingInfo.directions[2]),precise,boundingInfo)&&axisOverlap(_mathVector.Vector3.Cross(precise.directions[1],boundingInfo.directions[0]),precise,boundingInfo)&&
axisOverlap(_mathVector.Vector3.Cross(precise.directions[1],boundingInfo.directions[1]),precise,boundingInfo)&&axisOverlap(_mathVector.Vector3.Cross(precise.directions[1],boundingInfo.directions[2]),precise,boundingInfo)&&axisOverlap(_mathVector.Vector3.Cross(precise.directions[2],boundingInfo.directions[0]),precise,boundingInfo)&&axisOverlap(_mathVector.Vector3.Cross(precise.directions[2],boundingInfo.directions[1]),precise,boundingInfo)&&axisOverlap(_mathVector.Vector3.Cross(precise.directions[2],
boundingInfo.directions[2]),precise,boundingInfo)?!0:!1}}exports.BoundingInfo=BoundingInfo;BoundingInfo._TmpVector3=global.ArrayTools.BuildArray(2,_mathVector.Vector3.Zero)}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Culling$boundingInfo.js.map
