shadow$provide.module$node_modules$$babylonjs$core$abstractScene=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.AbstractScene=void 0;class AbstractScene{constructor(){this.rootNodes=[];this.cameras=[];this.lights=[];this.meshes=[];this.skeletons=[];this.particleSystems=[];this.animations=[];this.animationGroups=[];this.multiMaterials=[];this.materials=[];this.morphTargetManagers=[];this.geometries=[];this.transformNodes=[];this.actionManagers=
[];this.textures=[];this._environmentTexture=null;this.postProcesses=[]}static AddParser(name,parser){this._BabylonFileParsers[name]=parser}static GetParser(name){return this._BabylonFileParsers[name]?this._BabylonFileParsers[name]:null}static AddIndividualParser(name,parser){this._IndividualBabylonFileParsers[name]=parser}static GetIndividualParser(name){return this._IndividualBabylonFileParsers[name]?this._IndividualBabylonFileParsers[name]:null}static Parse(jsonData,scene,container,rootUrl){for(const parserName in this._BabylonFileParsers)if(Object.prototype.hasOwnProperty.call(this._BabylonFileParsers,
parserName))this._BabylonFileParsers[parserName](jsonData,scene,container,rootUrl)}get environmentTexture(){return this._environmentTexture}set environmentTexture(value){this._environmentTexture=value}getNodes(){let nodes=[];nodes=nodes.concat(this.meshes);nodes=nodes.concat(this.lights);nodes=nodes.concat(this.cameras);nodes=nodes.concat(this.transformNodes);this.skeletons.forEach(skeleton=>nodes=nodes.concat(skeleton.bones));return nodes}}exports.AbstractScene=AbstractScene;AbstractScene._BabylonFileParsers=
{};AbstractScene._IndividualBabylonFileParsers={}}
//# sourceMappingURL=module$node_modules$$babylonjs$core$abstractScene.js.map
