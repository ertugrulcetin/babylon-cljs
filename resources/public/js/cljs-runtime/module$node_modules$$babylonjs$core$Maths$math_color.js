shadow$provide.module$node_modules$$babylonjs$core$Maths$math_color=function(global,require,module,exports){function colorChannelToLinearSpace(color){return Math.pow(color,_mathConstants.ToLinearSpace)}function colorChannelToLinearSpaceExact(color){return.04045>=color?.0773993808*color:Math.pow(.947867299*(color+.055),2.4)}function colorChannelToGammaSpace(color){return Math.pow(color,_mathConstants.ToGammaSpace)}function colorChannelToGammaSpaceExact(color){return.0031308>=color?12.92*color:1.055*
Math.pow(color,.41666)-.055}Object.defineProperty(exports,"__esModule",{value:!0});exports.TmpColors=exports.Color4=exports.Color3=void 0;var _mathScalar=require("module$node_modules$$babylonjs$core$Maths$math_scalar"),_mathConstants=require("module$node_modules$$babylonjs$core$Maths$math_constants");global=require("module$node_modules$$babylonjs$core$Misc$arrayTools");require=require("module$node_modules$$babylonjs$core$Misc$typeStore");class Color3{constructor(r=0,g=0,b=0){this.r=r;this.g=g;this.b=
b}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+"}"}getClassName(){return"Color3"}getHashCode(){let hash=255*this.r|0;hash=397*hash^(255*this.g|0);return hash=397*hash^(255*this.b|0)}toArray(array,index=0){array[index]=this.r;array[index+1]=this.g;array[index+2]=this.b;return this}fromArray(array,offset=0){Color3.FromArrayToRef(array,offset,this);return this}toColor4(alpha=1){return new Color4(this.r,this.g,this.b,alpha)}asArray(){return[this.r,this.g,this.b]}toLuminance(){return.3*this.r+
.59*this.g+.11*this.b}multiply(otherColor){return new Color3(this.r*otherColor.r,this.g*otherColor.g,this.b*otherColor.b)}multiplyToRef(otherColor,result){result.r=this.r*otherColor.r;result.g=this.g*otherColor.g;result.b=this.b*otherColor.b;return this}equals(otherColor){return otherColor&&this.r===otherColor.r&&this.g===otherColor.g&&this.b===otherColor.b}equalsFloats(r,g,b){return this.r===r&&this.g===g&&this.b===b}scale(scale){return new Color3(this.r*scale,this.g*scale,this.b*scale)}scaleInPlace(scale){this.r*=
scale;this.g*=scale;this.b*=scale;return this}scaleToRef(scale,result){result.r=this.r*scale;result.g=this.g*scale;result.b=this.b*scale;return this}scaleAndAddToRef(scale,result){result.r+=this.r*scale;result.g+=this.g*scale;result.b+=this.b*scale;return this}clampToRef(min=0,max=1,result){result.r=_mathScalar.Scalar.Clamp(this.r,min,max);result.g=_mathScalar.Scalar.Clamp(this.g,min,max);result.b=_mathScalar.Scalar.Clamp(this.b,min,max);return this}add(otherColor){return new Color3(this.r+otherColor.r,
this.g+otherColor.g,this.b+otherColor.b)}addToRef(otherColor,result){result.r=this.r+otherColor.r;result.g=this.g+otherColor.g;result.b=this.b+otherColor.b;return this}subtract(otherColor){return new Color3(this.r-otherColor.r,this.g-otherColor.g,this.b-otherColor.b)}subtractToRef(otherColor,result){result.r=this.r-otherColor.r;result.g=this.g-otherColor.g;result.b=this.b-otherColor.b;return this}clone(){return new Color3(this.r,this.g,this.b)}copyFrom(source){this.r=source.r;this.g=source.g;this.b=
source.b;return this}copyFromFloats(r,g,b){this.r=r;this.g=g;this.b=b;return this}set(r,g,b){return this.copyFromFloats(r,g,b)}toHexString(){const intG=Math.round(255*this.g),intB=Math.round(255*this.b);return"#"+_mathScalar.Scalar.ToHex(Math.round(255*this.r))+_mathScalar.Scalar.ToHex(intG)+_mathScalar.Scalar.ToHex(intB)}toHSV(){const result=new Color3;this.toHSVToRef(result);return result}toHSVToRef(result){const r=this.r,g=this.g,b=this.b,max=Math.max(r,g,b),min=Math.min(r,g,b);let h=0,s=0;const dm=
max-min;0!==max&&(s=dm/max);max!=min&&(max==r?(h=(g-b)/dm,g<b&&(h+=6)):max==g?h=(b-r)/dm+2:max==b&&(h=(r-g)/dm+4),h*=60);result.r=h;result.g=s;result.b=max}toLinearSpace(exact=!1){const convertedColor=new Color3;this.toLinearSpaceToRef(convertedColor,exact);return convertedColor}toLinearSpaceToRef(convertedColor,exact=!1){exact?(convertedColor.r=colorChannelToLinearSpaceExact(this.r),convertedColor.g=colorChannelToLinearSpaceExact(this.g),convertedColor.b=colorChannelToLinearSpaceExact(this.b)):(convertedColor.r=
colorChannelToLinearSpace(this.r),convertedColor.g=colorChannelToLinearSpace(this.g),convertedColor.b=colorChannelToLinearSpace(this.b));return this}toGammaSpace(exact=!1){const convertedColor=new Color3;this.toGammaSpaceToRef(convertedColor,exact);return convertedColor}toGammaSpaceToRef(convertedColor,exact=!1){exact?(convertedColor.r=colorChannelToGammaSpaceExact(this.r),convertedColor.g=colorChannelToGammaSpaceExact(this.g),convertedColor.b=colorChannelToGammaSpaceExact(this.b)):(convertedColor.r=
colorChannelToGammaSpace(this.r),convertedColor.g=colorChannelToGammaSpace(this.g),convertedColor.b=colorChannelToGammaSpace(this.b));return this}static HSVtoRGBToRef(hue,saturation,value,result){saturation*=value;const h=hue/60,x=saturation*(1-Math.abs(h%2-1));let g=hue=0,b=0;0<=h&&1>=h?(hue=saturation,g=x):1<=h&&2>=h?(hue=x,g=saturation):2<=h&&3>=h?(g=saturation,b=x):3<=h&&4>=h?(g=x,b=saturation):4<=h&&5>=h?(hue=x,b=saturation):5<=h&&6>=h&&(hue=saturation,b=x);value-=saturation;result.set(hue+value,
g+value,b+value)}static FromHSV(hue,saturation,value){const result=new Color3(0,0,0);Color3.HSVtoRGBToRef(hue,saturation,value,result);return result}static FromHexString(hex){if("#"!==hex.substring(0,1)||7!==hex.length)return new Color3(0,0,0);const r=parseInt(hex.substring(1,3),16),g=parseInt(hex.substring(3,5),16);hex=parseInt(hex.substring(5,7),16);return Color3.FromInts(r,g,hex)}static FromArray(array,offset=0){return new Color3(array[offset],array[offset+1],array[offset+2])}static FromArrayToRef(array,
offset=0,result){result.r=array[offset];result.g=array[offset+1];result.b=array[offset+2]}static FromInts(r,g,b){return new Color3(r/255,g/255,b/255)}static Lerp(start,end,amount){const result=new Color3(0,0,0);Color3.LerpToRef(start,end,amount,result);return result}static LerpToRef(left,right,amount,result){result.r=left.r+(right.r-left.r)*amount;result.g=left.g+(right.g-left.g)*amount;result.b=left.b+(right.b-left.b)*amount}static Hermite(value1,tangent1,value2,tangent2,amount){var squared=amount*
amount;const cubed=amount*squared,part1=2*cubed-3*squared+1,part2=-2*cubed+3*squared;amount=cubed-2*squared+amount;squared=cubed-squared;return new Color3(value1.r*part1+value2.r*part2+tangent1.r*amount+tangent2.r*squared,value1.g*part1+value2.g*part2+tangent1.g*amount+tangent2.g*squared,value1.b*part1+value2.b*part2+tangent1.b*amount+tangent2.b*squared)}static Hermite1stDerivative(value1,tangent1,value2,tangent2,time){const result=Color3.Black();this.Hermite1stDerivativeToRef(value1,tangent1,value2,
tangent2,time,result);return result}static Hermite1stDerivativeToRef(value1,tangent1,value2,tangent2,time,result){const t2=time*time;result.r=6*(t2-time)*value1.r+(3*t2-4*time+1)*tangent1.r+6*(-t2+time)*value2.r+(3*t2-2*time)*tangent2.r;result.g=6*(t2-time)*value1.g+(3*t2-4*time+1)*tangent1.g+6*(-t2+time)*value2.g+(3*t2-2*time)*tangent2.g;result.b=6*(t2-time)*value1.b+(3*t2-4*time+1)*tangent1.b+6*(-t2+time)*value2.b+(3*t2-2*time)*tangent2.b}static Red(){return new Color3(1,0,0)}static Green(){return new Color3(0,
1,0)}static Blue(){return new Color3(0,0,1)}static Black(){return new Color3(0,0,0)}static get BlackReadOnly(){return Color3._BlackReadOnly}static White(){return new Color3(1,1,1)}static Purple(){return new Color3(.5,0,.5)}static Magenta(){return new Color3(1,0,1)}static Yellow(){return new Color3(1,1,0)}static Gray(){return new Color3(.5,.5,.5)}static Teal(){return new Color3(0,1,1)}static Random(){return new Color3(Math.random(),Math.random(),Math.random())}}exports.Color3=Color3;Color3._BlackReadOnly=
Color3.Black();class Color4{constructor(r=0,g=0,b=0,a=1){this.r=r;this.g=g;this.b=b;this.a=a}addInPlace(right){this.r+=right.r;this.g+=right.g;this.b+=right.b;this.a+=right.a;return this}asArray(){return[this.r,this.g,this.b,this.a]}toArray(array,index=0){array[index]=this.r;array[index+1]=this.g;array[index+2]=this.b;array[index+3]=this.a;return this}fromArray(array,offset=0){Color4.FromArrayToRef(array,offset,this);return this}equals(otherColor){return otherColor&&this.r===otherColor.r&&this.g===
otherColor.g&&this.b===otherColor.b&&this.a===otherColor.a}add(right){return new Color4(this.r+right.r,this.g+right.g,this.b+right.b,this.a+right.a)}subtract(right){return new Color4(this.r-right.r,this.g-right.g,this.b-right.b,this.a-right.a)}subtractToRef(right,result){result.r=this.r-right.r;result.g=this.g-right.g;result.b=this.b-right.b;result.a=this.a-right.a;return this}scale(scale){return new Color4(this.r*scale,this.g*scale,this.b*scale,this.a*scale)}scaleInPlace(scale){this.r*=scale;this.g*=
scale;this.b*=scale;this.a*=scale;return this}scaleToRef(scale,result){result.r=this.r*scale;result.g=this.g*scale;result.b=this.b*scale;result.a=this.a*scale;return this}scaleAndAddToRef(scale,result){result.r+=this.r*scale;result.g+=this.g*scale;result.b+=this.b*scale;result.a+=this.a*scale;return this}clampToRef(min=0,max=1,result){result.r=_mathScalar.Scalar.Clamp(this.r,min,max);result.g=_mathScalar.Scalar.Clamp(this.g,min,max);result.b=_mathScalar.Scalar.Clamp(this.b,min,max);result.a=_mathScalar.Scalar.Clamp(this.a,
min,max);return this}multiply(color){return new Color4(this.r*color.r,this.g*color.g,this.b*color.b,this.a*color.a)}multiplyToRef(color,result){result.r=this.r*color.r;result.g=this.g*color.g;result.b=this.b*color.b;result.a=this.a*color.a;return result}toString(){return"{R: "+this.r+" G:"+this.g+" B:"+this.b+" A:"+this.a+"}"}getClassName(){return"Color4"}getHashCode(){let hash=255*this.r|0;hash=397*hash^(255*this.g|0);hash=397*hash^(255*this.b|0);return hash=397*hash^(255*this.a|0)}clone(){return new Color4(this.r,
this.g,this.b,this.a)}copyFrom(source){this.r=source.r;this.g=source.g;this.b=source.b;this.a=source.a;return this}copyFromFloats(r,g,b,a){this.r=r;this.g=g;this.b=b;this.a=a;return this}set(r,g,b,a){return this.copyFromFloats(r,g,b,a)}toHexString(returnAsColor3=!1){const intR=Math.round(255*this.r),intG=Math.round(255*this.g),intB=Math.round(255*this.b);if(returnAsColor3)return"#"+_mathScalar.Scalar.ToHex(intR)+_mathScalar.Scalar.ToHex(intG)+_mathScalar.Scalar.ToHex(intB);returnAsColor3=Math.round(255*
this.a);return"#"+_mathScalar.Scalar.ToHex(intR)+_mathScalar.Scalar.ToHex(intG)+_mathScalar.Scalar.ToHex(intB)+_mathScalar.Scalar.ToHex(returnAsColor3)}toLinearSpace(exact=!1){const convertedColor=new Color4;this.toLinearSpaceToRef(convertedColor,exact);return convertedColor}toLinearSpaceToRef(convertedColor,exact=!1){exact?(convertedColor.r=colorChannelToLinearSpaceExact(this.r),convertedColor.g=colorChannelToLinearSpaceExact(this.g),convertedColor.b=colorChannelToLinearSpaceExact(this.b)):(convertedColor.r=
colorChannelToLinearSpace(this.r),convertedColor.g=colorChannelToLinearSpace(this.g),convertedColor.b=colorChannelToLinearSpace(this.b));convertedColor.a=this.a;return this}toGammaSpace(exact=!1){const convertedColor=new Color4;this.toGammaSpaceToRef(convertedColor,exact);return convertedColor}toGammaSpaceToRef(convertedColor,exact=!1){exact?(convertedColor.r=colorChannelToGammaSpaceExact(this.r),convertedColor.g=colorChannelToGammaSpaceExact(this.g),convertedColor.b=colorChannelToGammaSpaceExact(this.b)):
(convertedColor.r=colorChannelToGammaSpace(this.r),convertedColor.g=colorChannelToGammaSpace(this.g),convertedColor.b=colorChannelToGammaSpace(this.b));convertedColor.a=this.a;return this}static FromHexString(hex){if("#"!==hex.substring(0,1)||9!==hex.length&&7!==hex.length)return new Color4(0,0,0,0);const r=parseInt(hex.substring(1,3),16),g=parseInt(hex.substring(3,5),16),b=parseInt(hex.substring(5,7),16);hex=9===hex.length?parseInt(hex.substring(7,9),16):255;return Color4.FromInts(r,g,b,hex)}static Lerp(left,
right,amount){const result=new Color4(0,0,0,0);Color4.LerpToRef(left,right,amount,result);return result}static LerpToRef(left,right,amount,result){result.r=left.r+(right.r-left.r)*amount;result.g=left.g+(right.g-left.g)*amount;result.b=left.b+(right.b-left.b)*amount;result.a=left.a+(right.a-left.a)*amount}static Hermite(value1,tangent1,value2,tangent2,amount){var squared=amount*amount;const cubed=amount*squared,part1=2*cubed-3*squared+1,part2=-2*cubed+3*squared;amount=cubed-2*squared+amount;squared=
cubed-squared;return new Color4(value1.r*part1+value2.r*part2+tangent1.r*amount+tangent2.r*squared,value1.g*part1+value2.g*part2+tangent1.g*amount+tangent2.g*squared,value1.b*part1+value2.b*part2+tangent1.b*amount+tangent2.b*squared,value1.a*part1+value2.a*part2+tangent1.a*amount+tangent2.a*squared)}static Hermite1stDerivative(value1,tangent1,value2,tangent2,time){const result=new Color4;this.Hermite1stDerivativeToRef(value1,tangent1,value2,tangent2,time,result);return result}static Hermite1stDerivativeToRef(value1,
tangent1,value2,tangent2,time,result){const t2=time*time;result.r=6*(t2-time)*value1.r+(3*t2-4*time+1)*tangent1.r+6*(-t2+time)*value2.r+(3*t2-2*time)*tangent2.r;result.g=6*(t2-time)*value1.g+(3*t2-4*time+1)*tangent1.g+6*(-t2+time)*value2.g+(3*t2-2*time)*tangent2.g;result.b=6*(t2-time)*value1.b+(3*t2-4*time+1)*tangent1.b+6*(-t2+time)*value2.b+(3*t2-2*time)*tangent2.b;result.a=6*(t2-time)*value1.a+(3*t2-4*time+1)*tangent1.a+6*(-t2+time)*value2.a+(3*t2-2*time)*tangent2.a}static FromColor3(color3,alpha=
1){return new Color4(color3.r,color3.g,color3.b,alpha)}static FromArray(array,offset=0){return new Color4(array[offset],array[offset+1],array[offset+2],array[offset+3])}static FromArrayToRef(array,offset=0,result){result.r=array[offset];result.g=array[offset+1];result.b=array[offset+2];result.a=array[offset+3]}static FromInts(r,g,b,a){return new Color4(r/255,g/255,b/255,a/255)}static CheckColors4(colors,count){if(colors.length===3*count){count=[];for(let index=0;index<colors.length;index+=3){const newIndex=
index/3*4;count[newIndex]=colors[index];count[newIndex+1]=colors[index+1];count[newIndex+2]=colors[index+2];count[newIndex+3]=1}return count}return colors}}exports.Color4=Color4;class TmpColors{}exports.TmpColors=TmpColors;TmpColors.Color3=global.ArrayTools.BuildArray(3,Color3.Black);TmpColors.Color4=global.ArrayTools.BuildArray(3,()=>new Color4(0,0,0,0));(0,require.RegisterClass)("BABYLON.Color3",Color3);(0,require.RegisterClass)("BABYLON.Color4",Color4)}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Maths$math_color.js.map
