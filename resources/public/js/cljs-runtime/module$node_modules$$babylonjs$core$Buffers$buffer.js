shadow$provide.module$node_modules$$babylonjs$core$Buffers$buffer=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.VertexBuffer=exports.Buffer=void 0;var _dataBuffer=require("module$node_modules$$babylonjs$core$Buffers$dataBuffer");class Buffer{constructor(engine,data,updatable,stride=0,postponeInternalCreation=!1,instanced=!1,useBytes=!1,divisor){this._isAlreadyOwned=!1;this._engine=engine.getScene?engine.getScene().getEngine():engine;this._updatable=
updatable;this._instanced=instanced;this._divisor=divisor||1;data instanceof _dataBuffer.DataBuffer?(this._data=null,this._buffer=data):(this._data=data,this._buffer=null);this.byteStride=useBytes?stride:stride*Float32Array.BYTES_PER_ELEMENT;postponeInternalCreation||this.create()}createVertexBuffer(kind,offset,size,stride,instanced,useBytes=!1,divisor){return new VertexBuffer(this._engine,this,kind,this._updatable,!0,stride?useBytes?stride:stride*Float32Array.BYTES_PER_ELEMENT:this.byteStride,void 0===
instanced?this._instanced:instanced,useBytes?offset:offset*Float32Array.BYTES_PER_ELEMENT,size,void 0,void 0,!0,this._divisor||divisor)}isUpdatable(){return this._updatable}getData(){return this._data}getBuffer(){return this._buffer}getStrideSize(){return this.byteStride/Float32Array.BYTES_PER_ELEMENT}create(data=null){if(data||!this._buffer)if(data=data||this._data)this._buffer?this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,data),this._data=data):this._updatable?(this._buffer=
this._engine.createDynamicVertexBuffer(data),this._data=data):this._buffer=this._engine.createVertexBuffer(data)}_rebuild(){this._buffer=null;this.create(this._data)}update(data){this.create(data)}updateDirectly(data,offset,vertexCount,useBytes=!1){this._buffer&&this._updatable&&(this._engine.updateDynamicVertexBuffer(this._buffer,data,useBytes?offset:offset*Float32Array.BYTES_PER_ELEMENT,vertexCount?vertexCount*this.byteStride:void 0),this._data=0===offset&&void 0===vertexCount?data:null)}_increaseReferences(){this._buffer&&
(this._isAlreadyOwned?this._buffer.references++:this._isAlreadyOwned=!0)}dispose(){this._buffer&&this._engine._releaseBuffer(this._buffer)&&(this._data=this._buffer=null)}}exports.Buffer=Buffer;class VertexBuffer{get instanceDivisor(){return this._instanceDivisor}set instanceDivisor(value){const isInstanced=0!=value;this._instanceDivisor=value;isInstanced!==this._instanced&&(this._instanced=isInstanced,this._computeHashCode())}constructor(engine,data,kind,updatable,postponeInternalCreation,stride,
instanced,offset,size,type,normalized=!1,useBytes=!1,divisor=1,takeBufferOwnership=!1){data instanceof Buffer?(this._buffer=data,this._ownsBuffer=takeBufferOwnership):(this._buffer=new Buffer(engine,data,updatable,stride,postponeInternalCreation,instanced,useBytes),this._ownsBuffer=!0);this.uniqueId=VertexBuffer._Counter++;this._kind=kind;void 0==type?(engine=this.getData(),this.type=VertexBuffer.FLOAT,engine instanceof Int8Array?this.type=VertexBuffer.BYTE:engine instanceof Uint8Array?this.type=
VertexBuffer.UNSIGNED_BYTE:engine instanceof Int16Array?this.type=VertexBuffer.SHORT:engine instanceof Uint16Array?this.type=VertexBuffer.UNSIGNED_SHORT:engine instanceof Int32Array?this.type=VertexBuffer.INT:engine instanceof Uint32Array&&(this.type=VertexBuffer.UNSIGNED_INT)):this.type=type;engine=VertexBuffer.GetTypeByteLength(this.type);useBytes?(this._size=size||(stride?stride/engine:VertexBuffer.DeduceStride(kind)),this.byteStride=stride||this._buffer.byteStride||this._size*engine,this.byteOffset=
offset||0):(this._size=size||stride||VertexBuffer.DeduceStride(kind),this.byteStride=stride?stride*engine:this._buffer.byteStride||this._size*engine,this.byteOffset=(offset||0)*engine);this.normalized=normalized;this._instanced=void 0!==instanced?instanced:!1;this._instanceDivisor=instanced?divisor:0;this._computeHashCode()}_computeHashCode(){this.hashCode=(this.type-5120<<0)+((this.normalized?1:0)<<3)+(this._size<<4)+((this._instanced?1:0)<<6)+(this.byteStride<<12)}_rebuild(){this._buffer&&this._buffer._rebuild()}getKind(){return this._kind}isUpdatable(){return this._buffer.isUpdatable()}getData(){return this._buffer.getData()}getFloatData(totalVertices,
forceCopy){var data=this.getData();if(!data)return null;var tightlyPackedByteStride=this.getSize()*VertexBuffer.GetTypeByteLength(this.type);totalVertices*=this.getSize();if(this.type!==VertexBuffer.FLOAT||this.byteStride!==tightlyPackedByteStride){const copy=new Float32Array(totalVertices);this.forEach(totalVertices,(value,index)=>copy[index]=value);return copy}if(!(data instanceof Array||data instanceof Float32Array)||0!==this.byteOffset||data.length!==totalVertices){if(data instanceof Array)return forceCopy=
this.byteOffset/4,data.slice(forceCopy,forceCopy+totalVertices);if(data instanceof ArrayBuffer)return new Float32Array(data,this.byteOffset,totalVertices);tightlyPackedByteStride=data.byteOffset+this.byteOffset;if(forceCopy)return forceCopy=new Float32Array(totalVertices),data=new Float32Array(data.buffer,tightlyPackedByteStride,totalVertices),forceCopy.set(data),forceCopy;(forceCopy=tightlyPackedByteStride%4)&&(tightlyPackedByteStride=Math.max(0,tightlyPackedByteStride-forceCopy));return new Float32Array(data.buffer,
tightlyPackedByteStride,totalVertices)}return forceCopy?data.slice():data}getBuffer(){return this._buffer.getBuffer()}getStrideSize(){return this.byteStride/VertexBuffer.GetTypeByteLength(this.type)}getOffset(){return this.byteOffset/VertexBuffer.GetTypeByteLength(this.type)}getSize(sizeInBytes=!1){return sizeInBytes?this._size*VertexBuffer.GetTypeByteLength(this.type):this._size}getIsInstanced(){return this._instanced}getInstanceDivisor(){return this._instanceDivisor}create(data){this._buffer.create(data)}update(data){this._buffer.update(data)}updateDirectly(data,
offset,useBytes=!1){this._buffer.updateDirectly(data,offset,void 0,useBytes)}dispose(){this._ownsBuffer&&this._buffer.dispose()}forEach(count,callback){VertexBuffer.ForEach(this._buffer.getData(),this.byteOffset,this.byteStride,this._size,this.type,count,this.normalized,callback)}static DeduceStride(kind){switch(kind){case VertexBuffer.UVKind:case VertexBuffer.UV2Kind:case VertexBuffer.UV3Kind:case VertexBuffer.UV4Kind:case VertexBuffer.UV5Kind:case VertexBuffer.UV6Kind:return 2;case VertexBuffer.NormalKind:case VertexBuffer.PositionKind:return 3;
case VertexBuffer.ColorKind:case VertexBuffer.MatricesIndicesKind:case VertexBuffer.MatricesIndicesExtraKind:case VertexBuffer.MatricesWeightsKind:case VertexBuffer.MatricesWeightsExtraKind:case VertexBuffer.TangentKind:return 4;default:throw Error("Invalid kind '"+kind+"'");}}static GetTypeByteLength(type){switch(type){case VertexBuffer.BYTE:case VertexBuffer.UNSIGNED_BYTE:return 1;case VertexBuffer.SHORT:case VertexBuffer.UNSIGNED_SHORT:return 2;case VertexBuffer.INT:case VertexBuffer.UNSIGNED_INT:case VertexBuffer.FLOAT:return 4;
default:throw Error(`Invalid type '${type}'`);}}static ForEach(data,byteOffset,byteStride,componentCount,componentType,count,normalized,callback){if(data instanceof Array)for(byteOffset/=4,byteStride/=4,componentType=0;componentType<count;componentType+=componentCount){for(normalized=0;normalized<componentCount;normalized++)callback(data[byteOffset+normalized],componentType+normalized);byteOffset+=byteStride}else{data=data instanceof ArrayBuffer?new DataView(data):new DataView(data.buffer,data.byteOffset,
data.byteLength);const componentByteLength=VertexBuffer.GetTypeByteLength(componentType);for(let index=0;index<count;index+=componentCount){let componentByteOffset=byteOffset;for(let componentIndex=0;componentIndex<componentCount;componentIndex++){const value=VertexBuffer._GetFloatValue(data,componentType,componentByteOffset,normalized);callback(value,index+componentIndex);componentByteOffset+=componentByteLength}byteOffset+=byteStride}}}static _GetFloatValue(dataView,type,byteOffset,normalized){switch(type){case VertexBuffer.BYTE:return dataView=
dataView.getInt8(byteOffset),normalized&&(dataView=Math.max(dataView/127,-1)),dataView;case VertexBuffer.UNSIGNED_BYTE:return dataView=dataView.getUint8(byteOffset),normalized&&(dataView/=255),dataView;case VertexBuffer.SHORT:return dataView=dataView.getInt16(byteOffset,!0),normalized&&(dataView=Math.max(dataView/32767,-1)),dataView;case VertexBuffer.UNSIGNED_SHORT:return dataView=dataView.getUint16(byteOffset,!0),normalized&&(dataView/=65535),dataView;case VertexBuffer.INT:return dataView.getInt32(byteOffset,
!0);case VertexBuffer.UNSIGNED_INT:return dataView.getUint32(byteOffset,!0);case VertexBuffer.FLOAT:return dataView.getFloat32(byteOffset,!0);default:throw Error(`Invalid component type ${type}`);}}}exports.VertexBuffer=VertexBuffer;VertexBuffer._Counter=0;VertexBuffer.BYTE=5120;VertexBuffer.UNSIGNED_BYTE=5121;VertexBuffer.SHORT=5122;VertexBuffer.UNSIGNED_SHORT=5123;VertexBuffer.INT=5124;VertexBuffer.UNSIGNED_INT=5125;VertexBuffer.FLOAT=5126;VertexBuffer.PositionKind="position";VertexBuffer.NormalKind=
"normal";VertexBuffer.TangentKind="tangent";VertexBuffer.UVKind="uv";VertexBuffer.UV2Kind="uv2";VertexBuffer.UV3Kind="uv3";VertexBuffer.UV4Kind="uv4";VertexBuffer.UV5Kind="uv5";VertexBuffer.UV6Kind="uv6";VertexBuffer.ColorKind="color";VertexBuffer.ColorInstanceKind="instanceColor";VertexBuffer.MatricesIndicesKind="matricesIndices";VertexBuffer.MatricesWeightsKind="matricesWeights";VertexBuffer.MatricesIndicesExtraKind="matricesIndicesExtra";VertexBuffer.MatricesWeightsExtraKind="matricesWeightsExtra"}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Buffers$buffer.js.map
