{
"version":3,
"file":"module$node_modules$$babylonjs$core$Actions$abstractActionManager.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,iEAAA,CAAsF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG9HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,qBAAR,CAAgC,IAAK,EAOrC,MAAMA,sBAAN,CACEC,WAAW,EAAG,CAEZ,IAAKC,CAAAA,WAAL,CAAmB,EAGnB,KAAKC,CAAAA,OAAL,CAAe,EAKf,KAAKC,CAAAA,WAAL,CAAmB,CAAA,CAVP,CAiBH,sBAAc,EAAA,CACvB,IAAK,MAAMC,CAAX,GAAgBL,sBAAsBM,CAAAA,QAAtC,CACE,GAAIT,MAAOU,CAAAA,SAAUC,CAAAA,cAAeC,CAAAA,IAAhC,CAAqCT,qBAAsBM,CAAAA,QAA3D,CAAqED,CAArE,CAAJ,CACE,MAAO,CAAA,CAIX,OAAO,CAAA,CAPgB,CAcd,0BAAkB,EAAA,CAC3B,IAAK,MAAMA,CAAX,GAAgBL,sBAAsBM,CAAAA,QAAtC,CACE,GAAIT,MAAOU,CAAAA,SAAUC,CAAAA,cAAeC,CAAAA,IAAhC,CAAqCT,qBAAsBM,CAAAA,QAA3D;AAAqED,CAArE,CAAJ,CAA6E,CAC3E,MAAMK,OAASC,QAAA,CAASN,CAAT,CAEf,IAAc,CAAd,EAAIK,MAAJ,EAA6B,CAA7B,EAAmBA,MAAnB,CACE,MAAO,CAAA,CAJkE,CAS/E,MAAO,CAAA,CAXoB,CAoBtBE,yBAAkB,CAACC,OAAD,CAAU,CACjC,IAAK,MAAMR,CAAX,GAAgBL,sBAAsBM,CAAAA,QAAtC,CACE,GAAIT,MAAOU,CAAAA,SAAUC,CAAAA,cAAeC,CAAAA,IAAhC,CAAqCT,qBAAsBM,CAAAA,QAA3D,CAAqED,CAArE,CAAJ,EACiBM,QAAAD,CAASL,CAATK,CADjB,GAGiBG,OAHjB,CAII,MAAO,CAAA,CAKb,OAAO,CAAA,CAX0B,CApDrC,CAsEAjB,OAAQI,CAAAA,qBAAR,CAAgCA,qBAChCA,sBAAsBM,CAAAA,QAAtB,CAAiC,EApF6F;",
"sources":["node_modules/@babylonjs/core/Actions/abstractActionManager.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$babylonjs$core$Actions$abstractActionManager\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AbstractActionManager = void 0;\n\n/**\n * Abstract class used to decouple action Manager from scene and meshes.\n * Do not instantiate.\n * @see https://doc.babylonjs.com/features/featuresDeepDive/events/actions\n */\nclass AbstractActionManager {\n  constructor() {\n    /** Gets the cursor to use when hovering items */\n    this.hoverCursor = \"\";\n    /** Gets the list of actions */\n\n    this.actions = new Array();\n    /**\n     * Gets or sets a boolean indicating that the manager is recursive meaning that it can trigger action from children\n     */\n\n    this.isRecursive = false;\n  }\n  /**\n   * Does exist one action manager with at least one trigger\n   **/\n\n\n  static get HasTriggers() {\n    for (const t in AbstractActionManager.Triggers) {\n      if (Object.prototype.hasOwnProperty.call(AbstractActionManager.Triggers, t)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Does exist one action manager with at least one pick trigger\n   **/\n\n\n  static get HasPickTriggers() {\n    for (const t in AbstractActionManager.Triggers) {\n      if (Object.prototype.hasOwnProperty.call(AbstractActionManager.Triggers, t)) {\n        const tAsInt = parseInt(t);\n\n        if (tAsInt >= 1 && tAsInt <= 7) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n  /**\n   * Does exist one action manager that handles actions of a given trigger\n   * @param trigger defines the trigger to be tested\n   * @returns a boolean indicating whether the trigger is handled by at least one action manager\n   **/\n\n\n  static HasSpecificTrigger(trigger) {\n    for (const t in AbstractActionManager.Triggers) {\n      if (Object.prototype.hasOwnProperty.call(AbstractActionManager.Triggers, t)) {\n        const tAsInt = parseInt(t);\n\n        if (tAsInt === trigger) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  }\n\n}\n/** Gets the list of active triggers */\n\n\nexports.AbstractActionManager = AbstractActionManager;\nAbstractActionManager.Triggers = {};\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","AbstractActionManager","constructor","hoverCursor","actions","isRecursive","t","Triggers","prototype","hasOwnProperty","call","tAsInt","parseInt","HasSpecificTrigger","trigger"]
}
