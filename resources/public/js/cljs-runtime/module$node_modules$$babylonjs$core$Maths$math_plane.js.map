{
"version":3,
"file":"module$node_modules$$babylonjs$core$Maths$math_plane.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/@babylonjs/core/Maths/math.plane.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$babylonjs$core$Maths$math_plane\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Plane = void 0;\n\nvar _mathVector = require(\"./math.vector.js\");\n\n/**\n * Represents a plane by the equation ax + by + cz + d = 0\n */\nclass Plane {\n  /**\n   * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\n   * @param a a component of the plane\n   * @param b b component of the plane\n   * @param c c component of the plane\n   * @param d d component of the plane\n   */\n  constructor(a, b, c, d) {\n    this.normal = new _mathVector.Vector3(a, b, c);\n    this.d = d;\n  }\n  /**\n   * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\n   */\n\n\n  asArray() {\n    return [this.normal.x, this.normal.y, this.normal.z, this.d];\n  } // Methods\n\n  /**\n   * @returns a new plane copied from the current Plane.\n   */\n\n\n  clone() {\n    return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\n  }\n  /**\n   * @returns the string \"Plane\".\n   */\n\n\n  getClassName() {\n    return \"Plane\";\n  }\n  /**\n   * @returns the Plane hash code.\n   */\n\n\n  getHashCode() {\n    let hash = this.normal.getHashCode();\n    hash = hash * 397 ^ (this.d | 0);\n    return hash;\n  }\n  /**\n   * Normalize the current Plane in place.\n   * @returns the updated Plane.\n   */\n\n\n  normalize() {\n    const norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);\n    let magnitude = 0.0;\n\n    if (norm !== 0) {\n      magnitude = 1.0 / norm;\n    }\n\n    this.normal.x *= magnitude;\n    this.normal.y *= magnitude;\n    this.normal.z *= magnitude;\n    this.d *= magnitude;\n    return this;\n  }\n  /**\n   * Applies a transformation the plane and returns the result\n   * @param transformation the transformation matrix to be applied to the plane\n   * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\n   */\n\n\n  transform(transformation) {\n    const invertedMatrix = Plane._TmpMatrix;\n    transformation.invertToRef(invertedMatrix);\n    const m = invertedMatrix.m;\n    const x = this.normal.x;\n    const y = this.normal.y;\n    const z = this.normal.z;\n    const d = this.d;\n    const normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\n    const normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\n    const normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\n    const finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\n    return new Plane(normalX, normalY, normalZ, finalD);\n  }\n  /**\n   * Compute the dot product between the point and the plane normal\n   * @param point point to calculate the dot product with\n   * @returns the dot product (float) of the point coordinates and the plane normal.\n   */\n\n\n  dotCoordinate(point) {\n    return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;\n  }\n  /**\n   * Updates the current Plane from the plane defined by the three given points.\n   * @param point1 one of the points used to construct the plane\n   * @param point2 one of the points used to construct the plane\n   * @param point3 one of the points used to construct the plane\n   * @returns the updated Plane.\n   */\n\n\n  copyFromPoints(point1, point2, point3) {\n    const x1 = point2.x - point1.x;\n    const y1 = point2.y - point1.y;\n    const z1 = point2.z - point1.z;\n    const x2 = point3.x - point1.x;\n    const y2 = point3.y - point1.y;\n    const z2 = point3.z - point1.z;\n    const yz = y1 * z2 - z1 * y2;\n    const xz = z1 * x2 - x1 * z2;\n    const xy = x1 * y2 - y1 * x2;\n    const pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);\n    let invPyth;\n\n    if (pyth !== 0) {\n      invPyth = 1.0 / pyth;\n    } else {\n      invPyth = 0.0;\n    }\n\n    this.normal.x = yz * invPyth;\n    this.normal.y = xz * invPyth;\n    this.normal.z = xy * invPyth;\n    this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);\n    return this;\n  }\n  /**\n   * Checks if the plane is facing a given direction (meaning if the plane's normal is pointing in the opposite direction of the given vector).\n   * Note that for this function to work as expected you should make sure that:\n   *   - direction and the plane normal are normalized\n   *   - epsilon is a number just bigger than -1, something like -0.99 for eg\n   * @param direction the direction to check if the plane is facing\n   * @param epsilon value the dot product is compared against (returns true if dot <= epsilon)\n   * @returns True if the plane is facing the given direction\n   */\n\n\n  isFrontFacingTo(direction, epsilon) {\n    const dot = _mathVector.Vector3.Dot(this.normal, direction);\n\n    return dot <= epsilon;\n  }\n  /**\n   * Calculates the distance to a point\n   * @param point point to calculate distance to\n   * @returns the signed distance (float) from the given point to the Plane.\n   */\n\n\n  signedDistanceTo(point) {\n    return _mathVector.Vector3.Dot(point, this.normal) + this.d;\n  } // Statics\n\n  /**\n   * Creates a plane from an  array\n   * @param array the array to create a plane from\n   * @returns a new Plane from the given array.\n   */\n\n\n  static FromArray(array) {\n    return new Plane(array[0], array[1], array[2], array[3]);\n  }\n  /**\n   * Creates a plane from three points\n   * @param point1 point used to create the plane\n   * @param point2 point used to create the plane\n   * @param point3 point used to create the plane\n   * @returns a new Plane defined by the three given points.\n   */\n\n\n  static FromPoints(point1, point2, point3) {\n    const result = new Plane(0.0, 0.0, 0.0, 0.0);\n    result.copyFromPoints(point1, point2, point3);\n    return result;\n  }\n  /**\n   * Creates a plane from an origin point and a normal\n   * @param origin origin of the plane to be constructed\n   * @param normal normal of the plane to be constructed\n   * @returns a new Plane the normal vector to this plane at the given origin point.\n   * Note : the vector \"normal\" is updated because normalized.\n   */\n\n\n  static FromPositionAndNormal(origin, normal) {\n    const result = new Plane(0.0, 0.0, 0.0, 0.0);\n    normal.normalize();\n    result.normal = normal;\n    result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n    return result;\n  }\n  /**\n   * Calculates the distance from a plane and a point\n   * @param origin origin of the plane to be constructed\n   * @param normal normal of the plane to be constructed\n   * @param point point to calculate distance to\n   * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\n   */\n\n\n  static SignedDistanceToPlaneFromPositionAndNormal(origin, normal, point) {\n    const d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n    return _mathVector.Vector3.Dot(point, normal) + d;\n  }\n\n}\n\nexports.Plane = Plane;\nPlane._TmpMatrix = _mathVector.Matrix.Identity();\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","Plane","_mathVector","constructor","a","b","c","d","normal","Vector3","asArray","x","y","z","clone","getClassName","getHashCode","hash","normalize","norm","Math","sqrt","magnitude","transform","transformation","invertedMatrix","_TmpMatrix","invertToRef","m","dotCoordinate","point","copyFromPoints","point1","point2","point3","x1","y1","z1","x2","y2","z2","yz","xz","xy","pyth","invPyth","isFrontFacingTo","direction","epsilon","Dot","dot","signedDistanceTo","FromArray","array","FromPoints","result","FromPositionAndNormal","origin","SignedDistanceToPlaneFromPositionAndNormal","Matrix","Identity"]
}
