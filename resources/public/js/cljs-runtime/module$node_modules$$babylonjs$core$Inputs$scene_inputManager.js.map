{
"version":3,
"file":"module$node_modules$$babylonjs$core$Inputs$scene_inputManager.js",
"lineCount":50,
"mappings":"AAAAA,cAAA,CAAA,6DAAA,CAAkF,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAG1HC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,YAAR,CAAuB,IAAK,EAE5B,KAAIC,eAAiBP,OAAA,CAAQ,0DAAR,CAArB,CAEIQ,uBAAyBR,OAAA,CAAQ,mEAAR,CAF7B,CAIIS,aAAeT,OAAA,CAAQ,4DAAR,CAJnB,CAMIU,YAAcV,OAAA,CAAQ,uDAAR,CANlB;AAQIW,aAAeX,OAAA,CAAQ,yDAAR,CARnB,CAUIY,gBAAkBZ,OAAA,CAAQ,2DAAR,CAVtB,CAYIa,aAAeb,OAAA,CAAQ,0EAAR,CAZnB,CAcIc,qBAAuBd,OAAA,CAAQ,kFAAR,CAd3B,CAgBIe,aAAef,OAAA,CAAQ,yDAAR,CAInB,MAAMgB,WAAN,CACEC,WAAW,EAAG,CAIZ,IAAKC,CAAAA,OAAL,CADA,IAAKC,CAAAA,UACL;AAFA,IAAKC,CAAAA,YAEL,CAHA,IAAKC,CAAAA,YAGL,CAHoB,CAAA,CADR,CAOV,eAAc,EAAA,CAChB,MAAO,KAAKA,CAAAA,YADI,CAId,eAAc,EAAA,CAChB,MAAO,KAAKD,CAAAA,YADI,CAId,aAAY,EAAA,CACd,MAAO,KAAKD,CAAAA,UADE,CAIZ,UAAS,EAAA,CACX,MAAO,KAAKD,CAAAA,OADD,CAIT,eAAW,CAACI,CAAD,CAAI,CACjB,IAAKD,CAAAA,YAAL,CAAoBC,CADH,CAIf,eAAW,CAACA,CAAD,CAAI,CACjB,IAAKF,CAAAA,YAAL,CAAoBE,CADH,CAIf,aAAS,CAACA,CAAD,CAAI,CACf,IAAKH,CAAAA,UAAL,CAAkBG,CADH,CAIb,UAAM,CAACA,CAAD,CAAI,CACZ,IAAKJ,CAAAA,OAAL,CAAeI,CADH,CApChB,CA8CA,KAAMhB,aAAN,CAKEW,WAAW,CAACM,KAAD,CAAQ,CAGjB,IAAKC,CAAAA,gBAAL,CADA,IAAKC,CAAAA,gBACL,CADwB,CAAA,CAGxB,KAAKC,CAAAA,mBAAL,CADA,IAAKC,CAAAA,kBACL,CAD0B,IAE1B,KAAKC,CAAAA,qBAAL;AAA6B,CAE7B,KAAKC,CAAAA,UAAL,CADA,IAAKC,CAAAA,mBACL,CAD2B,CAAA,CAE3B,KAAKC,CAAAA,mBAAL,CAA2B,CAAC,CAE5B,KAAKC,CAAAA,oBAAL,CADA,IAAKC,CAAAA,eACL,CADuB,CAAA,CAGvB,KAAKC,CAAAA,SAAL,CADA,IAAKC,CAAAA,SACL,CADiB,CAEjB,KAAKC,CAAAA,wBAAL,CAAgC,IAAI1B,WAAY2B,CAAAA,OAAhB,CAAwB,CAAxB,CAA2B,CAA3B,CAChC,KAAKC,CAAAA,gCAAL,CAAwC,IAAI5B,WAAY2B,CAAAA,OAAhB,CAAwB,CAAxB,CAA2B,CAA3B,CAExC,KAAKE,CAAAA,4BAAL,CADA,IAAKC,CAAAA,oBACL,CAD4B,CAE5B,KAAKC,CAAAA,gBAAL,CAAwB,EACxB,KAAKC,CAAAA,mBAAL,CAA2B,EAC3B,KAAKC,CAAAA,gBAAL,CAAwB,IACxB,KAAKC,CAAAA,oBAAL,CAA4B,CAC5B,KAAKC,CAAAA,cAAL,CAAsB,CAAC,IAAD,CAAO,IAAP,CAAa,IAAb,CAAmB,IAAnB,CAAyB,IAAzB,CACtB,KAAK/B,CAAAA,oBAAL;AAA4B,IAC5B,KAAKgC,CAAAA,MAAL,CAAcvB,KAAd,EAAuBR,YAAagC,CAAAA,WAAYC,CAAAA,gBAxB/B,CAoCf,oBAAmB,EAAA,CACjB,IAAKL,CAAAA,gBAAT,GAGE,IAAKA,CAAAA,gBAAiBM,CAAAA,iBAAtB,EAGA,CAAA,IAAKN,CAAAA,gBAAL,CAAwB,IAN1B,CASA,OAAO,KAAKO,CAAAA,gBAVS,CAmBvBC,8BAA8B,CAACC,SAAD,CAAY,CACxC,MAAO,KAAKV,CAAAA,mBAAL,CAAyBU,SAAzB,CAAP,EAA8C,IADN,CAStC,uBAAsB,EAAA,CACxB,MAAO,KAAI1C,WAAY2B,CAAAA,OAAhB,CAAwB,IAAKgB,CAAAA,qBAA7B,CAAoD,IAAKC,CAAAA,qBAAzD,CADiB,CAStB,YAAW,EAAA,CACb,MAAO,KAAKnB,CAAAA,SADC,CAIX,YAAQ,CAAC9B,KAAD,CAAQ,CAClB,IAAK8B,CAAAA,SAAL,CAAiB9B,KADC,CAShB,YAAW,EAAA,CACb,MAAO,KAAK6B,CAAAA,SADC,CAIX,YAAQ,CAAC7B,KAAD,CAAQ,CAClB,IAAK6B,CAAAA,SAAL;AAAiB7B,KADC,CAIpBkD,sBAAsB,CAACC,GAAD,CAAM,CAC1B,MAAMC,WAAa,IAAKX,CAAAA,MAAOY,CAAAA,SAAZ,EAAwBC,CAAAA,yBAAxB,EAEdF,WAAL,GAIA,IAAKtB,CAAAA,SAGL,CAHiBqB,GAAII,CAAAA,OAGrB,CAH+BH,UAAWI,CAAAA,IAG1C,CAFA,IAAK3B,CAAAA,SAEL,CAFiBsB,GAAIM,CAAAA,OAErB,CAF+BL,UAAWM,CAAAA,GAE1C,CADA,IAAKV,CAAAA,qBACL,CAD6B,IAAKlB,CAAAA,SAClC,CAAA,IAAKmB,CAAAA,qBAAL,CAA6B,IAAKpB,CAAAA,SAPlC,CAH0B,CAa5B8B,mBAAmB,CAACC,UAAD,CAAaT,GAAb,CAAkB,CACnC,MAAMjC,MAAQ,IAAKuB,CAAAA,MACnB,KAAMoB,OAAS3C,KAAMmC,CAAAA,SAAN,EAAf,CACMS,OAASD,MAAOE,CAAAA,eAAP,EAEXD,OAAJ,GACEA,MAAOE,CAAAA,QAEP,CAFkBH,MAAOI,CAAAA,cAEzB,CAAK/C,KAAMgD,CAAAA,kBAAX,GACEJ,MAAOK,CAAAA,KAAMC,CAAAA,MADf;AACwBlD,KAAMmD,CAAAA,aAD9B,CAHF,CAQA,KAAKC,CAAAA,4BAAL,CAAkCV,UAAlC,CAA8CT,GAA9C,CAAmDjC,KAAnD,CAEA,KAAK,MAAMqD,IAAX,GAAmBrD,MAAMsD,CAAAA,iBAAzB,CAGEZ,UAEA,CAFaA,UAEb,EAF2B,IAAKa,CAAAA,SAAL,CAAetB,GAAf,CAE3B,CAAAS,UAAA,CAAaW,IAAKG,CAAAA,MAAL,CAAY,IAAK1B,CAAAA,qBAAjB,CAAwC,IAAKC,CAAAA,qBAA7C,CAAoEW,UAApE,CADQe,CAAgB,IAAf,GAAAf,UAAA,EAAsC,IAAK,EAA3C,GAAuBA,UAAvB,CAA+C,CAA/C,CAAwDA,UAAWgB,CAAAA,UAApED,EAAkF,CAAA,CAAlFA,CAAyF,CAAA,CACjG,CAA8Fb,MAA9F,CAGTe,OAAAA,CAAO1B,GAAI2B,CAAAA,UAAJ,EAAkBtE,YAAauE,CAAAA,YAAaC,CAAAA,WAA5C,EAA2D7B,GAAI2B,CAAAA,UAA/D,EAA6EtE,YAAauE,CAAAA,YAAaE,CAAAA,WAAvG,CAAqH/E,cAAegF,CAAAA,iBAAkBC,CAAAA,YAAtJ,CAAqKjF,cAAegF,CAAAA,iBAAkBE,CAAAA,WAE/MlE;KAAMmE,CAAAA,aAAV,GAEEzB,UACA,CADaA,UACb,EAD2B,IAAKa,CAAAA,SAAL,CAAetB,GAAf,CAC3B,CAAAjC,KAAMmE,CAAAA,aAAN,CAAoBlC,GAApB,CAAyBS,UAAzB,CAAqCiB,MAArC,CAHF,CAQIjB,WAAJ,EACE0B,MAEA,CAFc,IAAIpF,cAAeqF,CAAAA,WAAnB,CAA+BV,MAA/B,CAAqC1B,GAArC,CAA0CS,UAA1C,CAEd,CAAA,IAAK4B,CAAAA,oBAAL,CAA0B5B,UAA1B,CAAsCT,GAAtC,CAHF,EAME,IAAKb,CAAAA,gBANP,CAKEgD,MALF,CAKgB,IAAIpF,cAAeqF,CAAAA,WAAnB,CAA+BV,MAA/B,CAAqC1B,GAArC,CAA0C,IAA1C,CAAgD,IAAhD,CAIZjC,MAAMuE,CAAAA,mBAAoBC,CAAAA,YAA1B,EAAJ,EACExE,KAAMuE,CAAAA,mBAAoBE,CAAAA,eAA1B,CAA0CL,MAA1C,CAAuDT,MAAvD,CA3CiC,CAkDrCW,oBAAoB,CAACI,QAAD,CAAWC,KAAX,CAAkB,CACpC,MAAM3E,MAAQ,IAAKuB,CAAAA,MAEfmD,SAAJ,EAAgB1E,KAAM4E,CAAAA,iBAAtB;AACM,CAACF,QAASG,CAAAA,GADhB,GAEIH,QAASG,CAAAA,GAFb,CAEmB7E,KAAM8E,CAAAA,gBAAN,CAAuBH,KAAMI,CAAAA,OAA7B,CAAsCJ,KAAMK,CAAAA,OAA5C,CAAqD7F,WAAY8F,CAAAA,MAAOC,CAAAA,QAAnB,EAArD,CAAoFlF,KAAMmF,CAAAA,YAA1F,CAFnB,CAHoC,CAYtCC,yBAAyB,CAACC,QAAD,CAAWC,IAAX,CAAiB,CACxC,IAAKjE,CAAAA,oBAAL,EACA,OAAO,KAAKE,CAAAA,MAAOgD,CAAAA,mBAAoBgB,CAAAA,GAAhC,CAAoCF,QAApC,CAA8CC,IAA9C,CAFiC,CAO1CE,4BAA4B,CAACH,QAAD,CAAW,CACrC,IAAKhE,CAAAA,oBAAL,EACA,OAAO,KAAKE,CAAAA,MAAOgD,CAAAA,mBAAoBkB,CAAAA,MAAhC,CAAuCJ,QAAvC,CAF8B,CAKvCK,gBAAgB,EAAG,CACjB,MAAO,CAAC,EAAE,IAAKnE,CAAAA,MAAOgD,CAAAA,mBAAoBoB,CAAAA,SAAUC,CAAAA,MAA5C,CAAqD,IAAKvE,CAAAA,oBAA1D,EAAkF,IAAKE,CAAAA,MAAOsE,CAAAA,aAA9F,CADS,CAInBC,0BAA0B,CAACpD,UAAD;AAAaT,GAAb,CAAkB0B,IAAlB,CAAwB,CAChD,MAAM3D,MAAQ,IAAKuB,CAAAA,MACbwE,IAAAA,CAAK,IAAI/G,cAAegH,CAAAA,cAAnB,CAAkCrC,IAAlC,CAAwC1B,GAAxC,CAA6C,IAAKH,CAAAA,qBAAlD,CAAyE,IAAKC,CAAAA,qBAA9E,CAEPW,WAAJ,GACEqD,GAAGE,CAAAA,mBAGH,CAHyBvD,UAGzB,CAFAqD,GAAGlB,CAAAA,GAEH,CAFSnC,UAAWmC,CAAAA,GAEpB,CAAInC,UAAWwD,CAAAA,UAAf,GACEH,GAAGI,CAAAA,0BADL,CACkCzD,UADlC,CAJF,CASA1C,MAAMoG,CAAAA,sBAAuB3B,CAAAA,eAA7B,CAA6CsB,GAA7C,CAAiDpC,IAAjD,CAEA,OAAIoC,IAAGM,CAAAA,uBAAP,CACS,CAAA,CADT,CAGS,CAAA,CAlBuC,CAwBlD9C,SAAS,CAACtB,GAAD,CAAM,CACb,MAAMjC,MAAQ,IAAKuB,CAAAA,MAAnB,CACMmB,WAAa1C,KAAMsG,CAAAA,IAAN,CAAW,IAAKxE,CAAAA,qBAAhB,CAAuC,IAAKC,CAAAA,qBAA5C,CAAmE/B,KAAMuG,CAAAA,oBAAzE;AAA+FvG,KAAMwG,CAAAA,oBAArG,CAA2HxG,KAAMyG,CAAAA,sBAAjI,CAAyJzG,KAAM0G,CAAAA,4BAA/J,CAEnB,KAAKtD,CAAAA,4BAAL,CAAkCV,UAAlC,CAA8CT,GAA9C,CAAmDjC,KAAnD,CAEA,OAAO0C,WANM,CASfU,4BAA4B,CAACV,UAAD,CAAaT,GAAb,CAAkBjC,KAAlB,CAAyB,CAEnD,MAAM4C,OADS5C,KAAMmC,CAAAA,SAANQ,EACOE,CAAAA,eAAP,EAEf,EAAmB,IAAf,GAAAH,UAAA,EAAsC,IAAK,EAA3C,GAAuBA,UAAvB,CAA+C,CAA/C,CAAwDA,UAAWgB,CAAAA,UAAvE,GACE,IAAKiD,CAAAA,kBAAL,CAAwBjE,UAAWgB,CAAAA,UAAnC,CAA+CzB,GAAIJ,CAAAA,SAAnD,CAA8Da,UAA9D,CAA0ET,GAA1E,CAEA,CAAI,CAACjC,KAAMgD,CAAAA,kBAAX,EAAiCJ,MAAjC,EAA2C,IAAKjB,CAAAA,gBAAhD,GACQiF,UADR,CACwB,IAAKjF,CAAAA,gBAAiBkF,CAAAA,2BAAtB,EADxB;AAGuBD,UAAcE,CAAAA,kBAHrC,GAIIlE,MAAOK,CAAAA,KAAMC,CAAAA,MAJjB,CAI0B0D,UAAcG,CAAAA,WAJxC,EAIuD/G,KAAM+G,CAAAA,WAJ7D,CAHF,EAWE,IAAKJ,CAAAA,kBAAL,CAAwB,IAAxB,CAA8B1E,GAAIJ,CAAAA,SAAlC,CAA6Ca,UAA7C,CAAyDT,GAAzD,CAfiD,CA0BrD+E,mBAAmB,CAACtE,UAAD,CAAauE,gBAAb,CAA+B,CAC1ChF,gBAAAA,CAAM,IAAIiF,YAAJ,CAAiB,aAAjB,CAAgCD,gBAAhC,CACZhF,iBAAI2B,CAAAA,UAAJ,CAAiBtE,YAAauE,CAAAA,YAAasD,CAAAA,IAEvC,KAAKrB,CAAAA,0BAAL,CAAgCpD,UAAhC,CAA4CT,gBAA5C,CAAiDjD,cAAegF,CAAAA,iBAAkBE,CAAAA,WAAlF,CAAJ,EAIA,IAAKzB,CAAAA,mBAAL,CAAyBC,UAAzB,CAAqCT,gBAArC,CARgD,CAkBlDmF,mBAAmB,CAAC1E,UAAD;AAAauE,gBAAb,CAA+B,CAC1ChF,gBAAAA,CAAM,IAAIiF,YAAJ,CAAiB,aAAjB,CAAgCD,gBAAhC,CACZhF,iBAAI2B,CAAAA,UAAJ,CAAiB3B,gBAAIoF,CAAAA,MAArB,CAA8B,CAE1B,KAAKvB,CAAAA,0BAAL,CAAgCpD,UAAhC,CAA4CT,gBAA5C,CAAiDjD,cAAegF,CAAAA,iBAAkBsD,CAAAA,WAAlF,CAAJ,EAIA,IAAKC,CAAAA,mBAAL,CAAyB7E,UAAzB,CAAqCT,gBAArC,CARgD,CAWlDsF,mBAAmB,CAAC7E,mBAAD,CAAaT,GAAb,CAAkB,CACnC,MAAMjC,MAAQ,IAAKuB,CAAAA,MAEnB,IAAmB,IAAf,GAAAmB,mBAAA,EAAsC,IAAK,EAA3C,GAAuBA,mBAAvB,CAA+C,CAA/C,CAAwDA,mBAAWgB,CAAAA,UAAvE,CAAmF,CACjF,IAAK8D,CAAAA,eAAL,CAAuB9E,mBAAWgB,CAAAA,UAElC;MAAMkD,cAAgBlE,mBAAWgB,CAAAA,UAAWmD,CAAAA,2BAAtB,EAEtB,IAAID,aAAJ,CAAmB,CACjB,GAAIA,aAAca,CAAAA,eAAlB,CAGE,OAFAb,aAAcc,CAAAA,cAAd,CAA6B,CAA7B,CAAgCtI,YAAauI,CAAAA,WAAYC,CAAAA,SAAzB,CAAmClF,mBAAWgB,CAAAA,UAA9C,CAA0DzB,GAA1D,CAAhC,CAEYoF,CAAJpF,GAAIoF,CAAAA,MAAZ,EACE,KAAK,CAAL,CACET,aAAcc,CAAAA,cAAd,CAA6B,CAA7B,CAAgCtI,YAAauI,CAAAA,WAAYC,CAAAA,SAAzB,CAAmClF,mBAAWgB,CAAAA,UAA9C,CAA0DzB,GAA1D,CAAhC,CACA,MAEF,MAAK,CAAL,CACE2E,aAAcc,CAAAA,cAAd,CAA6B,CAA7B,CAAgCtI,YAAauI,CAAAA,WAAYC,CAAAA,SAAzB,CAAmClF,mBAAWgB,CAAAA,UAA9C,CAA0DzB,GAA1D,CAAhC,CACA,MAEF,MAAK,CAAL,CACE2E,aAAcc,CAAAA,cAAd,CAA6B,CAA7B;AAAgCtI,YAAauI,CAAAA,WAAYC,CAAAA,SAAzB,CAAmClF,mBAAWgB,CAAAA,UAA9C,CAA0DzB,GAA1D,CAAhC,CAVJ,CAeE2E,aAAciB,CAAAA,kBAAd,CAAiC,CAAjC,CAAJ,EACEC,MAAOC,CAAAA,UAAP,CAAkB,EAAA,EAAM,CACtB,MAAMrF,WAAa1C,KAAMsG,CAAAA,IAAN,CAAW,IAAKxE,CAAAA,qBAAhB,CAAuC,IAAKC,CAAAA,qBAA5C,CAAmEiG,IAAA,EAAQA,IAAKC,CAAAA,UAAb,EAA2BD,IAAKE,CAAAA,SAAhC,EAA6CF,IAAKG,CAAAA,OAAL,EAA7C,EAA+DH,IAAKpB,CAAAA,aAApE,EAAqFoB,IAAKpB,CAAAA,aAAciB,CAAAA,kBAAnB,CAAsC,CAAtC,CAArF,EAAiIG,IAAjI,GAA0I,IAAKR,CAAAA,eAAlN,CAAmO,CAAA,CAAnO,CAA0OxH,KAAMyG,CAAAA,sBAAhP,CAEnB,EAAoB,IAAf,GAAA/D,UAAA,EAAsC,IAAK,EAA3C,GAAuBA,UAAvB,CAA+C,CAA/C,CAAwDA,UAAWgB,CAAAA,UAAxE,GAAuFkD,aAAvF,EACqC,CADrC,GACM,IAAKvG,CAAAA,qBADX;AAC0C+H,IAAKC,CAAAA,GAAL,EAD1C,CACuD,IAAKpH,CAAAA,oBAD5D,CACmFlC,YAAauJ,CAAAA,cADhG,EACkH,CAAC,IAAKC,CAAAA,iBAAL,EADnH,GAEI,IAAKtH,CAAAA,oBACL,CAD4B,CAC5B,CAAA2F,aAAcc,CAAAA,cAAd,CAA6B,CAA7B,CAAgCtI,YAAauI,CAAAA,WAAYC,CAAAA,SAAzB,CAAmClF,UAAWgB,CAAAA,UAA9C,CAA0DzB,GAA1D,CAAhC,CAHJ,CAHsB,CAAxB,CASGlD,YAAauJ,CAAAA,cAThB,CApBe,CAL8D,CAAnF,IAsCE,KAAK,IAAMjF,IAAX,GAAmBrD,MAAMwI,CAAAA,iBAAzB,CACE9F,mBAAA,CAAaW,IAAKG,CAAAA,MAAL,CAAY,IAAK1B,CAAAA,qBAAjB,CAAwC,IAAKC,CAAAA,qBAA7C,CAAoEW,mBAApE,CAAgFT,GAAhF,CAAqF,CAAA,CAArF,CAKjB,OAAM0B,KAAO3E,cAAegF,CAAAA,iBAAkBsD,CAAAA,WAE9C,IAAI5E,mBAAJ,CAAgB,CACd,GAAI1C,KAAMyI,CAAAA,aAAV,CACEzI,KAAMyI,CAAAA,aAAN,CAAoBxG,GAApB;AAAyBS,mBAAzB,CAAqCiB,IAArC,CAGFS,KAAA,CAAc,IAAIpF,cAAeqF,CAAAA,WAAnB,CAA+BV,IAA/B,CAAqC1B,GAArC,CAA0CS,mBAA1C,CAEd,KAAK4B,CAAAA,oBAAL,CAA0B5B,mBAA1B,CAAsCT,GAAtC,CAPc,CAAhB,IASEmC,KAAA,CAAc,IAAIpF,cAAeqF,CAAAA,WAAnB,CAA+BV,IAA/B,CAAqC1B,GAArC,CAA0C,IAA1C,CAAgD,IAAhD,CAGZjC,MAAMuE,CAAAA,mBAAoBC,CAAAA,YAA1B,EAAJ,EACExE,KAAMuE,CAAAA,mBAAoBE,CAAAA,eAA1B,CAA0CL,IAA1C,CAAuDT,IAAvD,CA9DiC,CAuErC4E,iBAAiB,EAAG,CAClB,MAAO,KAAKjI,CAAAA,UADM,CAYpBoI,iBAAiB,CAAChG,UAAD,CAAauE,gBAAb,CAA+B0B,SAA/B,CAA0C,CACnD1G,gBAAAA,CAAM,IAAIiF,YAAJ,CAAiB,WAAjB,CAA8BD,gBAA9B,CACZhF,iBAAI2B,CAAAA,UAAJ,CAAiBtE,YAAauE,CAAAA,YAAasD,CAAAA,IAC3C;MAAMyB,UAAY,IAAInJ,UAElBkJ,UAAJ,CACEC,SAAUC,CAAAA,WADZ,CAC0B,CAAA,CAD1B,CAGED,SAAUE,CAAAA,WAHZ,CAG0B,CAAA,CAGtB,KAAKhD,CAAAA,0BAAL,CAAgCpD,UAAhC,CAA4CT,gBAA5C,CAAiDjD,cAAegF,CAAAA,iBAAkB+E,CAAAA,SAAlF,CAAJ,EAIA,IAAKC,CAAAA,iBAAL,CAAuBtG,UAAvB,CAAmCT,gBAAnC,CAAwC2G,SAAxC,CAfyD,CAkB3DI,iBAAiB,CAACtG,UAAD,CAAaT,GAAb,CAAkB2G,SAAlB,CAA6B,CAC5C,MAAM5I,MAAQ,IAAKuB,CAAAA,MAEnB,IAAmB,IAAf,GAAAmB,UAAA,EAAsC,IAAK,EAA3C,GAAuBA,UAAvB,CAA+C,CAA/C,CAAwDA,UAAWgB,CAAAA,UAAvE,CAAmF,CACjF,IAAKuF,CAAAA,aAAL,CAAqBvG,UAAWgB,CAAAA,UAEhC,IAAI,IAAK8D,CAAAA,eAAT,GAA6B,IAAKyB,CAAAA,aAAlC,CAAiD,CAC/C,GAAIjJ,KAAM6F,CAAAA,aAAV,CACE7F,KAAM6F,CAAAA,aAAN,CAAoB5D,GAApB;AAAyBS,UAAzB,CAGF,IAAIkG,SAAUE,CAAAA,WAAd,EAA6B,CAACF,SAAUM,CAAAA,MAAxC,EAAkDlJ,KAAMuE,CAAAA,mBAAoBoB,CAAAA,SAAUC,CAAAA,MAAtF,CAA+F,IAAKvE,CAAAA,oBAApG,CAA0H,CACxH,IAAMsC,KAAO3E,cAAegF,CAAAA,iBAAkBmF,CAAAA,WAC9C,OAAMpD,GAAK,IAAI/G,cAAeqF,CAAAA,WAAnB,CAA+BV,IAA/B,CAAqC1B,GAArC,CAA0CS,UAA1C,CAEX,KAAK4B,CAAAA,oBAAL,CAA0B5B,UAA1B,CAAsCT,GAAtC,CAEAjC,MAAMuE,CAAAA,mBAAoBE,CAAAA,eAA1B,CAA0CsB,EAA1C,CAA8CpC,IAA9C,CANwH,CAL3E,CAiBjD,CAFMiD,IAEN,CAFsBlE,UAAWgB,CAAAA,UAAWmD,CAAAA,2BAAtB,EAEtB,GAAqB,CAAC+B,SAAUM,CAAAA,MAAhC,GACEtC,IAAcc,CAAAA,cAAd,CAA6B,CAA7B,CAAgCtI,YAAauI,CAAAA,WAAYC,CAAAA,SAAzB,CAAmClF,UAAWgB,CAAAA,UAA9C,CAA0DzB,GAA1D,CAA+DS,UAA/D,CAAhC,CAQA;AANI,CAACkG,SAAUQ,CAAAA,SAMf,EAN4BR,SAAUE,CAAAA,WAMtC,EALElC,IAAcc,CAAAA,cAAd,CAA6B,CAA7B,CAAgCtI,YAAauI,CAAAA,WAAYC,CAAAA,SAAzB,CAAmClF,UAAWgB,CAAAA,UAA9C,CAA0DzB,GAA1D,CAA+DS,UAA/D,CAAhC,CAKF,CAFM2G,IAEN,CAFiC3G,UAAWgB,CAAAA,UAAWmD,CAAAA,2BAAtB,CAAkD,CAAlD,CAEjC,CAAI+B,SAAUC,CAAAA,WAAd,EAA6BQ,IAA7B,EACEA,IAAyB3B,CAAAA,cAAzB,CAAwC,CAAxC,CAA2CtI,YAAauI,CAAAA,WAAYC,CAAAA,SAAzB,CAAmClF,UAAWgB,CAAAA,UAA9C,CAA0DzB,GAA1D,CAA+DS,UAA/D,CAA3C,CAVJ,CApBiF,CAAnF,IAkCE,IAAI,CAACkG,SAAUM,CAAAA,MAAf,CACE,IAAW7F,IAAX,GAAmBrD,MAAMsJ,CAAAA,eAAzB,CACE5G,UAAA,CAAaW,IAAKG,CAAAA,MAAL,CAAY,IAAK1B,CAAAA,qBAAjB,CAAwC,IAAKC,CAAAA,qBAA7C,CAAoEW,UAApE,CAAgFT,GAAhF,CAAqF2G,SAAUC,CAAAA,WAA/F,CAKf,KAAKrB,CAAAA,eAAT;AAA4B,IAAKA,CAAAA,eAAjC,GAAqD,IAAKyB,CAAAA,aAA1D,GACQM,IADR,CACkC,IAAK/B,CAAAA,eAAgBX,CAAAA,2BAArB,CAAiD,EAAjD,CADlC,GAII0C,IAAwB7B,CAAAA,cAAxB,CAAuC,EAAvC,CAA2CtI,YAAauI,CAAAA,WAAYC,CAAAA,SAAzB,CAAmC,IAAKJ,CAAAA,eAAxC,CAAyDvF,GAAzD,CAA3C,CAIJ,IAAI,CAAC2G,SAAUM,CAAAA,MAAf,CAAuB,CACfnD,IAAAA,CAAK,IAAI/G,cAAeqF,CAAAA,WAAnB,CAA+BrF,cAAegF,CAAAA,iBAAkB+E,CAAAA,SAAhE,CAA2E9G,GAA3E,CAAgFS,UAAhF,CAEX,KAAK4B,CAAAA,oBAAL,CAA0B5B,UAA1B,CAAsCT,GAAtC,CAEAjC,MAAMuE,CAAAA,mBAAoBE,CAAAA,eAA1B,CAA0CsB,IAA1C,CAA8C/G,cAAegF,CAAAA,iBAAkB+E,CAAAA,SAA/E,CAEA,IAAI/I,KAAMwJ,CAAAA,WAAV,CACExJ,KAAMwJ,CAAAA,WAAN,CAAkBvH,GAAlB,CAAuBS,UAAvB,CAAmC1D,cAAegF,CAAAA,iBAAkB+E,CAAAA,SAApE,CAGGH;SAAUQ,CAAAA,SAAf,EAA6B,IAAK1I,CAAAA,eAAlC,EAAsD,IAAKD,CAAAA,oBAA3D,GACMkD,IAQJ,CARW,CAQX,CANIiF,SAAUE,CAAAA,WAAd,CACEnF,IADF,CACS3E,cAAegF,CAAAA,iBAAkByF,CAAAA,UAD1C,CAEWb,SAAUC,CAAAA,WAFrB,GAGElF,IAHF,CAGS3E,cAAegF,CAAAA,iBAAkB0F,CAAAA,gBAH1C,CAMA,CAAI/F,IAAJ,GACQoC,UAEN,CAFW,IAAI/G,cAAeqF,CAAAA,WAAnB,CAA+BV,IAA/B,CAAqC1B,GAArC,CAA0CS,UAA1C,CAEX,CAAI1C,KAAMuE,CAAAA,mBAAoBC,CAAAA,YAA1B,EAAJ,EAAgDxE,KAAMuE,CAAAA,mBAAoBoF,CAAAA,eAA1B,CAA0ChG,IAA1C,CAAhD,EACE3D,KAAMuE,CAAAA,mBAAoBE,CAAAA,eAA1B,CAA0CsB,UAA1C,CAA8CpC,IAA9C,CAJJ,CATF,CAXqB,CApDqB,CAyF9CiG,iBAAiB,CAAC/H,SAAA,CAAY,CAAb,CAAgB,CAC/B,MAAO,KAAKX,CAAAA,gBAAL,CAAsBW,SAAtB,CADwB,CAYjCgI,aAAa,CAACC,QAAA;AAAW,CAAA,CAAZ,CAAkBC,UAAA,CAAa,CAAA,CAA/B,CAAqCC,UAAA,CAAa,CAAA,CAAlD,CAAwDC,iBAAA,CAAoB,IAA5E,CAAkF,CAC7F,MAAMjK,MAAQ,IAAKuB,CAAAA,MAAnB,CACMoB,OAAS3C,KAAMmC,CAAAA,SAAN,EAEV8H,kBAAL,GACEA,iBADF,CACsBtH,MAAOE,CAAAA,eAAP,EADtB,CAII,KAAK3C,CAAAA,gBAAT,EACE,IAAKgK,CAAAA,aAAL,EAGED,kBAAJ,GACE,IAAKE,CAAAA,kBADP,CAC4BF,iBAD5B,CAIA,KAAK1K,CAAAA,oBAAL,CAA4B,IAAIA,oBAAqB6K,CAAAA,mBAAzB,CAA6CzH,MAA7C,CAE5B,KAAK0H,CAAAA,kBAAL,CAA0BC,GAAAC,EAAO,CAC/B,GAAI,CAAC,IAAKtK,CAAAA,gBAAV,CAA4B,CAC1B,MAAMyC,WAAa1C,KAAMwK,CAAAA,oBAAN,EAA2D,CAA3D,GAA8BxK,KAAMyK,CAAAA,kBAApC,EAAgE,CAAC,IAAK/E,CAAAA,gBAAL,EAAjE;AAA4F,CAAC1F,KAAMwJ,CAAAA,WAAnG,CAAiH,IAAjH,CAAwHxJ,KAAMsG,CAAAA,IAAN,CAAW,IAAKxE,CAAAA,qBAAhB,CAAuC,IAAKC,CAAAA,qBAA5C,CAAmE/B,KAAM0K,CAAAA,kBAAzE,CAA6F1K,KAAM2K,CAAAA,kBAAnG,CAAuH3K,KAAMyG,CAAAA,sBAA7H,CAG3I,EAFA,IAAKrG,CAAAA,kBAEL,CAF0BsC,UAE1B,IACE4H,GADF,CACQ5H,UAAWkI,CAAAA,GAAX,EAAkBlI,UAAWgB,CAAAA,UAA7B,CAA0ChB,UAAWgB,CAAAA,UAAWmD,CAAAA,2BAAtB,EAA1C,CAAgG,IADxG,CAIA,KAAK5G,CAAAA,gBAAL,CAAwB,CAAA,CARE,CAW5B,MAAOqK,IAZwB,CAejC,KAAKO,CAAAA,mBAAL,CAA2B,CAACC,GAAD,CAAMlC,SAAN,CAAiBmC,EAAjB,CAAAC,EAAwB,CAEjD,GAAI5C,IAAKC,CAAAA,GAAL,EAAJ,CAAiB,IAAKrH,CAAAA,4BAAtB,CAAqDjC,YAAakM,CAAAA,gBAAlE,EAAsF,CAAC,IAAK1K,CAAAA,mBAA5F,EAAmHuK,GAAnH;AAA2H,IAAKI,CAAAA,sBAAhI,CACE,IAAK3K,CAAAA,mBAIL,CAJ2B,CAAA,CAI3B,CAHAqI,SAAUE,CAAAA,WAGV,CAHwB,CAAA,CAGxB,CAFAF,SAAUM,CAAAA,MAEV,CAFmB,CAAA,CAEnB,CAAI,IAAK5H,CAAAA,cAAL,CAAoBwJ,GAApB,CAAJ,GAEQnH,SAQN,CARa3E,cAAegF,CAAAA,iBAAkByF,CAAAA,UAQ9C,CAPM1D,EAON,CAPW,IAAI/G,cAAeqF,CAAAA,WAAnB,CAA+BV,SAA/B,CAFC,IAAKrC,CAAAA,cAAL,CAAoBwJ,GAApB,CAAyB7I,CAAAA,GAE1B,CAA0C,IAAK7B,CAAAA,kBAA/C,CAOX,CALIJ,KAAMuE,CAAAA,mBAAoBC,CAAAA,YAA1B,EAKJ,EALgDxE,KAAMuE,CAAAA,mBAAoBoF,CAAAA,eAA1B,CAA0ChG,SAA1C,CAKhD,EAJE3D,KAAMuE,CAAAA,mBAAoBE,CAAAA,eAA1B,CAA0CsB,EAA1C,CAA8CpC,SAA9C,CAIF,CAAA,IAAKrC,CAAAA,cAAL,CAAoBwJ,GAApB,CAAA,CAA2B,IAV7B,CAP+C,CAsBnD,KAAKK,CAAAA,eAAL,CAAuB,CAACC,IAAD,CAAOC,IAAP,CAAapJ,GAAb,CAAkB8I,EAAlB,CAAAO;AAAyB,CAAA,IAC1CC,EAD0C,CACtCC,EAER,OAAM5C,UAAY,IAAInJ,UAEtB,KAAI6K,IADJ,IAAKlK,CAAAA,kBACDkK,CADsB,IAE1B,KAAImB,aAAeL,IAAKzB,CAAAA,eAAL,CAAqB3K,cAAegF,CAAAA,iBAAkBmF,CAAAA,WAAtD,CAAfsC,EAAqFJ,IAAK1B,CAAAA,eAAL,CAAqB3K,cAAegF,CAAAA,iBAAkBmF,CAAAA,WAAtD,CAArFsC,EAA2JL,IAAKzB,CAAAA,eAAL,CAAqB3K,cAAegF,CAAAA,iBAAkByF,CAAAA,UAAtD,CAA3JgC,EAAgOJ,IAAK1B,CAAAA,eAAL,CAAqB3K,cAAegF,CAAAA,iBAAkByF,CAAAA,UAAtD,CAAhOgC,EAAqSL,IAAKzB,CAAAA,eAAL,CAAqB3K,cAAegF,CAAAA,iBAAkB0F,CAAAA,gBAAtD,CAArS+B,EAAgXJ,IAAK1B,CAAAA,eAAL,CAAqB3K,cAAegF,CAAAA,iBAAkB0F,CAAAA,gBAAtD,CAEhX;CAAC+B,YAAL,EAAqBxM,sBAAuByM,CAAAA,qBAA5C,GACEpB,GADF,CACQ,IAAKD,CAAAA,kBAAL,CAAwBC,GAAxB,CAA6B1B,SAA7B,CADR,IAII6C,YAJJ,CAImBnB,GAAI7C,CAAAA,eAJvB,CAQA,KAAIkE,iBAAmB,CAAA,CAEvB,IAAIF,YAAJ,GACQX,YAGF,CAHQ7I,GAAIoF,CAAAA,MAGZ,CAFJuB,SAAUQ,CAAAA,SAEN,CAFkB,IAAKb,CAAAA,iBAAL,EAElB,CAAA,CAACK,SAAUQ,CAAAA,SAJjB,EAI4B,CACxB,IAAIwC,4BAA8B,CAAC7M,YAAa8M,CAAAA,wBAE3CD,4BAAL,GACEA,2BADF,CACgC,CAACR,IAAKzB,CAAAA,eAAL,CAAqB3K,cAAegF,CAAAA,iBAAkB0F,CAAAA,gBAAtD,CADjC,EAC4G,CAAC2B,IAAK1B,CAAAA,eAAL,CAAqB3K,cAAegF,CAAAA,iBAAkB0F,CAAAA,gBAAtD,CAD7G;AAGqC,CAACzK,sBAAuByM,CAAAA,qBAAsBI,CAAAA,kBAA7C,CAAgE,CAAhE,CAHtC,GAIIxB,GAJJ,CAIU,IAAKD,CAAAA,kBAAL,CAAwBC,GAAxB,CAA6B1B,SAA7B,CAJV,IAOMgD,2BAPN,CAOoC,CAACtB,GAAIzC,CAAAA,kBAAJ,CAAuB,CAAvB,CAPrC,CAYA,IAAI+D,2BAAJ,CAEE,IAAIxD,IAAKC,CAAAA,GAAL,EAAJ,CAAiB,IAAKrH,CAAAA,4BAAtB,CAAqDjC,YAAakM,CAAAA,gBAAlE,EAAsFH,YAAtF,GAA8F,IAAKI,CAAAA,sBAAnG,CACEtC,SAAUE,CAAAA,WAEV,CAFwB,CAAA,CAExB,CADAiC,EAAA,CAAGnC,SAAH,CAAc,IAAKxI,CAAAA,kBAAnB,CACA,CAAAuL,gBAAA,CAAmB,CAAA,CAHrB,CAFF,IAaQI,IAKN,CALqB,CACd9J,GADc,CAER2G,SAFQ,CAGnBoD,UAAWlE,MAAOC,CAAAA,UAAP,CAAkB,IAAK8C,CAAAA,mBAAoBoB,CAAAA,IAAzB,CAA8B,IAA9B,CAAoCnB,YAApC;AAAyClC,SAAzC,CAAoDmC,EAApD,CAAlB,CAA2EhM,YAAakM,CAAAA,gBAAxF,CAHQ,CAKrB,CAAA,IAAK3J,CAAAA,cAAL,CAAoBwJ,YAApB,CAAA,CAA2BiB,GAGzBG,KAAAA,CAAmBd,IAAKzB,CAAAA,eAAL,CAAqB3K,cAAegF,CAAAA,iBAAkB0F,CAAAA,gBAAtD,CAAnBwC,EAA8Fb,IAAK1B,CAAAA,eAAL,CAAqB3K,cAAegF,CAAAA,iBAAkB0F,CAAAA,gBAAtD,CAE9F,EAACwC,IAAL,EAAyBjN,sBAAuByM,CAAAA,qBAAsBI,CAAAA,kBAA7C,CAAgE,CAAhE,CAAzB,GACExB,GADF,CACQ,IAAKD,CAAAA,kBAAL,CAAwBC,GAAxB,CAA6B1B,SAA7B,CADR,IAIIsD,IAJJ,CAIuB5B,GAAIzC,CAAAA,kBAAJ,CAAuB,CAAvB,CAJvB,CAQIqE,KAAJ,GAEMpB,YAAJ,GAAY,IAAKI,CAAAA,sBAAjB,EAA2C9C,IAAKC,CAAAA,GAAL,EAA3C,CAAwD,IAAKrH,CAAAA,4BAA7D,CAA4FjC,YAAakM,CAAAA,gBAAzG;AAA6H,CAAC,IAAK1K,CAAAA,mBAAnI,EAEOqI,SAAUQ,CAAAA,SAAf,EAA6B,IAAKb,CAAAA,iBAAL,EAA7B,EAcE,IAAKhI,CAAAA,mBAML,CAN2B,CAAA,CAM3B,CALA,IAAKS,CAAAA,4BAKL,CALoC,IAAKC,CAAAA,oBAKzC,CAJA,IAAKF,CAAAA,gCAAiCoL,CAAAA,CAItC,CAJ0C,IAAKtL,CAAAA,wBAAyBsL,CAAAA,CAIxE,CAHA,IAAKpL,CAAAA,gCAAiCqL,CAAAA,CAGtC,CAH0C,IAAKvL,CAAAA,wBAAyBuL,CAAAA,CAGxE,CAFA,IAAKlB,CAAAA,sBAEL,CAF8BJ,YAE9B,CAAI/L,YAAa8M,CAAAA,wBAAjB,EAEM,IAAKvK,CAAAA,cAAL,CAAoBwJ,YAApB,CAKJ,GAJEuB,YAAA,CAAiD,IAApC,IAACb,EAAD,CAAM,IAAKlK,CAAAA,cAAL,CAAoBwJ,YAApB,CAAN,GAAmD,IAAK,EAAxD,GAA4CU,EAA5C,CAA4D,IAAK,EAAjE;AAAqEA,EAAGQ,CAAAA,SAArF,CACA,CAAA,IAAK1K,CAAAA,cAAL,CAAoBwJ,YAApB,CAAA,CAA2B,IAG7B,EAAAC,EAAA,CAAGnC,SAAH,CAAc,IAAKzI,CAAAA,mBAAnB,CAPF,EASE4K,EAAA,CAAGnC,SAAH,CAAc,IAAKxI,CAAAA,kBAAnB,CA7BJ,GACE,IAAKY,CAAAA,4BAUL,CAVoC,CAUpC,CATA,IAAKT,CAAAA,mBASL,CAT2B,CAAA,CAS3B,CARAqI,SAAUC,CAAAA,WAQV,CARwB,CAAA,CAQxB,CAPAD,SAAUM,CAAAA,MAOV,CAPmB,CAAA,CAOnB,CALInK,YAAa8M,CAAAA,wBAKjB,EAL6C,IAAKvK,CAAAA,cAAL,CAAoBwJ,YAApB,CAK7C,GAJEuB,YAAA,CAAiD,IAApC,IAACd,EAAD,CAAM,IAAKjK,CAAAA,cAAL,CAAoBwJ,YAApB,CAAN,GAAmD,IAAK,EAAxD,GAA4CS,EAA5C,CAA4D,IAAK,EAAjE,CAAqEA,EAAGS,CAAAA,SAArF,CACA,CAAA,IAAK1K,CAAAA,cAAL,CAAoBwJ,YAApB,CAAA,CAA2B,IAG7B,EAAAC,EAAA,CAAGnC,SAAH,CAAc,IAAKxI,CAAAA,kBAAnB,CAXF,CAiCA,CAAAuL,gBAAA;AAAmB,CAAA,CAnCrB,GAsCE,IAAKpL,CAAAA,mBAIL,CAJ2B,CAAA,CAI3B,CAHA,IAAKS,CAAAA,4BAGL,CAHoC,IAAKC,CAAAA,oBAGzC,CAFA,IAAKF,CAAAA,gCAAiCoL,CAAAA,CAEtC,CAF0C,IAAKtL,CAAAA,wBAAyBsL,CAAAA,CAExE,CADA,IAAKpL,CAAAA,gCAAiCqL,CAAAA,CACtC,CAD0C,IAAKvL,CAAAA,wBAAyBuL,CAAAA,CACxE,CAAA,IAAKlB,CAAAA,sBAAL,CAA8BJ,YA1ChC,CAFF,CA9CwB,CAkGvBa,gBAAL,EACEZ,EAAA,CAAGnC,SAAH,CAAc,IAAKxI,CAAAA,kBAAnB,CAzH4C,CA6HhD,KAAKkM,CAAAA,cAAL,CAAsBrK,GAAAsK,EAAO,CAC3B,IAAKvK,CAAAA,sBAAL,CAA4BC,GAA5B,CAGK,KAAK3B,CAAAA,UAAV,EAAqD,CAAC,CAAtD,GAAwB,IAAKE,CAAAA,mBAA7B,GACE,IAAKF,CAAAA,UADP,CACoBkM,IAAKC,CAAAA,GAAL,CAAS,IAAK5L,CAAAA,wBAAyBsL,CAAAA,CAAvC;AAA2C,IAAKvL,CAAAA,SAAhD,CADpB,CACiF7B,YAAa2N,CAAAA,qBAD9F,EACuHF,IAAKC,CAAAA,GAAL,CAAS,IAAK5L,CAAAA,wBAAyBuL,CAAAA,CAAvC,CAA2C,IAAKzL,CAAAA,SAAhD,CADvH,CACoL5B,YAAa2N,CAAAA,qBADjM,CAMI/J,OAAOgK,CAAAA,aAAX,EACEhK,MAAOiK,CAAAA,kBAAP,EAIF,IAAI,CAAA,IAAK9G,CAAAA,0BAAL,CAAgC,IAAhC,CAAsC7D,GAAtC,CAA2CA,GAAI2B,CAAAA,UAAJ,EAAkBtE,YAAauE,CAAAA,YAAaC,CAAAA,WAA5C,EAA2D7B,GAAI2B,CAAAA,UAA/D,EAA6EtE,YAAauE,CAAAA,YAAaE,CAAAA,WAAvG,CAAqH/E,cAAegF,CAAAA,iBAAkBC,CAAAA,YAAtJ,CAAqKjF,cAAegF,CAAAA,iBAAkBE,CAAAA,WAAjP,CAAJ,GAIKlE,KAAMyG,CAAAA,sBAJX,EAIsCzG,KAAMmF,CAAAA,YAJ5C,EAQA,GAAInF,KAAM6M,CAAAA,sBAAV,CACE,IAAKpK,CAAAA,mBAAL,CAAyB,IAAIvD,YAAa4N,CAAAA,WAA1C;AAAyD7K,GAAzD,CADF,KAAA,CAMKjC,KAAMuG,CAAAA,oBAAX,GACEvG,KAAMuG,CAAAA,oBADR,CAC+ByB,IAAA+E,EAAQ/E,IAAKC,CAAAA,UAAb8E,EAA2B/E,IAAKE,CAAAA,SAAhC6E,EAA6C/E,IAAKG,CAAAA,OAAL,EAA7C4E,EAA+D/E,IAAKgF,CAAAA,SAAL,EAA/DD,GAAoF/E,IAAKiF,CAAAA,uBAAzFF,EAAoH/M,KAAMkN,CAAAA,gCAA1HH,EAAqM,IAArMA,GAA8J/E,IAAKnB,CAAAA,2BAAL,EAA9JkG,IAA+M,CAAC/M,KAAMyG,CAAAA,sBAAtNsG,EAA8S,CAA9SA,IAAiP/M,KAAMyG,CAAAA,sBAAuB0G,CAAAA,SAA9QJ,CAA0R/E,IAAKmF,CAAAA,SAA/RJ,EAD/B,CAIA,KAAMrK,WAAwC,CAA3B,CAAA1C,KAAMyK,CAAAA,kBAAN,EAAgCzK,KAAMkN,CAAAA,gCAAtC,CAAyE,IAAK3J,CAAAA,SAAL,CAAetB,GAAf,CAAzE,CAA+F,IAElH,KAAKQ,CAAAA,mBAAL,CAAyBC,UAAzB,CAAqCT,GAArC,CAZA,CAvB2B,CAsC7B,KAAKmL,CAAAA,cAAL;AAAsBnL,GAAAoL,EAAO,CAC3B,IAAI9B,EAEJ,KAAKlL,CAAAA,qBAAL,EACA,KAAKmH,CAAAA,eAAL,CAAuB,IACvB,KAAKvH,CAAAA,gBAAL,CAAwB,CAAA,CAExB,IAAIlB,YAAa8M,CAAAA,wBAAjB,CACE,IAAK,IAAIyB,EAAI,CAAb,CAAgBA,CAAhB,CAAoB,IAAKhM,CAAAA,cAAesE,CAAAA,MAAxC,CAAgD0H,CAAA,EAAhD,CACE,GAAI,IAAKhM,CAAAA,cAAL,CAAoBgM,CAApB,CAAJ,CAGE,GAAIrL,GAAIoF,CAAAA,MAAR,GAAmBiG,CAAnB,CACEjB,YAAA,CAA+C,IAAlC,IAACd,EAAD,CAAM,IAAKjK,CAAAA,cAAL,CAAoBgM,CAApB,CAAN,GAAiD,IAAK,EAAtD,GAA0C/B,EAA1C,CAA0D,IAAK,EAA/D,CAAmEA,EAAGS,CAAAA,SAAnF,CADF,KAEO,CAEL,IAAMpD,UAAY,IAAKtH,CAAAA,cAAL,CAAoBgM,CAApB,CAAuB1E,CAAAA,SACzC,KAAKrI,CAAAA,mBAAL,CAA2B,CAAA,CAC3BqI,UAAUE,CAAAA,WAAV,CAAwB,CAAA,CACxBF,UAAUM,CAAAA,MAAV,CAAmB,CAAA,CAEbvF,UAAAA,CAAO3E,cAAegF,CAAAA,iBAAkByF,CAAAA,UAC9C,OAAM1D,GAAK,IAAI/G,cAAeqF,CAAAA,WAAnB,CAA+BV,SAA/B;AAFK,IAAKrC,CAAAA,cAAL,CAAoBgM,CAApB,CAAuBrL,CAAAA,GAE5B,CAA8C,IAAK7B,CAAAA,kBAAnD,CAEPJ,MAAMuE,CAAAA,mBAAoBC,CAAAA,YAA1B,EAAJ,EAAgDxE,KAAMuE,CAAAA,mBAAoBoF,CAAAA,eAA1B,CAA0ChG,SAA1C,CAAhD,EACE3D,KAAMuE,CAAAA,mBAAoBE,CAAAA,eAA1B,CAA0CsB,EAA1C,CAA8CpC,SAA9C,CAIF,KAAKrC,CAAAA,cAAL,CAAoBgM,CAApB,CAAA,CAAyB,IAfpB,CAqBb,IAAKtL,CAAAA,sBAAL,CAA4BC,GAA5B,CAEiC,EAAC,CAAlC,GAAI,IAAKzB,CAAAA,mBAAT,GACE,IAAKA,CAAAA,mBADP,CAC6ByB,GAAIoF,CAAAA,MADjC,CAIIrH,MAAMuN,CAAAA,2BAAV,EAAyCtD,iBAAzC,GACEhI,GAAIuL,CAAAA,cAAJ,EACA,CAAAvD,iBAAkBwD,CAAAA,KAAlB,EAFF,CAKA,KAAK5M,CAAAA,wBAAyBsL,CAAAA,CAA9B,CAAkC,IAAKvL,CAAAA,SACvC,KAAKC,CAAAA,wBAAyBuL,CAAAA,CAA9B;AAAkC,IAAKzL,CAAAA,SACvC,KAAKM,CAAAA,oBAAL,CAA4BmH,IAAKC,CAAAA,GAAL,EAExB,KAAKvC,CAAAA,0BAAL,CAAgC,IAAhC,CAAsC7D,GAAtC,CAA2CjD,cAAegF,CAAAA,iBAAkBsD,CAAAA,WAA5E,CAAJ,EAIWb,CAANzG,KAAMyG,CAAAA,sBAJX,EAI4CtB,CAANnF,KAAMmF,CAAAA,YAJ5C,GAQA,IAAKjE,CAAAA,gBAAL,CAAsBe,GAAIJ,CAAAA,SAA1B,CAkBA,CAlBuC,CAAA,CAkBvC,CAhBK7B,KAAM0N,CAAAA,oBAgBX,GAfE1N,KAAM0N,CAAAA,oBAeR,CAf+B1F,IAAA2F,EACpB3F,IAAKC,CAAAA,UADe0F,EACD3F,IAAKE,CAAAA,SADJyF,EACiB3F,IAAKG,CAAAA,OAAL,EADjBwF,EACmC3F,IAAKgF,CAAAA,SAAL,EADnCW,GACwD,CAAC3N,KAAMyG,CAAAA,sBAD/DkH,EACuJ,CADvJA,IAC0F3N,KAAMyG,CAAAA,sBAAuB0G,CAAAA,SADvHQ,CACmI3F,IAAKmF,CAAAA,SADxIQ,EAe/B,EATA,IAAKnG,CAAAA,eASL,CATuB,IASvB,CALE9E,EAKF,CANI1C,KAAM4N,CAAAA,sBAAV;AAAiE,CAAjE,GAAoC5N,KAAMyK,CAAAA,kBAA1C,EAAsE,CAAC,IAAK/E,CAAAA,gBAAL,EAAvE,EAAkG,CAAC1F,KAAMyI,CAAAA,aAAzG,CACe,IAAIvJ,YAAa4N,CAAAA,WADhC,CAGe9M,KAAMsG,CAAAA,IAAN,CAAW,IAAKxE,CAAAA,qBAAhB,CAAuC,IAAKC,CAAAA,qBAA5C,CAAmE/B,KAAM0N,CAAAA,oBAAzE,CAA+F1N,KAAM6N,CAAAA,oBAArG,CAA2H7N,KAAMyG,CAAAA,sBAAjI,CAGf,CAAA,IAAKc,CAAAA,mBAAL,CAAyB7E,EAAzB,CAAqCT,GAArC,CA1BA,CAlD2B,CA+E7B,KAAK6L,CAAAA,YAAL,CAAoB7L,GAAA8L,EAAO,CACU,CAAnC,GAAI,IAAK1N,CAAAA,qBAAT,GAKA,IAAKA,CAAAA,qBAAL,EAWA,CAVA,IAAK4I,CAAAA,aAUL,CAVqB,IAUrB,CATA,IAAKhJ,CAAAA,gBASL,CATwB,CAAA,CASxB,CAPA,IAAK+B,CAAAA,sBAAL,CAA4BC,GAA5B,CAOA,CALIjC,KAAMgO,CAAAA,yBAKV,EALuC/D,iBAKvC;CAJEhI,GAAIuL,CAAAA,cAAJ,EACA,CAAAvD,iBAAkBwD,CAAAA,KAAlB,EAGF,EAAA,IAAKtC,CAAAA,eAAL,CAAqBnL,KAAMoG,CAAAA,sBAA3B,CAAmDpG,KAAMuE,CAAAA,mBAAzD,CAA8EtC,GAA9E,CAAmF,CAAC2G,SAAD,CAAYlG,UAAZ,CAAA,EAA2B,CAE5G,GAAI1C,KAAMoG,CAAAA,sBAAuB5B,CAAAA,YAA7B,EAAJ,GACE,IAAK9D,CAAAA,eAED,CAFmB,CAAA,CAEnB,CAAA,CAACkI,SAAUM,CAAAA,MAHjB,EAGyB,CACrB,GAAI,IAAKpD,CAAAA,0BAAL,CAAgC,IAAhC,CAAsC7D,GAAtC,CAA2CjD,cAAegF,CAAAA,iBAAkB+E,CAAAA,SAA5E,CAAJ,CAA4F,CAEtF,IAAKvI,CAAAA,mBAAT,GAAiCyB,GAAIoF,CAAAA,MAArC,GACE,IAAK/G,CAAAA,UACL,CADkB,CAAA,CAClB,CAAA,IAAKE,CAAAA,mBAAL,CAA2B,CAAC,CAF9B,CAKA,OAP0F,CAUvFoI,SAAUQ,CAAAA,SAAf,GACMR,SAAUE,CAAAA,WAMd,EAN6B9I,KAAMoG,CAAAA,sBAAuBuD,CAAAA,eAA7B,CAA6C3K,cAAegF,CAAAA,iBAAkByF,CAAAA,UAA9E,CAM7B;AALM,IAAK3D,CAAAA,0BAAL,CAAgC,IAAhC,CAAsC7D,GAAtC,CAA2CjD,cAAegF,CAAAA,iBAAkByF,CAAAA,UAA5E,CAKN,GAJI,IAAK/I,CAAAA,eAIT,CAJ2B,CAAA,CAI3B,EAAIkI,SAAUC,CAAAA,WAAd,EAA6B7I,KAAMoG,CAAAA,sBAAuBuD,CAAAA,eAA7B,CAA6C3K,cAAegF,CAAAA,iBAAkB0F,CAAAA,gBAA9E,CAA7B,EACM,IAAK5D,CAAAA,0BAAL,CAAgC,IAAhC,CAAsC7D,GAAtC,CAA2CjD,cAAegF,CAAAA,iBAAkB0F,CAAAA,gBAA5E,CADN,GAEI,IAAKhJ,CAAAA,eAFT,CAE2B,CAAA,CAF3B,CAPF,CAXqB,CA4BzB,GAAK,IAAKQ,CAAAA,gBAAL,CAAsBe,GAAIJ,CAAAA,SAA1B,CAAL,CAcA,IAJoB,CAIhB,GAJAI,GAAIgM,CAAAA,OAIJ,GAHF,IAAK/M,CAAAA,gBAAL,CAAsBe,GAAIJ,CAAAA,SAA1B,CAGE,CAHqC,CAAA,CAGrC,EAAC7B,KAAMyG,CAAAA,sBAAP,EAAkCzG,KAAMmF,CAAAA,YAA5C,CAIKnF,KAAM0K,CAAAA,kBAmBX;CAlBE1K,KAAM0K,CAAAA,kBAkBR,CAlB6B1C,IAAAkG,EAClBlG,IAAKC,CAAAA,UADaiG,EACClG,IAAKE,CAAAA,SADNgG,EACmBlG,IAAKG,CAAAA,OAAL,EADnB+F,EACqClG,IAAKgF,CAAAA,SAAL,EADrCkB,GAC0D,CAAClO,KAAMyG,CAAAA,sBADjEyH,EACyJ,CADzJA,IAC4FlO,KAAMyG,CAAAA,sBAAuB0G,CAAAA,SADzHe,CACqIlG,IAAKmF,CAAAA,SAD1Ie,EAkB7B,EAZI,CAAC,IAAKjO,CAAAA,gBAYV,GAZ+BhB,sBAAuByM,CAAAA,qBAYtD,EAZ+EzM,sBAAuByM,CAAAA,qBAAsByC,CAAAA,WAY5H,EAZ2I,IAAKzI,CAAAA,gBAAL,EAY3I,EAZsK1F,KAAMwJ,CAAAA,WAY5K,GAXE,IAAKa,CAAAA,kBAAL,CAAwB,IAAxB,CAA8BzB,SAA9B,CAWF,CARKlG,UAQL,GAPEA,UAOF,CAPe,IAAKtC,CAAAA,kBAOpB,EAJA,IAAK4I,CAAAA,iBAAL,CAAuBtG,UAAvB,CAAmCT,GAAnC,CAAwC2G,SAAxC,CAIA;AAFA,IAAKzI,CAAAA,mBAEL,CAF2B,IAAKC,CAAAA,kBAEhC,CAAI,IAAKI,CAAAA,mBAAT,GAAiCyB,GAAIoF,CAAAA,MAArC,GACE,IAAK/G,CAAAA,UACL,CADkB,CAAA,CAClB,CAAA,IAAKE,CAAAA,mBAAL,CAA2B,CAAC,CAF9B,CAvBA,CAdA,IACM,KAAKA,CAAAA,mBAAT,GAAiCyB,GAAIoF,CAAAA,MAArC,GACE,IAAK/G,CAAAA,UACL,CADkB,CAAA,CAClB,CAAA,IAAKE,CAAAA,mBAAL,CAA2B,CAAC,CAF9B,CAlC0G,CAA9G,CAhBA,CADyB,CA8F3B,KAAK4N,CAAAA,UAAL,CAAkBnM,GAAAoM,EAAO,CACvB,MAAM1K,KAAOtE,eAAgBiP,CAAAA,kBAAmBC,CAAAA,OAEhD,IAAIvO,KAAMwO,CAAAA,uBAAwBhK,CAAAA,YAA9B,EAAJ,CAAkD,CAChD,IAAMuB,GAAK,IAAI1G,eAAgBoP,CAAAA,eAApB,CAAoC9K,IAApC,CAA0C1B,GAA1C,CACXjC,MAAMwO,CAAAA,uBAAwB/J,CAAAA,eAA9B,CAA8CsB,EAA9C,CAAkDpC,IAAlD,CAEA,IAAIoC,EAAG2I,CAAAA,wBAAP,CACE,MAL8C,CAS9C1O,KAAM2O,CAAAA,oBAAqBnK,CAAAA,YAA3B,EAAJ;CACQuB,EACN,CADW,IAAI1G,eAAgBuP,CAAAA,YAApB,CAAiCjL,IAAjC,CAAuC1B,GAAvC,CACX,CAAAjC,KAAM2O,CAAAA,oBAAqBlK,CAAAA,eAA3B,CAA2CsB,EAA3C,CAA+CpC,IAA/C,CAFF,CAKI3D,MAAM4G,CAAAA,aAAV,EACE5G,KAAM4G,CAAAA,aAAcc,CAAAA,cAApB,CAAmC,EAAnC,CAAuCtI,YAAauI,CAAAA,WAAYkH,CAAAA,kBAAzB,CAA4C7O,KAA5C,CAAmDiC,GAAnD,CAAvC,CAlBqB,CAsBzB,KAAK6M,CAAAA,QAAL,CAAgB7M,GAAA8M,EAAO,CACrB,MAAMpL,KAAOtE,eAAgBiP,CAAAA,kBAAmBU,CAAAA,KAEhD,IAAIhP,KAAMwO,CAAAA,uBAAwBhK,CAAAA,YAA9B,EAAJ,CAAkD,CAChD,IAAMuB,GAAK,IAAI1G,eAAgBoP,CAAAA,eAApB,CAAoC9K,IAApC,CAA0C1B,GAA1C,CACXjC,MAAMwO,CAAAA,uBAAwB/J,CAAAA,eAA9B,CAA8CsB,EAA9C,CAAkDpC,IAAlD,CAEA,IAAIoC,EAAG2I,CAAAA,wBAAP,CACE,MAL8C,CAS9C1O,KAAM2O,CAAAA,oBAAqBnK,CAAAA,YAA3B,EAAJ;CACQuB,EACN,CADW,IAAI1G,eAAgBuP,CAAAA,YAApB,CAAiCjL,IAAjC,CAAuC1B,GAAvC,CACX,CAAAjC,KAAM2O,CAAAA,oBAAqBlK,CAAAA,eAA3B,CAA2CsB,EAA3C,CAA+CpC,IAA/C,CAFF,CAKI3D,MAAM4G,CAAAA,aAAV,EACE5G,KAAM4G,CAAAA,aAAcc,CAAAA,cAApB,CAAmC,EAAnC,CAAuCtI,YAAauI,CAAAA,WAAYkH,CAAAA,kBAAzB,CAA4C7O,KAA5C,CAAmDiC,GAAnD,CAAvC,CAlBmB,CAuBvB,KAAK1C,CAAAA,oBAAqB0P,CAAAA,2BAA4B1J,CAAAA,GAAtD,CAA0D2J,YAAA,EAAgB,CACpEA,YAAaC,CAAAA,UAAjB,GAAgC7P,YAAa8P,CAAAA,UAAWC,CAAAA,KAAxD,CACEH,YAAaI,CAAAA,wBAAyB/J,CAAAA,GAAtC,CAA0CgK,SAAA,EAAa,CACjDA,SAAU3L,CAAAA,UAAd,GAA6BtE,YAAauE,CAAAA,YAAa2L,CAAAA,SAAvD,EAAoED,SAAU3L,CAAAA,UAA9E,GAA6FtE,YAAauE,CAAAA,YAAa4L,CAAAA,WAAvH;AAAsIF,SAAU3L,CAAAA,UAAhJ,GAA+JtE,YAAauE,CAAAA,YAAa6L,CAAAA,UAAzL,EAAuMH,SAAU3L,CAAAA,UAAjN,GAAgOtE,YAAauE,CAAAA,YAAa8L,CAAAA,WAA1P,EAAyQJ,SAAU3L,CAAAA,UAAnR,GAAkStE,YAAauE,CAAAA,YAAa+L,CAAAA,cAA5T,CACM7F,UAAJ,EAAkE,CAAlE,GAAkBmF,YAAaW,CAAAA,QAAb,CAAsBN,SAAU3L,CAAAA,UAAhC,CAAlB,CACE,IAAKwJ,CAAAA,cAAL,CAAoBmC,SAApB,CADF,CAEWzF,QAFX,EAEuE,CAFvE,GAEuBoF,YAAaW,CAAAA,QAAb,CAAsBN,SAAU3L,CAAAA,UAAhC,CAFvB,EAGE,IAAKkK,CAAAA,YAAL,CAAkByB,SAAlB,CAJJ,CAMWvF,UANX,GAOMuF,SAAU3L,CAAAA,UAAd,GAA6BtE,YAAauE,CAAAA,YAAasD,CAAAA,IAAvD,CACE,IAAKmF,CAAAA,cAAL,CAAoBiD,SAApB,CADF,EAEWA,SAAU3L,CAAAA,UAFrB,GAEoCtE,YAAauE,CAAAA,YAAaC,CAAAA,WAF9D;AAE6EyL,SAAU3L,CAAAA,UAFvF,GAEsGtE,YAAauE,CAAAA,YAAaiM,CAAAA,WAFhI,EAE+IP,SAAU3L,CAAAA,UAFzJ,GAEwKtE,YAAauE,CAAAA,YAAaE,CAAAA,WAFlM,GAGE,IAAKuI,CAAAA,cAAL,CAAoBiD,SAApB,CAVJ,CADqD,CAAvD,CADF,CAgBWL,YAAaC,CAAAA,UAAjB,GAAgC7P,YAAa8P,CAAAA,UAAWW,CAAAA,KAAxD,CACLb,YAAaI,CAAAA,wBAAyB/J,CAAAA,GAAtC,CAA0CgK,SAAA,EAAa,CACjDA,SAAU3L,CAAAA,UAAd,GAA6BtE,YAAauE,CAAAA,YAAa2L,CAAAA,SAAvD,GACMzF,UAAJ,EAAkE,CAAlE,GAAkBmF,YAAaW,CAAAA,QAAb,CAAsBN,SAAU3L,CAAAA,UAAhC,CAAlB,EACE,IAAKwJ,CAAAA,cAAL,CAAoBmC,SAApB,CAEA,CAAiC,CAAjC,CAAI,IAAKlP,CAAAA,qBAAT,GACE,IAAKI,CAAAA,oBADP,CAC8B,CAAA,CAD9B,CAHF,EAMWqJ,QANX,EAMuE,CANvE,GAMuBoF,YAAaW,CAAAA,QAAb,CAAsBN,SAAU3L,CAAAA,UAAhC,CANvB;CAOE,IAAKkK,CAAAA,YAAL,CAAkByB,SAAlB,CAEA,CAAmC,CAAnC,GAAI,IAAKlP,CAAAA,qBAAT,GACE,IAAKI,CAAAA,oBADP,CAC8B,CAAA,CAD9B,CATF,CADF,CAgBIuJ,WAAJ,EAAkBuF,SAAU3L,CAAAA,UAA5B,GAA2CtE,YAAauE,CAAAA,YAAasD,CAAAA,IAArE,EACE,IAAKmF,CAAAA,cAAL,CAAoBiD,SAApB,CAlBmD,CAAvD,CADK,CAsBIL,YAAaC,CAAAA,UAtBjB,GAsBgC7P,YAAa8P,CAAAA,UAAWY,CAAAA,QAtBxD,EAuBLd,YAAaI,CAAAA,wBAAyB/J,CAAAA,GAAtC,CAA0CgK,SAAA,EAAa,CAC9B,SAAvB,GAAIA,SAAU5L,CAAAA,IAAd,CACE,IAAKyK,CAAAA,UAAL,CAAgBmB,SAAhB,CADF,CAE8B,OAF9B,GAEWA,SAAU5L,CAAAA,IAFrB,EAGE,IAAKmL,CAAAA,QAAL,CAAcS,SAAd,CAJmD,CAAvD,CAxCsE,CAA1E,CAkDA,KAAKrP,CAAAA,gBAAL,CAAwB,CAAA,CAteqE,CA6e/FgK,aAAa,EAAG,CACV,IAAKhK,CAAAA,gBAAT,GACE,IAAKX,CAAAA,oBAAqB0Q,CAAAA,OAA1B,EASA;AAPA,IAAK1Q,CAAAA,oBAOL,CAP4B,IAO5B,CALI,IAAK4K,CAAAA,kBAKT,EAL+B,CAAC,IAAK5I,CAAAA,MAAOyB,CAAAA,kBAK5C,GAJE,IAAKmH,CAAAA,kBAAmBlH,CAAAA,KAAMC,CAAAA,MAIhC,CAJyC,IAAK3B,CAAAA,MAAO4B,CAAAA,aAIrD,EADA,IAAKjD,CAAAA,gBACL,CADwB,CAAA,CACxB,CAAA,IAAKiK,CAAAA,kBAAL,CAA0B,IAV5B,CADc,CAuBhBxD,kBAAkB,CAACqB,IAAD,CAAOnG,SAAA,CAAY,CAAnB,CAAsBa,UAAtB,CAAkCT,GAAlC,CAAuC,CACvD,GAAI,IAAKd,CAAAA,mBAAL,CAAyBU,SAAzB,CAAJ,GAA4CmG,IAA5C,EAAsDA,IAAtD,EAA+DA,IAAKkI,CAAAA,6BAA8BC,CAAAA,8BAAlG,CAAA,CAIA,IAAMC,iBAAmB,IAAKjP,CAAAA,mBAAL,CAAyBU,SAAzB,CAAzB,CACI+E,aAEAwJ,iBAAJ,GACExJ,aADF,CACkBwJ,gBAAiBvJ,CAAAA,2BAAjB,CAA6C,EAA7C,CADlB;AAIID,aAAcc,CAAAA,cAAd,CAA6B,EAA7B,CAAiCtI,YAAauI,CAAAA,WAAYC,CAAAA,SAAzB,CAAmCwI,gBAAnC,CAAqDnO,GAArD,CAA0D,CACzFJ,SADyF,CAA1D,CAAjC,CAMAmG,KAAJ,EAEE,IAAKrG,CAAAA,gBAGL,CAJA,IAAKR,CAAAA,mBAAL,CAAyBU,SAAzB,CAIA,CAJsCmG,IAItC,EAFApB,aAEA,CAFgBoB,IAAKnB,CAAAA,2BAAL,CAAiC,CAAjC,CAEhB,GACED,aAAcc,CAAAA,cAAd,CAA6B,CAA7B,CAAgCtI,YAAauI,CAAAA,WAAYC,CAAAA,SAAzB,CAAmCI,IAAnC,CAAyC/F,GAAzC,CAA8C,CAC5EJ,SAD4E,CAE5Ea,UAF4E,CAA9C,CAAhC,CANJ,GAYE,OAAO,IAAKvB,CAAAA,mBAAL,CAAyBU,SAAzB,CACP,CAAA,IAAKF,CAAAA,gBAAL,CAAwB,IAb1B,CAjBA,CADuD,CAwCzD0O,kBAAkB,EAAG,CACnB,MAAO,KAAKC,CAAAA,gBADO,CASrBC,eAAe,CAACvI,IAAD,CAAO,CAChB,IAAKrG,CAAAA,gBAAT,GAA8BqG,IAA9B,GACE,IAAKrG,CAAAA,gBADP;AAC0B,IAD1B,CAII,KAAK6F,CAAAA,eAAT,GAA6BQ,IAA7B,GACE,IAAKR,CAAAA,eADP,CACyB,IADzB,CAII,KAAKyB,CAAAA,aAAT,GAA2BjB,IAA3B,GACE,IAAKiB,CAAAA,aADP,CACuB,IADvB,CAIA,KAAK,MAAMpH,SAAX,GAAwB,KAAKV,CAAAA,mBAA7B,CACM,IAAKA,CAAAA,mBAAL,CAAyBU,SAAzB,CAAJ,GAA4CmG,IAA5C,EACE,OAAO,IAAK7G,CAAAA,mBAAL,CAAyBU,SAAzB,CAfS,CArhCxB,CA6iCAlD,OAAQI,CAAAA,YAAR,CAAuBA,YACvBA,aAAa2N,CAAAA,qBAAb,CAAqC,EAIrC3N,aAAauJ,CAAAA,cAAb,CAA8B,GAI9BvJ,aAAakM,CAAAA,gBAAb,CAAgC,GAQhClM,aAAa8M,CAAAA,wBAAb,CAAwC,CAAA,CAxoCkF;",
"sources":["node_modules/@babylonjs/core/Inputs/scene.inputManager.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$babylonjs$core$Inputs$scene_inputManager\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.InputManager = void 0;\n\nvar _pointerEvents = require(\"../Events/pointerEvents.js\");\n\nvar _abstractActionManager = require(\"../Actions/abstractActionManager.js\");\n\nvar _pickingInfo = require(\"../Collisions/pickingInfo.js\");\n\nvar _mathVector = require(\"../Maths/math.vector.js\");\n\nvar _actionEvent = require(\"../Actions/actionEvent.js\");\n\nvar _keyboardEvents = require(\"../Events/keyboardEvents.js\");\n\nvar _deviceEnums = require(\"../DeviceInput/InputDevices/deviceEnums.js\");\n\nvar _deviceSourceManager = require(\"../DeviceInput/InputDevices/deviceSourceManager.js\");\n\nvar _engineStore = require(\"../Engines/engineStore.js\");\n\n/** @internal */\n// eslint-disable-next-line @typescript-eslint/naming-convention\nclass _ClickInfo {\n  constructor() {\n    this._singleClick = false;\n    this._doubleClick = false;\n    this._hasSwiped = false;\n    this._ignore = false;\n  }\n\n  get singleClick() {\n    return this._singleClick;\n  }\n\n  get doubleClick() {\n    return this._doubleClick;\n  }\n\n  get hasSwiped() {\n    return this._hasSwiped;\n  }\n\n  get ignore() {\n    return this._ignore;\n  }\n\n  set singleClick(b) {\n    this._singleClick = b;\n  }\n\n  set doubleClick(b) {\n    this._doubleClick = b;\n  }\n\n  set hasSwiped(b) {\n    this._hasSwiped = b;\n  }\n\n  set ignore(b) {\n    this._ignore = b;\n  }\n\n}\n/**\n * Class used to manage all inputs for the scene.\n */\n\n\nclass InputManager {\n  /**\n   * Creates a new InputManager\n   * @param scene - defines the hosting scene\n   */\n  constructor(scene) {\n    /** This is a defensive check to not allow control attachment prior to an already active one. If already attached, previous control is unattached before attaching the new one. */\n    this._alreadyAttached = false;\n    this._meshPickProceed = false;\n    this._currentPickResult = null;\n    this._previousPickResult = null;\n    this._totalPointersPressed = 0;\n    this._doubleClickOccured = false;\n    this._isSwiping = false;\n    this._swipeButtonPressed = -1;\n    this._skipPointerTap = false;\n    this._isMultiTouchGesture = false;\n    this._pointerX = 0;\n    this._pointerY = 0;\n    this._startingPointerPosition = new _mathVector.Vector2(0, 0);\n    this._previousStartingPointerPosition = new _mathVector.Vector2(0, 0);\n    this._startingPointerTime = 0;\n    this._previousStartingPointerTime = 0;\n    this._pointerCaptures = {};\n    this._meshUnderPointerId = {};\n    this._movePointerInfo = null;\n    this._cameraObserverCount = 0;\n    this._delayedClicks = [null, null, null, null, null];\n    this._deviceSourceManager = null;\n    this._scene = scene || _engineStore.EngineStore.LastCreatedScene;\n\n    if (!this._scene) {\n      return;\n    }\n  }\n  /**\n   * Gets the mesh that is currently under the pointer\n   * @returns Mesh that the pointer is pointer is hovering over\n   */\n\n\n  get meshUnderPointer() {\n    if (this._movePointerInfo) {\n      // Because _pointerOverMesh is populated as part of _pickMove, we need to force a pick to update it.\n      // Calling _pickMove calls _setCursorAndPointerOverMesh which calls setPointerOverMesh\n      this._movePointerInfo._generatePickInfo(); // Once we have what we need, we can clear _movePointerInfo because we don't need it anymore\n\n\n      this._movePointerInfo = null;\n    }\n\n    return this._pointerOverMesh;\n  }\n  /**\n   * When using more than one pointer (for example in XR) you can get the mesh under the specific pointer\n   * @param pointerId - the pointer id to use\n   * @returns The mesh under this pointer id or null if not found\n   */\n\n\n  getMeshUnderPointerByPointerId(pointerId) {\n    return this._meshUnderPointerId[pointerId] || null;\n  }\n  /**\n   * Gets the pointer coordinates in 2D without any translation (ie. straight out of the pointer event)\n   * @returns Vector with X/Y values directly from pointer event\n   */\n\n\n  get unTranslatedPointer() {\n    return new _mathVector.Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);\n  }\n  /**\n   * Gets or sets the current on-screen X position of the pointer\n   * @returns Translated X with respect to screen\n   */\n\n\n  get pointerX() {\n    return this._pointerX;\n  }\n\n  set pointerX(value) {\n    this._pointerX = value;\n  }\n  /**\n   * Gets or sets the current on-screen Y position of the pointer\n   * @returns Translated Y with respect to screen\n   */\n\n\n  get pointerY() {\n    return this._pointerY;\n  }\n\n  set pointerY(value) {\n    this._pointerY = value;\n  }\n\n  _updatePointerPosition(evt) {\n    const canvasRect = this._scene.getEngine().getInputElementClientRect();\n\n    if (!canvasRect) {\n      return;\n    }\n\n    this._pointerX = evt.clientX - canvasRect.left;\n    this._pointerY = evt.clientY - canvasRect.top;\n    this._unTranslatedPointerX = this._pointerX;\n    this._unTranslatedPointerY = this._pointerY;\n  }\n\n  _processPointerMove(pickResult, evt) {\n    const scene = this._scene;\n    const engine = scene.getEngine();\n    const canvas = engine.getInputElement();\n\n    if (canvas) {\n      canvas.tabIndex = engine.canvasTabIndex; // Restore pointer\n\n      if (!scene.doNotHandleCursors) {\n        canvas.style.cursor = scene.defaultCursor;\n      }\n    }\n\n    this._setCursorAndPointerOverMesh(pickResult, evt, scene);\n\n    for (const step of scene._pointerMoveStage) {\n      // If _pointerMoveState is defined, we have an active spriteManager and can't use Lazy Picking\n      // Therefore, we need to force a pick to update the pickResult\n      pickResult = pickResult || this._pickMove(evt);\n      const isMeshPicked = (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) ? true : false;\n      pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);\n    }\n\n    const type = evt.inputIndex >= _deviceEnums.PointerInput.MouseWheelX && evt.inputIndex <= _deviceEnums.PointerInput.MouseWheelZ ? _pointerEvents.PointerEventTypes.POINTERWHEEL : _pointerEvents.PointerEventTypes.POINTERMOVE;\n\n    if (scene.onPointerMove) {\n      // Because of lazy picking, we need to force a pick to update the pickResult\n      pickResult = pickResult || this._pickMove(evt);\n      scene.onPointerMove(evt, pickResult, type);\n    }\n\n    let pointerInfo;\n\n    if (pickResult) {\n      pointerInfo = new _pointerEvents.PointerInfo(type, evt, pickResult);\n\n      this._setRayOnPointerInfo(pickResult, evt);\n    } else {\n      pointerInfo = new _pointerEvents.PointerInfo(type, evt, null, this);\n      this._movePointerInfo = pointerInfo;\n    }\n\n    if (scene.onPointerObservable.hasObservers()) {\n      scene.onPointerObservable.notifyObservers(pointerInfo, type);\n    }\n  } // Pointers handling\n\n  /** @internal */\n\n\n  _setRayOnPointerInfo(pickInfo, event) {\n    const scene = this._scene;\n\n    if (pickInfo && scene._pickingAvailable) {\n      if (!pickInfo.ray) {\n        pickInfo.ray = scene.createPickingRay(event.offsetX, event.offsetY, _mathVector.Matrix.Identity(), scene.activeCamera);\n      }\n    }\n  }\n  /** @internal */\n\n\n  _addCameraPointerObserver(observer, mask) {\n    this._cameraObserverCount++;\n    return this._scene.onPointerObservable.add(observer, mask);\n  }\n  /** @internal */\n\n\n  _removeCameraPointerObserver(observer) {\n    this._cameraObserverCount--;\n    return this._scene.onPointerObservable.remove(observer);\n  }\n\n  _checkForPicking() {\n    return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick);\n  }\n\n  _checkPrePointerObservable(pickResult, evt, type) {\n    const scene = this._scene;\n    const pi = new _pointerEvents.PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);\n\n    if (pickResult) {\n      pi.originalPickingInfo = pickResult;\n      pi.ray = pickResult.ray;\n\n      if (pickResult.originMesh) {\n        pi.nearInteractionPickingInfo = pickResult;\n      }\n    }\n\n    scene.onPrePointerObservable.notifyObservers(pi, type);\n\n    if (pi.skipOnPointerObservable) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n  /** @internal */\n\n\n  _pickMove(evt) {\n    const scene = this._scene;\n    const pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerMovePredicate, scene.pointerMoveFastCheck, scene.cameraToUseForPointers, scene.pointerMoveTrianglePredicate);\n\n    this._setCursorAndPointerOverMesh(pickResult, evt, scene);\n\n    return pickResult;\n  }\n\n  _setCursorAndPointerOverMesh(pickResult, evt, scene) {\n    const engine = scene.getEngine();\n    const canvas = engine.getInputElement();\n\n    if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {\n      this.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId, pickResult, evt);\n\n      if (!scene.doNotHandleCursors && canvas && this._pointerOverMesh) {\n        const actionManager = this._pointerOverMesh._getActionManagerForTrigger();\n\n        if (actionManager && actionManager.hasPointerTriggers) {\n          canvas.style.cursor = actionManager.hoverCursor || scene.hoverCursor;\n        }\n      }\n    } else {\n      this.setPointerOverMesh(null, evt.pointerId, pickResult, evt);\n    }\n  }\n  /**\n   * Use this method to simulate a pointer move on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   */\n\n\n  simulatePointerMove(pickResult, pointerEventInit) {\n    const evt = new PointerEvent(\"pointermove\", pointerEventInit);\n    evt.inputIndex = _deviceEnums.PointerInput.Move;\n\n    if (this._checkPrePointerObservable(pickResult, evt, _pointerEvents.PointerEventTypes.POINTERMOVE)) {\n      return;\n    }\n\n    this._processPointerMove(pickResult, evt);\n  }\n  /**\n   * Use this method to simulate a pointer down on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   */\n\n\n  simulatePointerDown(pickResult, pointerEventInit) {\n    const evt = new PointerEvent(\"pointerdown\", pointerEventInit);\n    evt.inputIndex = evt.button + 2;\n\n    if (this._checkPrePointerObservable(pickResult, evt, _pointerEvents.PointerEventTypes.POINTERDOWN)) {\n      return;\n    }\n\n    this._processPointerDown(pickResult, evt);\n  }\n\n  _processPointerDown(pickResult, evt) {\n    const scene = this._scene;\n\n    if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {\n      this._pickedDownMesh = pickResult.pickedMesh;\n\n      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\n\n      if (actionManager) {\n        if (actionManager.hasPickTriggers) {\n          actionManager.processTrigger(5, _actionEvent.ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n\n          switch (evt.button) {\n            case 0:\n              actionManager.processTrigger(2, _actionEvent.ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n\n            case 1:\n              actionManager.processTrigger(4, _actionEvent.ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n\n            case 2:\n              actionManager.processTrigger(3, _actionEvent.ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              break;\n          }\n        }\n\n        if (actionManager.hasSpecificTrigger(8)) {\n          window.setTimeout(() => {\n            const pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, mesh => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh === this._pickedDownMesh, false, scene.cameraToUseForPointers);\n\n            if ((pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) && actionManager) {\n              if (this._totalPointersPressed !== 0 && Date.now() - this._startingPointerTime > InputManager.LongPressDelay && !this._isPointerSwiping()) {\n                this._startingPointerTime = 0;\n                actionManager.processTrigger(8, _actionEvent.ActionEvent.CreateNew(pickResult.pickedMesh, evt));\n              }\n            }\n          }, InputManager.LongPressDelay);\n        }\n      }\n    } else {\n      for (const step of scene._pointerDownStage) {\n        pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, false);\n      }\n    }\n\n    let pointerInfo;\n    const type = _pointerEvents.PointerEventTypes.POINTERDOWN;\n\n    if (pickResult) {\n      if (scene.onPointerDown) {\n        scene.onPointerDown(evt, pickResult, type);\n      }\n\n      pointerInfo = new _pointerEvents.PointerInfo(type, evt, pickResult);\n\n      this._setRayOnPointerInfo(pickResult, evt);\n    } else {\n      pointerInfo = new _pointerEvents.PointerInfo(type, evt, null, this);\n    }\n\n    if (scene.onPointerObservable.hasObservers()) {\n      scene.onPointerObservable.notifyObservers(pointerInfo, type);\n    }\n  }\n  /**\n   * @internal\n   * @internals Boolean if delta for pointer exceeds drag movement threshold\n   */\n\n\n  _isPointerSwiping() {\n    return this._isSwiping;\n  }\n  /**\n   * Use this method to simulate a pointer up on a mesh\n   * The pickResult parameter can be obtained from a scene.pick or scene.pickWithRay\n   * @param pickResult - pickingInfo of the object wished to simulate pointer event on\n   * @param pointerEventInit - pointer event state to be used when simulating the pointer event (eg. pointer id for multitouch)\n   * @param doubleTap - indicates that the pointer up event should be considered as part of a double click (false by default)\n   */\n\n\n  simulatePointerUp(pickResult, pointerEventInit, doubleTap) {\n    const evt = new PointerEvent(\"pointerup\", pointerEventInit);\n    evt.inputIndex = _deviceEnums.PointerInput.Move;\n    const clickInfo = new _ClickInfo();\n\n    if (doubleTap) {\n      clickInfo.doubleClick = true;\n    } else {\n      clickInfo.singleClick = true;\n    }\n\n    if (this._checkPrePointerObservable(pickResult, evt, _pointerEvents.PointerEventTypes.POINTERUP)) {\n      return;\n    }\n\n    this._processPointerUp(pickResult, evt, clickInfo);\n  }\n\n  _processPointerUp(pickResult, evt, clickInfo) {\n    const scene = this._scene;\n\n    if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {\n      this._pickedUpMesh = pickResult.pickedMesh;\n\n      if (this._pickedDownMesh === this._pickedUpMesh) {\n        if (scene.onPointerPick) {\n          scene.onPointerPick(evt, pickResult);\n        }\n\n        if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.observers.length > this._cameraObserverCount) {\n          const type = _pointerEvents.PointerEventTypes.POINTERPICK;\n          const pi = new _pointerEvents.PointerInfo(type, evt, pickResult);\n\n          this._setRayOnPointerInfo(pickResult, evt);\n\n          scene.onPointerObservable.notifyObservers(pi, type);\n        }\n      }\n\n      const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();\n\n      if (actionManager && !clickInfo.ignore) {\n        actionManager.processTrigger(7, _actionEvent.ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n\n        if (!clickInfo.hasSwiped && clickInfo.singleClick) {\n          actionManager.processTrigger(1, _actionEvent.ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n        }\n\n        const doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);\n\n        if (clickInfo.doubleClick && doubleClickActionManager) {\n          doubleClickActionManager.processTrigger(6, _actionEvent.ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));\n        }\n      }\n    } else {\n      if (!clickInfo.ignore) {\n        for (const step of scene._pointerUpStage) {\n          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, clickInfo.doubleClick);\n        }\n      }\n    }\n\n    if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {\n      const pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);\n\n      if (pickedDownActionManager) {\n        pickedDownActionManager.processTrigger(16, _actionEvent.ActionEvent.CreateNew(this._pickedDownMesh, evt));\n      }\n    }\n\n    if (!clickInfo.ignore) {\n      const pi = new _pointerEvents.PointerInfo(_pointerEvents.PointerEventTypes.POINTERUP, evt, pickResult); // Set ray on picking info.  Note that this info will also be reused for the tap notification.\n\n      this._setRayOnPointerInfo(pickResult, evt);\n\n      scene.onPointerObservable.notifyObservers(pi, _pointerEvents.PointerEventTypes.POINTERUP);\n\n      if (scene.onPointerUp) {\n        scene.onPointerUp(evt, pickResult, _pointerEvents.PointerEventTypes.POINTERUP);\n      }\n\n      if (!clickInfo.hasSwiped && !this._skipPointerTap && !this._isMultiTouchGesture) {\n        let type = 0;\n\n        if (clickInfo.singleClick) {\n          type = _pointerEvents.PointerEventTypes.POINTERTAP;\n        } else if (clickInfo.doubleClick) {\n          type = _pointerEvents.PointerEventTypes.POINTERDOUBLETAP;\n        }\n\n        if (type) {\n          const pi = new _pointerEvents.PointerInfo(type, evt, pickResult);\n\n          if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\n            scene.onPointerObservable.notifyObservers(pi, type);\n          }\n        }\n      }\n    }\n  }\n  /**\n   * Gets a boolean indicating if the current pointer event is captured (meaning that the scene has already handled the pointer down)\n   * @param pointerId - defines the pointer id to use in a multi-touch scenario (0 by default)\n   * @returns true if the pointer was captured\n   */\n\n\n  isPointerCaptured(pointerId = 0) {\n    return this._pointerCaptures[pointerId];\n  }\n  /**\n   * Attach events to the canvas (To handle actionManagers triggers and raise onPointerMove, onPointerDown and onPointerUp\n   * @param attachUp - defines if you want to attach events to pointerup\n   * @param attachDown - defines if you want to attach events to pointerdown\n   * @param attachMove - defines if you want to attach events to pointermove\n   * @param elementToAttachTo - defines the target DOM element to attach to (will use the canvas by default)\n   */\n\n\n  attachControl(attachUp = true, attachDown = true, attachMove = true, elementToAttachTo = null) {\n    const scene = this._scene;\n    const engine = scene.getEngine();\n\n    if (!elementToAttachTo) {\n      elementToAttachTo = engine.getInputElement();\n    }\n\n    if (this._alreadyAttached) {\n      this.detachControl();\n    }\n\n    if (elementToAttachTo) {\n      this._alreadyAttachedTo = elementToAttachTo;\n    }\n\n    this._deviceSourceManager = new _deviceSourceManager.DeviceSourceManager(engine); // Because this is only called from _initClickEvent, which is called in _onPointerUp, we'll use the pointerUpPredicate for the pick call\n\n    this._initActionManager = act => {\n      if (!this._meshPickProceed) {\n        const pickResult = scene.skipPointerUpPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerUp ? null : scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerUpPredicate, scene.pointerUpFastCheck, scene.cameraToUseForPointers);\n        this._currentPickResult = pickResult;\n\n        if (pickResult) {\n          act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;\n        }\n\n        this._meshPickProceed = true;\n      }\n\n      return act;\n    };\n\n    this._delayedSimpleClick = (btn, clickInfo, cb) => {\n      // double click delay is over and that no double click has been raised since, or the 2 consecutive keys pressed are different\n      if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay && !this._doubleClickOccured || btn !== this._previousButtonPressed) {\n        this._doubleClickOccured = false;\n        clickInfo.singleClick = true;\n        clickInfo.ignore = false; // If we have a delayed click, we need to resolve the TAP event\n\n        if (this._delayedClicks[btn]) {\n          const evt = this._delayedClicks[btn].evt;\n          const type = _pointerEvents.PointerEventTypes.POINTERTAP;\n          const pi = new _pointerEvents.PointerInfo(type, evt, this._currentPickResult);\n\n          if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\n            scene.onPointerObservable.notifyObservers(pi, type);\n          } // Clear the delayed click\n\n\n          this._delayedClicks[btn] = null;\n        }\n      }\n    };\n\n    this._initClickEvent = (obs1, obs2, evt, cb) => {\n      var _a, _b;\n\n      const clickInfo = new _ClickInfo();\n      this._currentPickResult = null;\n      let act = null;\n      let checkPicking = obs1.hasSpecificMask(_pointerEvents.PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(_pointerEvents.PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(_pointerEvents.PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(_pointerEvents.PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(_pointerEvents.PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(_pointerEvents.PointerEventTypes.POINTERDOUBLETAP);\n\n      if (!checkPicking && _abstractActionManager.AbstractActionManager) {\n        act = this._initActionManager(act, clickInfo);\n\n        if (act) {\n          checkPicking = act.hasPickTriggers;\n        }\n      }\n\n      let needToIgnoreNext = false;\n\n      if (checkPicking) {\n        const btn = evt.button;\n        clickInfo.hasSwiped = this._isPointerSwiping();\n\n        if (!clickInfo.hasSwiped) {\n          let checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;\n\n          if (!checkSingleClickImmediately) {\n            checkSingleClickImmediately = !obs1.hasSpecificMask(_pointerEvents.PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(_pointerEvents.PointerEventTypes.POINTERDOUBLETAP);\n\n            if (checkSingleClickImmediately && !_abstractActionManager.AbstractActionManager.HasSpecificTrigger(6)) {\n              act = this._initActionManager(act, clickInfo);\n\n              if (act) {\n                checkSingleClickImmediately = !act.hasSpecificTrigger(6);\n              }\n            }\n          }\n\n          if (checkSingleClickImmediately) {\n            // single click detected if double click delay is over or two different successive keys pressed without exclusive double click or no double click required\n            if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== this._previousButtonPressed) {\n              clickInfo.singleClick = true;\n              cb(clickInfo, this._currentPickResult);\n              needToIgnoreNext = true;\n            }\n          } // at least one double click is required to be check and exclusive double click is enabled\n          else {\n            // Queue up a delayed click, just in case this isn't a double click\n            // It should be noted that while this delayed event happens\n            // because of user input, it shouldn't be considered as a direct,\n            // timing-dependent result of that input.  It's meant to just fire the TAP event\n            const delayedClick = {\n              evt: evt,\n              clickInfo: clickInfo,\n              timeoutId: window.setTimeout(this._delayedSimpleClick.bind(this, btn, clickInfo, cb), InputManager.DoubleClickDelay)\n            };\n            this._delayedClicks[btn] = delayedClick;\n          }\n\n          let checkDoubleClick = obs1.hasSpecificMask(_pointerEvents.PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(_pointerEvents.PointerEventTypes.POINTERDOUBLETAP);\n\n          if (!checkDoubleClick && _abstractActionManager.AbstractActionManager.HasSpecificTrigger(6)) {\n            act = this._initActionManager(act, clickInfo);\n\n            if (act) {\n              checkDoubleClick = act.hasSpecificTrigger(6);\n            }\n          }\n\n          if (checkDoubleClick) {\n            // two successive keys pressed are equal, double click delay is not over and double click has not just occurred\n            if (btn === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < InputManager.DoubleClickDelay && !this._doubleClickOccured) {\n              // pointer has not moved for 2 clicks, it's a double click\n              if (!clickInfo.hasSwiped && !this._isPointerSwiping()) {\n                this._previousStartingPointerTime = 0;\n                this._doubleClickOccured = true;\n                clickInfo.doubleClick = true;\n                clickInfo.ignore = false; // If we have a pending click, we need to cancel it\n\n                if (InputManager.ExclusiveDoubleClickMode && this._delayedClicks[btn]) {\n                  clearTimeout((_a = this._delayedClicks[btn]) === null || _a === void 0 ? void 0 : _a.timeoutId);\n                  this._delayedClicks[btn] = null;\n                }\n\n                cb(clickInfo, this._currentPickResult);\n              } // if the two successive clicks are too far, it's just two simple clicks\n              else {\n                this._doubleClickOccured = false;\n                this._previousStartingPointerTime = this._startingPointerTime;\n                this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\n                this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\n                this._previousButtonPressed = btn;\n\n                if (InputManager.ExclusiveDoubleClickMode) {\n                  // If we have a delayed click, we need to cancel it\n                  if (this._delayedClicks[btn]) {\n                    clearTimeout((_b = this._delayedClicks[btn]) === null || _b === void 0 ? void 0 : _b.timeoutId);\n                    this._delayedClicks[btn] = null;\n                  }\n\n                  cb(clickInfo, this._previousPickResult);\n                } else {\n                  cb(clickInfo, this._currentPickResult);\n                }\n              }\n\n              needToIgnoreNext = true;\n            } // just the first click of the double has been raised\n            else {\n              this._doubleClickOccured = false;\n              this._previousStartingPointerTime = this._startingPointerTime;\n              this._previousStartingPointerPosition.x = this._startingPointerPosition.x;\n              this._previousStartingPointerPosition.y = this._startingPointerPosition.y;\n              this._previousButtonPressed = btn;\n            }\n          }\n        }\n      } // Even if ExclusiveDoubleClickMode is true, we need to always handle\n      // up events at time of execution, unless we're explicitly ignoring them.\n\n\n      if (!needToIgnoreNext) {\n        cb(clickInfo, this._currentPickResult);\n      }\n    };\n\n    this._onPointerMove = evt => {\n      this._updatePointerPosition(evt); // Check if pointer leaves DragMovementThreshold range to determine if swipe is occurring\n\n\n      if (!this._isSwiping && this._swipeButtonPressed !== -1) {\n        this._isSwiping = Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold;\n      } // Because there's a race condition between pointermove and pointerlockchange events, we need to\n      // verify that the pointer is still locked after each pointermove event.\n\n\n      if (engine.isPointerLock) {\n        engine._verifyPointerLock();\n      } // PreObservable support\n\n\n      if (this._checkPrePointerObservable(null, evt, evt.inputIndex >= _deviceEnums.PointerInput.MouseWheelX && evt.inputIndex <= _deviceEnums.PointerInput.MouseWheelZ ? _pointerEvents.PointerEventTypes.POINTERWHEEL : _pointerEvents.PointerEventTypes.POINTERMOVE)) {\n        return;\n      }\n\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n\n      if (scene.skipPointerMovePicking) {\n        this._processPointerMove(new _pickingInfo.PickingInfo(), evt);\n\n        return;\n      }\n\n      if (!scene.pointerMovePredicate) {\n        scene.pointerMovePredicate = mesh => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n      }\n\n      const pickResult = scene._registeredActions > 0 || scene.constantlyUpdateMeshUnderPointer ? this._pickMove(evt) : null;\n\n      this._processPointerMove(pickResult, evt);\n    };\n\n    this._onPointerDown = evt => {\n      var _a;\n\n      this._totalPointersPressed++;\n      this._pickedDownMesh = null;\n      this._meshPickProceed = false; // If ExclusiveDoubleClickMode is true, we need to resolve any pending delayed clicks\n\n      if (InputManager.ExclusiveDoubleClickMode) {\n        for (let i = 0; i < this._delayedClicks.length; i++) {\n          if (this._delayedClicks[i]) {\n            // If the button that was pressed is the same as the one that was released,\n            // just clear the timer.  This will be resolved in the up event.\n            if (evt.button === i) {\n              clearTimeout((_a = this._delayedClicks[i]) === null || _a === void 0 ? void 0 : _a.timeoutId);\n            } else {\n              // Otherwise, we need to resolve the click\n              const clickInfo = this._delayedClicks[i].clickInfo;\n              this._doubleClickOccured = false;\n              clickInfo.singleClick = true;\n              clickInfo.ignore = false;\n              const prevEvt = this._delayedClicks[i].evt;\n              const type = _pointerEvents.PointerEventTypes.POINTERTAP;\n              const pi = new _pointerEvents.PointerInfo(type, prevEvt, this._currentPickResult);\n\n              if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {\n                scene.onPointerObservable.notifyObservers(pi, type);\n              } // Clear the delayed click\n\n\n              this._delayedClicks[i] = null;\n            }\n          }\n        }\n      }\n\n      this._updatePointerPosition(evt);\n\n      if (this._swipeButtonPressed === -1) {\n        this._swipeButtonPressed = evt.button;\n      }\n\n      if (scene.preventDefaultOnPointerDown && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n\n      this._startingPointerPosition.x = this._pointerX;\n      this._startingPointerPosition.y = this._pointerY;\n      this._startingPointerTime = Date.now(); // PreObservable support\n\n      if (this._checkPrePointerObservable(null, evt, _pointerEvents.PointerEventTypes.POINTERDOWN)) {\n        return;\n      }\n\n      if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n        return;\n      }\n\n      this._pointerCaptures[evt.pointerId] = true;\n\n      if (!scene.pointerDownPredicate) {\n        scene.pointerDownPredicate = mesh => {\n          return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n        };\n      } // Meshes\n\n\n      this._pickedDownMesh = null;\n      let pickResult;\n\n      if (scene.skipPointerDownPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerDown) {\n        pickResult = new _pickingInfo.PickingInfo();\n      } else {\n        pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerDownPredicate, scene.pointerDownFastCheck, scene.cameraToUseForPointers);\n      }\n\n      this._processPointerDown(pickResult, evt);\n    };\n\n    this._onPointerUp = evt => {\n      if (this._totalPointersPressed === 0) {\n        // We are attaching the pointer up to windows because of a bug in FF\n        return; // So we need to test it the pointer down was pressed before.\n      }\n\n      this._totalPointersPressed--;\n      this._pickedUpMesh = null;\n      this._meshPickProceed = false;\n\n      this._updatePointerPosition(evt);\n\n      if (scene.preventDefaultOnPointerUp && elementToAttachTo) {\n        evt.preventDefault();\n        elementToAttachTo.focus();\n      }\n\n      this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, (clickInfo, pickResult) => {\n        // PreObservable support\n        if (scene.onPrePointerObservable.hasObservers()) {\n          this._skipPointerTap = false;\n\n          if (!clickInfo.ignore) {\n            if (this._checkPrePointerObservable(null, evt, _pointerEvents.PointerEventTypes.POINTERUP)) {\n              // If we're skipping the next observable, we need to reset the swipe state before returning\n              if (this._swipeButtonPressed === evt.button) {\n                this._isSwiping = false;\n                this._swipeButtonPressed = -1;\n              }\n\n              return;\n            }\n\n            if (!clickInfo.hasSwiped) {\n              if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(_pointerEvents.PointerEventTypes.POINTERTAP)) {\n                if (this._checkPrePointerObservable(null, evt, _pointerEvents.PointerEventTypes.POINTERTAP)) {\n                  this._skipPointerTap = true;\n                }\n              }\n\n              if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(_pointerEvents.PointerEventTypes.POINTERDOUBLETAP)) {\n                if (this._checkPrePointerObservable(null, evt, _pointerEvents.PointerEventTypes.POINTERDOUBLETAP)) {\n                  this._skipPointerTap = true;\n                }\n              }\n            }\n          }\n        } // There should be a pointer captured at this point so if there isn't we should reset and return\n\n\n        if (!this._pointerCaptures[evt.pointerId]) {\n          if (this._swipeButtonPressed === evt.button) {\n            this._isSwiping = false;\n            this._swipeButtonPressed = -1;\n          }\n\n          return;\n        } // Only release capture if all buttons are released\n\n\n        if (evt.buttons === 0) {\n          this._pointerCaptures[evt.pointerId] = false;\n        }\n\n        if (!scene.cameraToUseForPointers && !scene.activeCamera) {\n          return;\n        }\n\n        if (!scene.pointerUpPredicate) {\n          scene.pointerUpPredicate = mesh => {\n            return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);\n          };\n        } // Meshes\n\n\n        if (!this._meshPickProceed && (_abstractActionManager.AbstractActionManager && _abstractActionManager.AbstractActionManager.HasTriggers || this._checkForPicking() || scene.onPointerUp)) {\n          this._initActionManager(null, clickInfo);\n        }\n\n        if (!pickResult) {\n          pickResult = this._currentPickResult;\n        }\n\n        this._processPointerUp(pickResult, evt, clickInfo);\n\n        this._previousPickResult = this._currentPickResult;\n\n        if (this._swipeButtonPressed === evt.button) {\n          this._isSwiping = false;\n          this._swipeButtonPressed = -1;\n        }\n      });\n    };\n\n    this._onKeyDown = evt => {\n      const type = _keyboardEvents.KeyboardEventTypes.KEYDOWN;\n\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        const pi = new _keyboardEvents.KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n\n        if (pi.skipOnKeyboardObservable) {\n          return;\n        }\n      }\n\n      if (scene.onKeyboardObservable.hasObservers()) {\n        const pi = new _keyboardEvents.KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(14, _actionEvent.ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    };\n\n    this._onKeyUp = evt => {\n      const type = _keyboardEvents.KeyboardEventTypes.KEYUP;\n\n      if (scene.onPreKeyboardObservable.hasObservers()) {\n        const pi = new _keyboardEvents.KeyboardInfoPre(type, evt);\n        scene.onPreKeyboardObservable.notifyObservers(pi, type);\n\n        if (pi.skipOnKeyboardObservable) {\n          return;\n        }\n      }\n\n      if (scene.onKeyboardObservable.hasObservers()) {\n        const pi = new _keyboardEvents.KeyboardInfo(type, evt);\n        scene.onKeyboardObservable.notifyObservers(pi, type);\n      }\n\n      if (scene.actionManager) {\n        scene.actionManager.processTrigger(15, _actionEvent.ActionEvent.CreateNewFromScene(scene, evt));\n      }\n    }; // If a device connects that we can handle, wire up the observable\n\n\n    this._deviceSourceManager.onDeviceConnectedObservable.add(deviceSource => {\n      if (deviceSource.deviceType === _deviceEnums.DeviceType.Mouse) {\n        deviceSource.onInputChangedObservable.add(eventData => {\n          if (eventData.inputIndex === _deviceEnums.PointerInput.LeftClick || eventData.inputIndex === _deviceEnums.PointerInput.MiddleClick || eventData.inputIndex === _deviceEnums.PointerInput.RightClick || eventData.inputIndex === _deviceEnums.PointerInput.BrowserBack || eventData.inputIndex === _deviceEnums.PointerInput.BrowserForward) {\n            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\n              this._onPointerDown(eventData);\n            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\n              this._onPointerUp(eventData);\n            }\n          } else if (attachMove) {\n            if (eventData.inputIndex === _deviceEnums.PointerInput.Move) {\n              this._onPointerMove(eventData);\n            } else if (eventData.inputIndex === _deviceEnums.PointerInput.MouseWheelX || eventData.inputIndex === _deviceEnums.PointerInput.MouseWheelY || eventData.inputIndex === _deviceEnums.PointerInput.MouseWheelZ) {\n              this._onPointerMove(eventData);\n            }\n          }\n        });\n      } else if (deviceSource.deviceType === _deviceEnums.DeviceType.Touch) {\n        deviceSource.onInputChangedObservable.add(eventData => {\n          if (eventData.inputIndex === _deviceEnums.PointerInput.LeftClick) {\n            if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {\n              this._onPointerDown(eventData);\n\n              if (this._totalPointersPressed > 1) {\n                this._isMultiTouchGesture = true;\n              }\n            } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {\n              this._onPointerUp(eventData);\n\n              if (this._totalPointersPressed === 0) {\n                this._isMultiTouchGesture = false;\n              }\n            }\n          }\n\n          if (attachMove && eventData.inputIndex === _deviceEnums.PointerInput.Move) {\n            this._onPointerMove(eventData);\n          }\n        });\n      } else if (deviceSource.deviceType === _deviceEnums.DeviceType.Keyboard) {\n        deviceSource.onInputChangedObservable.add(eventData => {\n          if (eventData.type === \"keydown\") {\n            this._onKeyDown(eventData);\n          } else if (eventData.type === \"keyup\") {\n            this._onKeyUp(eventData);\n          }\n        });\n      }\n    });\n\n    this._alreadyAttached = true;\n  }\n  /**\n   * Detaches all event handlers\n   */\n\n\n  detachControl() {\n    if (this._alreadyAttached) {\n      this._deviceSourceManager.dispose();\n\n      this._deviceSourceManager = null; // Cursor\n\n      if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {\n        this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;\n      }\n\n      this._alreadyAttached = false;\n      this._alreadyAttachedTo = null;\n    }\n  }\n  /**\n   * Force the value of meshUnderPointer\n   * @param mesh - defines the mesh to use\n   * @param pointerId - optional pointer id when using more than one pointer. Defaults to 0\n   * @param pickResult - optional pickingInfo data used to find mesh\n   * @param evt - optional pointer event\n   */\n\n\n  setPointerOverMesh(mesh, pointerId = 0, pickResult, evt) {\n    if (this._meshUnderPointerId[pointerId] === mesh && (!mesh || !mesh._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting)) {\n      return;\n    }\n\n    const underPointerMesh = this._meshUnderPointerId[pointerId];\n    let actionManager;\n\n    if (underPointerMesh) {\n      actionManager = underPointerMesh._getActionManagerForTrigger(10);\n\n      if (actionManager) {\n        actionManager.processTrigger(10, _actionEvent.ActionEvent.CreateNew(underPointerMesh, evt, {\n          pointerId\n        }));\n      }\n    }\n\n    if (mesh) {\n      this._meshUnderPointerId[pointerId] = mesh;\n      this._pointerOverMesh = mesh;\n      actionManager = mesh._getActionManagerForTrigger(9);\n\n      if (actionManager) {\n        actionManager.processTrigger(9, _actionEvent.ActionEvent.CreateNew(mesh, evt, {\n          pointerId,\n          pickResult\n        }));\n      }\n    } else {\n      delete this._meshUnderPointerId[pointerId];\n      this._pointerOverMesh = null;\n    }\n  }\n  /**\n   * Gets the mesh under the pointer\n   * @returns a Mesh or null if no mesh is under the pointer\n   */\n\n\n  getPointerOverMesh() {\n    return this.meshUnderPointer;\n  }\n  /**\n   * @param mesh - Mesh to invalidate\n   * @internal\n   */\n\n\n  _invalidateMesh(mesh) {\n    if (this._pointerOverMesh === mesh) {\n      this._pointerOverMesh = null;\n    }\n\n    if (this._pickedDownMesh === mesh) {\n      this._pickedDownMesh = null;\n    }\n\n    if (this._pickedUpMesh === mesh) {\n      this._pickedUpMesh = null;\n    }\n\n    for (const pointerId in this._meshUnderPointerId) {\n      if (this._meshUnderPointerId[pointerId] === mesh) {\n        delete this._meshUnderPointerId[pointerId];\n      }\n    }\n  }\n\n}\n/** The distance in pixel that you have to move to prevent some events */\n\n\nexports.InputManager = InputManager;\nInputManager.DragMovementThreshold = 10; // in pixels\n\n/** Time in milliseconds to wait to raise long press events if button is still pressed */\n\nInputManager.LongPressDelay = 500; // in milliseconds\n\n/** Time in milliseconds with two consecutive clicks will be considered as a double click */\n\nInputManager.DoubleClickDelay = 300; // in milliseconds\n\n/**\n * This flag will modify the behavior so that, when true, a click will happen if and only if\n * another click DOES NOT happen within the DoubleClickDelay time frame.  If another click does\n * happen within that time frame, the first click will not fire an event and and a double click will occur.\n */\n\nInputManager.ExclusiveDoubleClickMode = false;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","InputManager","_pointerEvents","_abstractActionManager","_pickingInfo","_mathVector","_actionEvent","_keyboardEvents","_deviceEnums","_deviceSourceManager","_engineStore","_ClickInfo","constructor","_ignore","_hasSwiped","_doubleClick","_singleClick","b","scene","_meshPickProceed","_alreadyAttached","_previousPickResult","_currentPickResult","_totalPointersPressed","_isSwiping","_doubleClickOccured","_swipeButtonPressed","_isMultiTouchGesture","_skipPointerTap","_pointerY","_pointerX","_startingPointerPosition","Vector2","_previousStartingPointerPosition","_previousStartingPointerTime","_startingPointerTime","_pointerCaptures","_meshUnderPointerId","_movePointerInfo","_cameraObserverCount","_delayedClicks","_scene","EngineStore","LastCreatedScene","_generatePickInfo","_pointerOverMesh","getMeshUnderPointerByPointerId","pointerId","_unTranslatedPointerX","_unTranslatedPointerY","_updatePointerPosition","evt","canvasRect","getEngine","getInputElementClientRect","clientX","left","clientY","top","_processPointerMove","pickResult","engine","canvas","getInputElement","tabIndex","canvasTabIndex","doNotHandleCursors","style","cursor","defaultCursor","_setCursorAndPointerOverMesh","step","_pointerMoveStage","_pickMove","action","isMeshPicked","pickedMesh","type","inputIndex","PointerInput","MouseWheelX","MouseWheelZ","PointerEventTypes","POINTERWHEEL","POINTERMOVE","onPointerMove","pointerInfo","PointerInfo","_setRayOnPointerInfo","onPointerObservable","hasObservers","notifyObservers","pickInfo","event","_pickingAvailable","ray","createPickingRay","offsetX","offsetY","Matrix","Identity","activeCamera","_addCameraPointerObserver","observer","mask","add","_removeCameraPointerObserver","remove","_checkForPicking","observers","length","onPointerPick","_checkPrePointerObservable","pi","PointerInfoPre","originalPickingInfo","originMesh","nearInteractionPickingInfo","onPrePointerObservable","skipOnPointerObservable","pick","pointerMovePredicate","pointerMoveFastCheck","cameraToUseForPointers","pointerMoveTrianglePredicate","setPointerOverMesh","actionManager","_getActionManagerForTrigger","hasPointerTriggers","hoverCursor","simulatePointerMove","pointerEventInit","PointerEvent","Move","simulatePointerDown","button","POINTERDOWN","_processPointerDown","_pickedDownMesh","hasPickTriggers","processTrigger","ActionEvent","CreateNew","hasSpecificTrigger","window","setTimeout","mesh","isPickable","isVisible","isReady","Date","now","LongPressDelay","_isPointerSwiping","_pointerDownStage","onPointerDown","simulatePointerUp","doubleTap","clickInfo","doubleClick","singleClick","POINTERUP","_processPointerUp","_pickedUpMesh","ignore","POINTERPICK","hasSwiped","doubleClickActionManager","_pointerUpStage","pickedDownActionManager","onPointerUp","POINTERTAP","POINTERDOUBLETAP","hasSpecificMask","isPointerCaptured","attachControl","attachUp","attachDown","attachMove","elementToAttachTo","detachControl","_alreadyAttachedTo","DeviceSourceManager","_initActionManager","act","this._initActionManager","skipPointerUpPicking","_registeredActions","pointerUpPredicate","pointerUpFastCheck","hit","_delayedSimpleClick","btn","cb","this._delayedSimpleClick","DoubleClickDelay","_previousButtonPressed","_initClickEvent","obs1","obs2","this._initClickEvent","_a","_b","checkPicking","AbstractActionManager","needToIgnoreNext","checkSingleClickImmediately","ExclusiveDoubleClickMode","HasSpecificTrigger","delayedClick","timeoutId","bind","checkDoubleClick","x","y","clearTimeout","_onPointerMove","this._onPointerMove","Math","abs","DragMovementThreshold","isPointerLock","_verifyPointerLock","skipPointerMovePicking","PickingInfo","scene.pointerMovePredicate","isEnabled","enablePointerMoveEvents","constantlyUpdateMeshUnderPointer","layerMask","_onPointerDown","this._onPointerDown","i","preventDefaultOnPointerDown","preventDefault","focus","pointerDownPredicate","scene.pointerDownPredicate","skipPointerDownPicking","pointerDownFastCheck","_onPointerUp","this._onPointerUp","preventDefaultOnPointerUp","buttons","scene.pointerUpPredicate","HasTriggers","_onKeyDown","this._onKeyDown","KeyboardEventTypes","KEYDOWN","onPreKeyboardObservable","KeyboardInfoPre","skipOnKeyboardObservable","onKeyboardObservable","KeyboardInfo","CreateNewFromScene","_onKeyUp","this._onKeyUp","KEYUP","onDeviceConnectedObservable","deviceSource","deviceType","DeviceType","Mouse","onInputChangedObservable","eventData","LeftClick","MiddleClick","RightClick","BrowserBack","BrowserForward","getInput","MouseWheelY","Touch","Keyboard","dispose","_internalAbstractMeshDataInfo","_pointerOverDisableMeshTesting","underPointerMesh","getPointerOverMesh","meshUnderPointer","_invalidateMesh"]
}
