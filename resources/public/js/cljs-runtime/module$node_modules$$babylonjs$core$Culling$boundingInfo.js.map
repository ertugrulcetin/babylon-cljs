{
"version":3,
"file":"module$node_modules$$babylonjs$core$Culling$boundingInfo.js",
"lineCount":11,
"mappings":"AAAAA,cAAA,CAAA,wDAAA,CAA6E,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CAGrHC,MAAOC,CAAAA,cAAP,CAAsBF,OAAtB,CAA+B,YAA/B,CAA6C,CAC3CG,MAAO,CAAA,CADoC,CAA7C,CAGAH,QAAQI,CAAAA,YAAR,CAAuB,IAAK,EAExBC,OAAAA,CAAcP,OAAA,CAAQ,qDAAR,CAElB,KAAIQ,YAAcR,OAAA,CAAQ,uDAAR,CAAlB,CAEIS,aAAeT,OAAA,CAAQ,yDAAR,CAFnB,CAIIU,gBAAkBV,OAAA,CAAQ,4DAAR,CAEtB;MAAMW,SAAW,CACfC,IAAK,CADU,CAEfC,IAAK,CAFU,CAAjB,CAIMC,SAAW,CACfF,IAAK,CADU,CAEfC,IAAK,CAFU,CAJjB,CASME,kBAAoB,CAACC,IAAD,CAAOC,GAAP,CAAYC,MAAZ,CAAAH,EAAuB,CAC/C,MAAMI,EAAIX,WAAYY,CAAAA,OAAQC,CAAAA,GAApB,CAAwBJ,GAAIK,CAAAA,WAA5B,CAAyCN,IAAzC,CAEV,KAAMO,GAAKC,IAAKC,CAAAA,GAAL,CAASjB,WAAYY,CAAAA,OAAQC,CAAAA,GAApB,CAAwBJ,GAAIS,CAAAA,UAAJ,CAAe,CAAf,CAAxB,CAA2CV,IAA3C,CAAT,CAALO,CAAkEN,GAAIU,CAAAA,UAAWC,CAAAA,CACvF,OAAMC,GAAKL,IAAKC,CAAAA,GAAL,CAASjB,WAAYY,CAAAA,OAAQC,CAAAA,GAApB,CAAwBJ,GAAIS,CAAAA,UAAJ,CAAe,CAAf,CAAxB,CAA2CV,IAA3C,CAAT,CAALa,CAAkEZ,GAAIU,CAAAA,UAAWG,CAAAA,CACjFC,KAAAA,CAAKP,IAAKC,CAAAA,GAAL,CAASjB,WAAYY,CAAAA,OAAQC,CAAAA,GAApB,CAAwBJ,GAAIS,CAAAA,UAAJ,CAAe,CAAf,CAAxB,CAA2CV,IAA3C,CAAT,CAALe,CAAkEd,GAAIU,CAAAA,UAAWK,CAAAA,CACjFC,GAAAA,CAAIV,EAAJU,CAASJ,EAATI,CAAcF,IACpBb,OAAON,CAAAA,GAAP,CAAaO,CAAb,CAAiBc,EACjBf,OAAOL,CAAAA,GAAP,CAAaM,CAAb,CAAiBc,EAR8B,CATjD,CAoBMC,YAAc,CAAClB,IAAD,CAAOmB,IAAP,CAAaC,IAAb,CAAAF,EAAsB,CACxCnB,iBAAA,CAAkBC,IAAlB,CAAwBmB,IAAxB,CAA8BxB,QAA9B,CACAI;iBAAA,CAAkBC,IAAlB,CAAwBoB,IAAxB,CAA8BtB,QAA9B,CACA,OAAO,EAAEH,QAASC,CAAAA,GAAX,CAAiBE,QAASD,CAAAA,GAA1B,EAAiCC,QAASF,CAAAA,GAA1C,CAAgDD,QAASE,CAAAA,GAAzD,CAHiC,CAU1C,MAAMP,aAAN,CAOE+B,WAAW,CAACC,OAAD,CAAUC,OAAV,CAAmBC,WAAnB,CAAgC,CACzC,IAAKC,CAAAA,SAAL,CAAiB,CAAA,CACjB,KAAKC,CAAAA,WAAL,CAAmB,IAAIjC,YAAakC,CAAAA,WAAjB,CAA6BL,OAA7B,CAAsCC,OAAtC,CAA+CC,WAA/C,CACnB,KAAKI,CAAAA,cAAL,CAAsB,IAAIlC,eAAgBmC,CAAAA,cAApB,CAAmCP,OAAnC,CAA4CC,OAA5C,CAAqDC,WAArD,CAHmB,CAa3CM,WAAW,CAAClC,GAAD,CAAMC,GAAN,CAAW2B,WAAX,CAAwB,CACjC,IAAKE,CAAAA,WAAYI,CAAAA,WAAjB,CAA6BlC,GAA7B,CAAkCC,GAAlC,CAAuC2B,WAAvC,CACA,KAAKI,CAAAA,cAAeE,CAAAA,WAApB,CAAgClC,GAAhC,CAAqCC,GAArC,CAA0C2B,WAA1C,CAFiC,CAS/B,WAAU,EAAA,CACZ,MAAO,KAAKE,CAAAA,WAAYJ,CAAAA,OADZ,CAQV,WAAU,EAAA,CACZ,MAAO,KAAKI,CAAAA,WAAYH,CAAAA,OADZ,CAQV,YAAW,EAAA,CACb,MAAO,KAAKE,CAAAA,SADC,CAIX,YAAQ,CAACpC,KAAD,CAAQ,CAClB,IAAKoC,CAAAA,SAAL;AAAiBpC,KADC,CAUpB0C,MAAM,CAACC,KAAD,CAAQ,CACR,IAAKP,CAAAA,SAAT,GAIA,IAAKC,CAAAA,WAAYO,CAAAA,OAAjB,CAAyBD,KAAzB,CAEA,CAAA,IAAKJ,CAAAA,cAAeK,CAAAA,OAApB,CAA4BD,KAA5B,CANA,CADY,CAiBdE,QAAQ,CAACC,MAAD,CAASC,MAAT,CAAiB,CACvB,MAAMd,QAAUhC,YAAa+C,CAAAA,WAAb,CAAyB,CAAzB,CAA4BC,CAAAA,QAA5B,CAAqCH,MAArC,CAA6CI,CAAAA,eAA7C,CAA6DH,MAA7D,CAEVb,OAAAA,CAAUjC,YAAa+C,CAAAA,WAAb,CAAyB,CAAzB,CAA4BC,CAAAA,QAA5B,CAAqCH,MAArC,CAA6CK,CAAAA,UAA7C,CAAwDJ,MAAxD,CAEhB,KAAKV,CAAAA,WAAYI,CAAAA,WAAjB,CAA6BR,OAA7B,CAAsCC,MAAtC,CAA+C,IAAKG,CAAAA,WAAYe,CAAAA,cAAjB,EAA/C,CACA,KAAKb,CAAAA,cAAeE,CAAAA,WAApB,CAAgCR,OAAhC,CAAyCC,MAAzC,CAAkD,IAAKG,CAAAA,WAAYe,CAAAA,cAAjB,EAAlD,CACA,OAAO,KAPgB,CAgBzBC,WAAW,CAACC,KAAD,CAAQ,CACjB,MAAMrB,QAAU9B,WAAYY,CAAAA,OAAQwC,CAAAA,QAApB,CAA6B,IAAKtB,CAAAA,OAAlC;AAA2CqB,KAA3C,CAEVpB,MAAAA,CAAU/B,WAAYY,CAAAA,OAAQyC,CAAAA,QAApB,CAA6B,IAAKtB,CAAAA,OAAlC,CAA2CoB,KAA3C,CAEhB,KAAKb,CAAAA,WAAL,CAAiBR,OAAjB,CAA0BC,KAA1B,CAAmC,IAAKG,CAAAA,WAAYe,CAAAA,cAAjB,EAAnC,CACA,OAAO,KANU,CAenBK,uBAAuB,CAACC,aAAD,CAAgB,CACrC,MAAMC,KAAOxD,WAAYyD,CAAAA,UAAWC,CAAAA,MAAvB,CAA8B,CAA9B,CACb,KAAKxB,CAAAA,WAAYe,CAAAA,cAAjB,EAAkCU,CAAAA,WAAlC,CAA8CH,IAA9C,CACA,OAAMI,EAAI5D,WAAYyD,CAAAA,UAAW7C,CAAAA,OAAvB,CAA+B,CAA/B,CAEVZ,YAAYY,CAAAA,OAAQiD,CAAAA,yBAApB,CAA8CN,aAAcrB,CAAAA,WAAY4B,CAAAA,YAAxE,CAAsFN,IAAtF,CAA4FI,CAA5F,CAEA,KAAKV,CAAAA,WAAL,CAAiBU,CAAjB,CAEA5D,YAAYY,CAAAA,OAAQiD,CAAAA,yBAApB,CAA8CN,aAAcrB,CAAAA,WAAY6B,CAAAA,YAAxE;AAAsFP,IAAtF,CAA4FI,CAA5F,CAEA,KAAKV,CAAAA,WAAL,CAAiBU,CAAjB,CACA,OAAO,KAZ8B,CAqBvCI,KAAK,CAACC,MAAD,CAAS,CACZ,IAAK/B,CAAAA,WAAY8B,CAAAA,KAAjB,CAAuBC,MAAvB,CACA,KAAK7B,CAAAA,cAAe4B,CAAAA,KAApB,CAA0BC,MAA1B,CACA,OAAO,KAHK,CAkBdC,WAAW,CAACC,aAAD,CAAgBC,QAAA,CAAW,CAA3B,CAA8B,CAGvC,MAFmC,EAEnC,GAFsBA,QAEtB,EAFqD,CAErD,GAFwCA,QAExC,EACM,CAAA,IAAKhC,CAAAA,cAAeiC,CAAAA,iBAApB,CAAsCF,aAAtC,CADN,CAMK,IAAK/B,CAAAA,cAAe8B,CAAAA,WAApB,CAAgCC,aAAhC,CAAL,CAIqC,CAErC,GAFwBC,QAExB,EAFuD,CAEvD,GAF0CA,QAE1C,CACS,CAAA,CADT,CAIO,IAAKlC,CAAAA,WAAYgC,CAAAA,WAAjB,CAA6BC,aAA7B,CAVP,CACS,CAAA,CAPT,CAEW,CAAA,CAL4B,CA0BrC,kBAAiB,EAAA,CACnB,MAAMjC,YAAc,IAAKA,CAAAA,WAEzB,OADaA,YAAY6B,CAAAA,YAAaO,CAAAA,aAAzBC,CAAuCrC,WAAY4B,CAAAA,YAAnDS;AAAiEzE,YAAa+C,CAAAA,WAAb,CAAyB,CAAzB,CAAjE0B,CACDC,CAAAA,MAAL,EAHY,CAarBC,qBAAqB,CAACN,aAAD,CAAgB,CACnC,MAAO,KAAKjC,CAAAA,WAAYuC,CAAAA,qBAAjB,CAAuCN,aAAvC,CAD4B,CAQrCO,eAAe,CAACC,QAAD,CAAW,CACxB,MAAOA,SAASC,CAAAA,eAAT,CAAyB,IAAKxC,CAAAA,cAAetB,CAAAA,WAA7C,CAA0D,IAAKsB,CAAAA,cAAeyC,CAAAA,WAA9E,CAA2F,IAAK3C,CAAAA,WAAY4B,CAAAA,YAA5G,CAA0H,IAAK5B,CAAAA,WAAY6B,CAAAA,YAA3I,CADiB,CAW1Be,eAAe,CAAC3B,KAAD,CAAQ,CASrB,MARK,KAAKf,CAAAA,cAAetB,CAAAA,WAQzB,EAJK,IAAKsB,CAAAA,cAAe0C,CAAAA,eAApB,CAAoC3B,KAApC,CAIL,EAAK,IAAKjB,CAAAA,WAAY4C,CAAAA,eAAjB,CAAiC3B,KAAjC,CAAL,CAIO,CAAA,CAJP,CACS,CAAA,CAVY,CAwBvB4B,UAAU,CAACC,YAAD,CAAeC,OAAf,CAAwB,CAKhC,GAJI,CAAC/E,eAAgBmC,CAAAA,cAAe6C,CAAAA,UAA/B,CAA0C,IAAK9C,CAAAA,cAA/C;AAA+D4C,YAAa5C,CAAAA,cAA5E,CAIL,EAAI,CAACnC,YAAakC,CAAAA,WAAY+C,CAAAA,UAAzB,CAAoC,IAAKhD,CAAAA,WAAzC,CAAsD8C,YAAa9C,CAAAA,WAAnE,CAAL,CACE,MAAO,CAAA,CAGT,IAAI,CAAC+C,OAAL,CACE,MAAO,CAAA,CAGHtD,QAAAA,CAAO,IAAKO,CAAAA,WACZN,aAAAA,CAAOoD,YAAa9C,CAAAA,WA0D1B,OAxDKR,YAAA,CAAYC,OAAKT,CAAAA,UAAL,CAAgB,CAAhB,CAAZ,CAAgCS,OAAhC,CAAsCC,YAAtC,CAwDL,EApDKF,WAAA,CAAYC,OAAKT,CAAAA,UAAL,CAAgB,CAAhB,CAAZ,CAAgCS,OAAhC,CAAsCC,YAAtC,CAoDL,EAhDKF,WAAA,CAAYC,OAAKT,CAAAA,UAAL,CAAgB,CAAhB,CAAZ,CAAgCS,OAAhC,CAAsCC,YAAtC,CAgDL,EA5CKF,WAAA,CAAYE,YAAKV,CAAAA,UAAL,CAAgB,CAAhB,CAAZ,CAAgCS,OAAhC,CAAsCC,YAAtC,CA4CL,EAxCKF,WAAA,CAAYE,YAAKV,CAAAA,UAAL,CAAgB,CAAhB,CAAZ,CAAgCS,OAAhC,CAAsCC,YAAtC,CAwCL;AApCKF,WAAA,CAAYE,YAAKV,CAAAA,UAAL,CAAgB,CAAhB,CAAZ,CAAgCS,OAAhC,CAAsCC,YAAtC,CAoCL,EAhCKF,WAAA,CAAY1B,WAAYY,CAAAA,OAAQuE,CAAAA,KAApB,CAA0BxD,OAAKT,CAAAA,UAAL,CAAgB,CAAhB,CAA1B,CAA8CU,YAAKV,CAAAA,UAAL,CAAgB,CAAhB,CAA9C,CAAZ,CAA+ES,OAA/E,CAAqFC,YAArF,CAgCL,EA5BKF,WAAA,CAAY1B,WAAYY,CAAAA,OAAQuE,CAAAA,KAApB,CAA0BxD,OAAKT,CAAAA,UAAL,CAAgB,CAAhB,CAA1B,CAA8CU,YAAKV,CAAAA,UAAL,CAAgB,CAAhB,CAA9C,CAAZ,CAA+ES,OAA/E,CAAqFC,YAArF,CA4BL,EAxBKF,WAAA,CAAY1B,WAAYY,CAAAA,OAAQuE,CAAAA,KAApB,CAA0BxD,OAAKT,CAAAA,UAAL,CAAgB,CAAhB,CAA1B,CAA8CU,YAAKV,CAAAA,UAAL,CAAgB,CAAhB,CAA9C,CAAZ,CAA+ES,OAA/E,CAAqFC,YAArF,CAwBL,EApBKF,WAAA,CAAY1B,WAAYY,CAAAA,OAAQuE,CAAAA,KAApB,CAA0BxD,OAAKT,CAAAA,UAAL,CAAgB,CAAhB,CAA1B,CAA8CU,YAAKV,CAAAA,UAAL,CAAgB,CAAhB,CAA9C,CAAZ,CAA+ES,OAA/E,CAAqFC,YAArF,CAoBL;AAhBKF,WAAA,CAAY1B,WAAYY,CAAAA,OAAQuE,CAAAA,KAApB,CAA0BxD,OAAKT,CAAAA,UAAL,CAAgB,CAAhB,CAA1B,CAA8CU,YAAKV,CAAAA,UAAL,CAAgB,CAAhB,CAA9C,CAAZ,CAA+ES,OAA/E,CAAqFC,YAArF,CAgBL,EAZKF,WAAA,CAAY1B,WAAYY,CAAAA,OAAQuE,CAAAA,KAApB,CAA0BxD,OAAKT,CAAAA,UAAL,CAAgB,CAAhB,CAA1B,CAA8CU,YAAKV,CAAAA,UAAL,CAAgB,CAAhB,CAA9C,CAAZ,CAA+ES,OAA/E,CAAqFC,YAArF,CAYL,EARKF,WAAA,CAAY1B,WAAYY,CAAAA,OAAQuE,CAAAA,KAApB,CAA0BxD,OAAKT,CAAAA,UAAL,CAAgB,CAAhB,CAA1B,CAA8CU,YAAKV,CAAAA,UAAL,CAAgB,CAAhB,CAA9C,CAAZ,CAA+ES,OAA/E,CAAqFC,YAArF,CAQL,EAJKF,WAAA,CAAY1B,WAAYY,CAAAA,OAAQuE,CAAAA,KAApB,CAA0BxD,OAAKT,CAAAA,UAAL,CAAgB,CAAhB,CAA1B,CAA8CU,YAAKV,CAAAA,UAAL,CAAgB,CAAhB,CAA9C,CAAZ,CAA+ES,OAA/E,CAAqFC,YAArF,CAIL,EAAKF,WAAA,CAAY1B,WAAYY,CAAAA,OAAQuE,CAAAA,KAApB,CAA0BxD,OAAKT,CAAAA,UAAL,CAAgB,CAAhB,CAA1B;AAA8CU,YAAKV,CAAAA,UAAL,CAAgB,CAAhB,CAA9C,CAAZ,CAA+ES,OAA/E,CAAqFC,YAArF,CAAL,CAIO,CAAA,CAJP,CACS,CAAA,CAzEuB,CApOpC,CAqTAlC,OAAQI,CAAAA,YAAR,CAAuBA,YACvBA,aAAa+C,CAAAA,WAAb,CAA2B9C,MAAYqF,CAAAA,UAAWC,CAAAA,UAAvB,CAAkC,CAAlC,CAAqCrF,WAAYY,CAAAA,OAAQ0E,CAAAA,IAAzD,CApW0F;",
"sources":["node_modules/@babylonjs/core/Culling/boundingInfo.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$babylonjs$core$Culling$boundingInfo\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BoundingInfo = void 0;\n\nvar _arrayTools = require(\"../Misc/arrayTools.js\");\n\nvar _mathVector = require(\"../Maths/math.vector.js\");\n\nvar _boundingBox = require(\"./boundingBox.js\");\n\nvar _boundingSphere = require(\"./boundingSphere.js\");\n\nconst _result0 = {\n  min: 0,\n  max: 0\n};\nconst _result1 = {\n  min: 0,\n  max: 0\n};\n\nconst computeBoxExtents = (axis, box, result) => {\n  const p = _mathVector.Vector3.Dot(box.centerWorld, axis);\n\n  const r0 = Math.abs(_mathVector.Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;\n  const r1 = Math.abs(_mathVector.Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;\n  const r2 = Math.abs(_mathVector.Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;\n  const r = r0 + r1 + r2;\n  result.min = p - r;\n  result.max = p + r;\n};\n\nconst axisOverlap = (axis, box0, box1) => {\n  computeBoxExtents(axis, box0, _result0);\n  computeBoxExtents(axis, box1, _result1);\n  return !(_result0.min > _result1.max || _result1.min > _result0.max);\n};\n/**\n * Info for a bounding data of a mesh\n */\n\n\nclass BoundingInfo {\n  /**\n   * Constructs bounding info\n   * @param minimum min vector of the bounding box/sphere\n   * @param maximum max vector of the bounding box/sphere\n   * @param worldMatrix defines the new world matrix\n   */\n  constructor(minimum, maximum, worldMatrix) {\n    this._isLocked = false;\n    this.boundingBox = new _boundingBox.BoundingBox(minimum, maximum, worldMatrix);\n    this.boundingSphere = new _boundingSphere.BoundingSphere(minimum, maximum, worldMatrix);\n  }\n  /**\n   * Recreates the entire bounding info from scratch as if we call the constructor in place\n   * @param min defines the new minimum vector (in local space)\n   * @param max defines the new maximum vector (in local space)\n   * @param worldMatrix defines the new world matrix\n   */\n\n\n  reConstruct(min, max, worldMatrix) {\n    this.boundingBox.reConstruct(min, max, worldMatrix);\n    this.boundingSphere.reConstruct(min, max, worldMatrix);\n  }\n  /**\n   * min vector of the bounding box/sphere\n   */\n\n\n  get minimum() {\n    return this.boundingBox.minimum;\n  }\n  /**\n   * max vector of the bounding box/sphere\n   */\n\n\n  get maximum() {\n    return this.boundingBox.maximum;\n  }\n  /**\n   * If the info is locked and won't be updated to avoid perf overhead\n   */\n\n\n  get isLocked() {\n    return this._isLocked;\n  }\n\n  set isLocked(value) {\n    this._isLocked = value;\n  } // Methods\n\n  /**\n   * Updates the bounding sphere and box\n   * @param world world matrix to be used to update\n   */\n\n\n  update(world) {\n    if (this._isLocked) {\n      return;\n    }\n\n    this.boundingBox._update(world);\n\n    this.boundingSphere._update(world);\n  }\n  /**\n   * Recreate the bounding info to be centered around a specific point given a specific extend.\n   * @param center New center of the bounding info\n   * @param extend New extend of the bounding info\n   * @returns the current bounding info\n   */\n\n\n  centerOn(center, extend) {\n    const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);\n\n    const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);\n\n    this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    return this;\n  }\n  /**\n   * Grows the bounding info to include the given point.\n   * @param point The point that will be included in the current bounding info (in local space)\n   * @returns the current bounding info\n   */\n\n\n  encapsulate(point) {\n    const minimum = _mathVector.Vector3.Minimize(this.minimum, point);\n\n    const maximum = _mathVector.Vector3.Maximize(this.maximum, point);\n\n    this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());\n    return this;\n  }\n  /**\n   * Grows the bounding info to encapsulate the given bounding info.\n   * @param toEncapsulate The bounding info that will be encapsulated in the current bounding info\n   * @returns the current bounding info\n   */\n\n\n  encapsulateBoundingInfo(toEncapsulate) {\n    const invw = _mathVector.TmpVectors.Matrix[0];\n    this.boundingBox.getWorldMatrix().invertToRef(invw);\n    const v = _mathVector.TmpVectors.Vector3[0];\n\n    _mathVector.Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.minimumWorld, invw, v);\n\n    this.encapsulate(v);\n\n    _mathVector.Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.maximumWorld, invw, v);\n\n    this.encapsulate(v);\n    return this;\n  }\n  /**\n   * Scale the current bounding info by applying a scale factor\n   * @param factor defines the scale factor to apply\n   * @returns the current bounding info\n   */\n\n\n  scale(factor) {\n    this.boundingBox.scale(factor);\n    this.boundingSphere.scale(factor);\n    return this;\n  }\n  /**\n   * Returns `true` if the bounding info is within the frustum defined by the passed array of planes.\n   * @param frustumPlanes defines the frustum to test\n   * @param strategy defines the strategy to use for the culling (default is BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD)\n   * The different strategies available are:\n   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_STANDARD most accurate but slower @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_STANDARD\n   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY faster but less accurate @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY\n   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION\n   * * BABYLON.AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY can be faster if always visible @see https://doc.babylonjs.com/typedoc/classes/BABYLON.AbstractMesh#CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY\n   * @returns true if the bounding info is in the frustum planes\n   */\n\n\n  isInFrustum(frustumPlanes, strategy = 0) {\n    const inclusionTest = strategy === 2 || strategy === 3;\n\n    if (inclusionTest) {\n      if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {\n        return true;\n      }\n    }\n\n    if (!this.boundingSphere.isInFrustum(frustumPlanes)) {\n      return false;\n    }\n\n    const bSphereOnlyTest = strategy === 1 || strategy === 3;\n\n    if (bSphereOnlyTest) {\n      return true;\n    }\n\n    return this.boundingBox.isInFrustum(frustumPlanes);\n  }\n  /**\n   * Gets the world distance between the min and max points of the bounding box\n   */\n\n\n  get diagonalLength() {\n    const boundingBox = this.boundingBox;\n    const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);\n    return diag.length();\n  }\n  /**\n   * Checks if a cullable object (mesh...) is in the camera frustum\n   * Unlike isInFrustum this checks the full bounding box\n   * @param frustumPlanes Camera near/planes\n   * @returns true if the object is in frustum otherwise false\n   */\n\n\n  isCompletelyInFrustum(frustumPlanes) {\n    return this.boundingBox.isCompletelyInFrustum(frustumPlanes);\n  }\n  /**\n   * @internal\n   */\n\n\n  _checkCollision(collider) {\n    return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);\n  }\n  /**\n   * Checks if a point is inside the bounding box and bounding sphere or the mesh\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\n   * @param point the point to check intersection with\n   * @returns if the point intersects\n   */\n\n\n  intersectsPoint(point) {\n    if (!this.boundingSphere.centerWorld) {\n      return false;\n    }\n\n    if (!this.boundingSphere.intersectsPoint(point)) {\n      return false;\n    }\n\n    if (!this.boundingBox.intersectsPoint(point)) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Checks if another bounding info intersects the bounding box and bounding sphere or the mesh\n   * @see https://doc.babylonjs.com/features/featuresDeepDive/mesh/interactions/mesh_intersect\n   * @param boundingInfo the bounding info to check intersection with\n   * @param precise if the intersection should be done using OBB\n   * @returns if the bounding info intersects\n   */\n\n\n  intersects(boundingInfo, precise) {\n    if (!_boundingSphere.BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {\n      return false;\n    }\n\n    if (!_boundingBox.BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {\n      return false;\n    }\n\n    if (!precise) {\n      return true;\n    }\n\n    const box0 = this.boundingBox;\n    const box1 = boundingInfo.boundingBox;\n\n    if (!axisOverlap(box0.directions[0], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box0.directions[1], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box0.directions[2], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box1.directions[0], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box1.directions[1], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(box1.directions[2], box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(_mathVector.Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(_mathVector.Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(_mathVector.Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(_mathVector.Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(_mathVector.Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(_mathVector.Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(_mathVector.Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(_mathVector.Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {\n      return false;\n    }\n\n    if (!axisOverlap(_mathVector.Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {\n      return false;\n    }\n\n    return true;\n  }\n\n}\n\nexports.BoundingInfo = BoundingInfo;\nBoundingInfo._TmpVector3 = _arrayTools.ArrayTools.BuildArray(2, _mathVector.Vector3.Zero);\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","BoundingInfo","_arrayTools","_mathVector","_boundingBox","_boundingSphere","_result0","min","max","_result1","computeBoxExtents","axis","box","result","p","Vector3","Dot","centerWorld","r0","Math","abs","directions","extendSize","x","r1","y","r2","z","r","axisOverlap","box0","box1","constructor","minimum","maximum","worldMatrix","_isLocked","boundingBox","BoundingBox","boundingSphere","BoundingSphere","reConstruct","update","world","_update","centerOn","center","extend","_TmpVector3","copyFrom","subtractInPlace","addInPlace","getWorldMatrix","encapsulate","point","Minimize","Maximize","encapsulateBoundingInfo","toEncapsulate","invw","TmpVectors","Matrix","invertToRef","v","TransformCoordinatesToRef","minimumWorld","maximumWorld","scale","factor","isInFrustum","frustumPlanes","strategy","isCenterInFrustum","subtractToRef","diag","length","isCompletelyInFrustum","_checkCollision","collider","_canDoCollision","radiusWorld","intersectsPoint","intersects","boundingInfo","precise","Intersects","Cross","ArrayTools","BuildArray","Zero"]
}
