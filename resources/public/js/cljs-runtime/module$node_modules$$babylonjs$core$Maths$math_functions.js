shadow$provide.module$node_modules$$babylonjs$core$Maths$math_functions=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.extractMinAndMaxIndexed=function(positions,indices,indexStart,indexCount,bias=null){const minimum=new _mathVector.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),maximum=new _mathVector.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);MathHelpers.extractMinAndMaxIndexed(positions,indices,indexStart,
indexCount,minimum,maximum);bias&&(minimum.x-=minimum.x*bias.x+bias.y,minimum.y-=minimum.y*bias.x+bias.y,minimum.z-=minimum.z*bias.x+bias.y,maximum.x+=maximum.x*bias.x+bias.y,maximum.y+=maximum.y*bias.x+bias.y,maximum.z+=maximum.z*bias.x+bias.y);return{minimum,maximum}};exports.extractMinAndMax=function(positions,start,count,bias=null,stride){const minimum=new _mathVector.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),maximum=new _mathVector.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,
-Number.MAX_VALUE);stride||(stride=3);MathHelpers.extractMinAndMax(positions,start,count,stride,minimum,maximum);bias&&(minimum.x-=minimum.x*bias.x+bias.y,minimum.y-=minimum.y*bias.x+bias.y,minimum.z-=minimum.z*bias.x+bias.y,maximum.x+=maximum.x*bias.x+bias.y,maximum.y+=maximum.y*bias.x+bias.y,maximum.z+=maximum.z*bias.x+bias.y);return{minimum,maximum}};global=require("module$node_modules$$babylonjs$core$tslib_es6");var _mathVector=require("module$node_modules$$babylonjs$core$Maths$math_vector");
require=require("module$node_modules$$babylonjs$core$Misc$decorators");class MathHelpers{static extractMinAndMaxIndexed(positions,indices,indexStart,indexCount,minimum,maximum){for(let index=indexStart;index<indexStart+indexCount;index++){var offset=3*indices[index];const x=positions[offset],y=positions[offset+1];offset=positions[offset+2];minimum.minimizeInPlaceFromFloats(x,y,offset);maximum.maximizeInPlaceFromFloats(x,y,offset)}}static extractMinAndMax(positions,start,count,stride,minimum,maximum){for(let index=
start,offset=start*stride;index<start+count;index++,offset+=stride){const x=positions[offset],y=positions[offset+1],z=positions[offset+2];minimum.minimizeInPlaceFromFloats(x,y,z);maximum.maximizeInPlaceFromFloats(x,y,z)}}}(0,global.__decorate)([require.nativeOverride.filter((...[positions,indices])=>!Array.isArray(positions)&&!Array.isArray(indices))],MathHelpers,"extractMinAndMaxIndexed",null);(0,global.__decorate)([require.nativeOverride.filter((...[positions])=>!Array.isArray(positions))],MathHelpers,
"extractMinAndMax",null)}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Maths$math_functions.js.map
