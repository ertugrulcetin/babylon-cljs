shadow$provide.module$node_modules$$babylonjs$core$Culling$boundingSphere=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.BoundingSphere=void 0;global=require("module$node_modules$$babylonjs$core$Misc$arrayTools");var _mathVector=require("module$node_modules$$babylonjs$core$Maths$math_vector");class BoundingSphere{constructor(min,max,worldMatrix){this.center=_mathVector.Vector3.Zero();this.centerWorld=_mathVector.Vector3.Zero();this.minimum=_mathVector.Vector3.Zero();
this.maximum=_mathVector.Vector3.Zero();this.reConstruct(min,max,worldMatrix)}reConstruct(min,max,worldMatrix){this.minimum.copyFrom(min);this.maximum.copyFrom(max);const distance=_mathVector.Vector3.Distance(min,max);max.addToRef(min,this.center).scaleInPlace(.5);this.radius=.5*distance;this._update(worldMatrix||_mathVector.Matrix.IdentityReadOnly)}scale(factor){var tmpVectors=BoundingSphere._TmpVector3;const tempRadiusVector=tmpVectors[0].setAll(this.radius*factor);factor=this.center.subtractToRef(tempRadiusVector,
tmpVectors[1]);tmpVectors=this.center.addToRef(tempRadiusVector,tmpVectors[2]);this.reConstruct(factor,tmpVectors,this._worldMatrix);return this}getWorldMatrix(){return this._worldMatrix}_update(worldMatrix){if(worldMatrix.isIdentity())this.centerWorld.copyFrom(this.center),this.radiusWorld=this.radius;else{_mathVector.Vector3.TransformCoordinatesToRef(this.center,worldMatrix,this.centerWorld);const tempVector=BoundingSphere._TmpVector3[0];_mathVector.Vector3.TransformNormalFromFloatsToRef(1,1,1,
worldMatrix,tempVector);this.radiusWorld=Math.max(Math.abs(tempVector.x),Math.abs(tempVector.y),Math.abs(tempVector.z))*this.radius}}isInFrustum(frustumPlanes){const center=this.centerWorld,radius=this.radiusWorld;for(let i=0;6>i;i++)if(frustumPlanes[i].dotCoordinate(center)<=-radius)return!1;return!0}isCenterInFrustum(frustumPlanes){const center=this.centerWorld;for(let i=0;6>i;i++)if(0>frustumPlanes[i].dotCoordinate(center))return!1;return!0}intersectsPoint(point){point=_mathVector.Vector3.DistanceSquared(this.centerWorld,
point);return this.radiusWorld*this.radiusWorld<point?!1:!0}static Intersects(sphere0,sphere1){const squareDistance=_mathVector.Vector3.DistanceSquared(sphere0.centerWorld,sphere1.centerWorld);sphere0=sphere0.radiusWorld+sphere1.radiusWorld;return sphere0*sphere0<squareDistance?!1:!0}static CreateFromCenterAndRadius(center,radius,matrix){this._TmpVector3[0].copyFrom(center);this._TmpVector3[1].copyFromFloats(0,0,radius);this._TmpVector3[2].copyFrom(center);this._TmpVector3[0].addInPlace(this._TmpVector3[1]);
this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);center=new BoundingSphere(this._TmpVector3[0],this._TmpVector3[2]);center._worldMatrix=matrix?matrix:_mathVector.Matrix.Identity();return center}}exports.BoundingSphere=BoundingSphere;BoundingSphere._TmpVector3=global.ArrayTools.BuildArray(3,_mathVector.Vector3.Zero)}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Culling$boundingSphere.js.map
