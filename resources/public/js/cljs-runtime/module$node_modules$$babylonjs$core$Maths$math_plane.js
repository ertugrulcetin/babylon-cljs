shadow$provide.module$node_modules$$babylonjs$core$Maths$math_plane=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Plane=void 0;var _mathVector=require("module$node_modules$$babylonjs$core$Maths$math_vector");class Plane{constructor(a,b,c,d){this.normal=new _mathVector.Vector3(a,b,c);this.d=d}asArray(){return[this.normal.x,this.normal.y,this.normal.z,this.d]}clone(){return new Plane(this.normal.x,this.normal.y,this.normal.z,this.d)}getClassName(){return"Plane"}getHashCode(){let hash=
this.normal.getHashCode();return hash=397*hash^(this.d|0)}normalize(){const norm=Math.sqrt(this.normal.x*this.normal.x+this.normal.y*this.normal.y+this.normal.z*this.normal.z);let magnitude=0;0!==norm&&(magnitude=1/norm);this.normal.x*=magnitude;this.normal.y*=magnitude;this.normal.z*=magnitude;this.d*=magnitude;return this}transform(transformation){var invertedMatrix=Plane._TmpMatrix;transformation.invertToRef(invertedMatrix);transformation=invertedMatrix.m;invertedMatrix=this.normal.x;const y=this.normal.y,
z=this.normal.z,d=this.d;return new Plane(invertedMatrix*transformation[0]+y*transformation[1]+z*transformation[2]+d*transformation[3],invertedMatrix*transformation[4]+y*transformation[5]+z*transformation[6]+d*transformation[7],invertedMatrix*transformation[8]+y*transformation[9]+z*transformation[10]+d*transformation[11],invertedMatrix*transformation[12]+y*transformation[13]+z*transformation[14]+d*transformation[15])}dotCoordinate(point){return this.normal.x*point.x+this.normal.y*point.y+this.normal.z*
point.z+this.d}copyFromPoints(point1,point2,point3){var x1=point2.x-point1.x,y1=point2.y-point1.y,z1=point2.z-point1.z;point2=point3.x-point1.x;const y2=point3.y-point1.y,z2=point3.z-point1.z;point3=y1*z2-z1*y2;z1=z1*point2-x1*z2;x1=x1*y2-y1*point2;y1=Math.sqrt(point3*point3+z1*z1+x1*x1);y1=0!==y1?1/y1:0;this.normal.x=point3*y1;this.normal.y=z1*y1;this.normal.z=x1*y1;this.d=-(this.normal.x*point1.x+this.normal.y*point1.y+this.normal.z*point1.z);return this}isFrontFacingTo(direction,epsilon){return _mathVector.Vector3.Dot(this.normal,
direction)<=epsilon}signedDistanceTo(point){return _mathVector.Vector3.Dot(point,this.normal)+this.d}static FromArray(array){return new Plane(array[0],array[1],array[2],array[3])}static FromPoints(point1,point2,point3){const result=new Plane(0,0,0,0);result.copyFromPoints(point1,point2,point3);return result}static FromPositionAndNormal(origin,normal){const result=new Plane(0,0,0,0);normal.normalize();result.normal=normal;result.d=-(normal.x*origin.x+normal.y*origin.y+normal.z*origin.z);return result}static SignedDistanceToPlaneFromPositionAndNormal(origin,
normal,point){origin=-(normal.x*origin.x+normal.y*origin.y+normal.z*origin.z);return _mathVector.Vector3.Dot(point,normal)+origin}}exports.Plane=Plane;Plane._TmpMatrix=_mathVector.Matrix.Identity()}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Maths$math_plane.js.map
