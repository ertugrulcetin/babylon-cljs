shadow$provide.module$node_modules$$babylonjs$core$Materials$materialHelper=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.MaterialHelper=void 0;var _logger=require("module$node_modules$$babylonjs$core$Misc$logger"),_camera=require("module$node_modules$$babylonjs$core$Cameras$camera"),_scene=require("module$node_modules$$babylonjs$core$scene"),_engineStore=require("module$node_modules$$babylonjs$core$Engines$engineStore"),_buffer=require("module$node_modules$$babylonjs$core$Buffers$buffer"),
_lightConstants=require("module$node_modules$$babylonjs$core$Lights$lightConstants");global=require("module$node_modules$$babylonjs$core$Maths$math_color");var _clipPlaneMaterialHelper=require("module$node_modules$$babylonjs$core$Materials$clipPlaneMaterialHelper");class MaterialHelper{static BindSceneUniformBuffer(effect,sceneUbo){sceneUbo.bindToEffect(effect,"Scene")}static PrepareDefinesForMergedUV(texture,defines,key){defines._needUVs=!0;defines[key]=!0;texture.optimizeUVAllocation&&texture.getTextureMatrix().isIdentityAs3x2()?
(defines[key+"DIRECTUV"]=texture.coordinatesIndex+1,defines["MAINUV"+(texture.coordinatesIndex+1)]=!0):defines[key+"DIRECTUV"]=0}static BindTextureMatrix(texture,uniformBuffer,key){texture=texture.getTextureMatrix();uniformBuffer.updateMatrix(key+"Matrix",texture)}static GetFogState(mesh,scene){return scene.fogEnabled&&mesh.applyFog&&scene.fogMode!==_scene.Scene.FOGMODE_NONE}static PrepareDefinesForMisc(mesh,scene,useLogarithmicDepth,pointsCloud,fogEnabled,alphaTest,defines){defines._areMiscDirty&&
(defines.LOGARITHMICDEPTH=useLogarithmicDepth,defines.POINTSIZE=pointsCloud,defines.FOG=fogEnabled&&this.GetFogState(mesh,scene),defines.NONUNIFORMSCALING=mesh.nonUniformScaling,defines.ALPHATEST=alphaTest)}static PrepareDefinesForCamera(scene,defines){let changed=!1;if(scene.activeCamera){const wasPersp=defines.CAMERA_PERSPECTIVE?1:0,isOrtho=scene.activeCamera.mode===_camera.Camera.ORTHOGRAPHIC_CAMERA?1:0;scene=scene.activeCamera.mode===_camera.Camera.PERSPECTIVE_CAMERA?1:0;if((defines.CAMERA_ORTHOGRAPHIC?
1:0)^isOrtho||wasPersp^scene)defines.CAMERA_ORTHOGRAPHIC=1===isOrtho,defines.CAMERA_PERSPECTIVE=1===scene,changed=!0}return changed}static PrepareDefinesForFrameBoundValues(scene,engine,material,defines,useInstances,useClipPlane=null,useThinInstances=!1){let changed=MaterialHelper.PrepareDefinesForCamera(scene,defines);!1!==useClipPlane&&(changed=(0,_clipPlaneMaterialHelper.prepareDefinesForClipPlanes)(material,scene,defines));defines.DEPTHPREPASS!==!engine.getColorWrite()&&(defines.DEPTHPREPASS=
!defines.DEPTHPREPASS,changed=!0);defines.INSTANCES!==useInstances&&(defines.INSTANCES=useInstances,changed=!0);defines.THIN_INSTANCES!==useThinInstances&&(defines.THIN_INSTANCES=useThinInstances,changed=!0);changed&&defines.markAsUnprocessed()}static PrepareDefinesForBones(mesh,defines){if(mesh.useBones&&mesh.computeBonesUsingShaders&&mesh.skeleton){defines.NUM_BONE_INFLUENCERS=mesh.numBoneInfluencers;var materialSupportsBoneTexture=void 0!==defines.BONETEXTURE;mesh.skeleton.isUsingTextureForMatrices&&
materialSupportsBoneTexture?defines.BONETEXTURE=!0:(defines.BonesPerMesh=mesh.skeleton.bones.length+1,defines.BONETEXTURE=materialSupportsBoneTexture?!1:void 0,(materialSupportsBoneTexture=mesh.getScene().prePassRenderer)&&materialSupportsBoneTexture.enabled&&(mesh=-1===materialSupportsBoneTexture.excludedSkinnedMesh.indexOf(mesh),defines.BONES_VELOCITY_ENABLED=mesh))}else defines.NUM_BONE_INFLUENCERS=0,defines.BonesPerMesh=0,void 0!==defines.BONETEXTURE&&(defines.BONETEXTURE=!1)}static PrepareDefinesForMorphTargets(mesh,
defines){(mesh=mesh.morphTargetManager)?(defines.MORPHTARGETS_UV=mesh.supportsUVs&&defines.UV1,defines.MORPHTARGETS_TANGENT=mesh.supportsTangents&&defines.TANGENT,defines.MORPHTARGETS_NORMAL=mesh.supportsNormals&&defines.NORMAL,defines.MORPHTARGETS=0<mesh.numInfluencers,defines.NUM_MORPH_INFLUENCERS=mesh.numInfluencers,defines.MORPHTARGETS_TEXTURE=mesh.isUsingTextureForTargets):(defines.MORPHTARGETS_UV=!1,defines.MORPHTARGETS_TANGENT=!1,defines.MORPHTARGETS_NORMAL=!1,defines.MORPHTARGETS=!1,defines.NUM_MORPH_INFLUENCERS=
0)}static PrepareDefinesForBakedVertexAnimation(mesh,defines){mesh=mesh.bakedVertexAnimationManager;defines.BAKED_VERTEX_ANIMATION_TEXTURE=mesh&&mesh.isEnabled?!0:!1}static PrepareDefinesForAttributes(mesh,defines,useVertexColor,useBones,useMorphTargets=!1,useVertexAlpha=!0,useBakedVertexAnimation=!0){if(!defines._areAttributesDirty&&defines._needNormals===defines._normals&&defines._needUVs===defines._uvs)return!1;defines._normals=defines._needNormals;defines._uvs=defines._needUVs;defines.NORMAL=
defines._needNormals&&mesh.isVerticesDataPresent(_buffer.VertexBuffer.NormalKind);defines._needNormals&&mesh.isVerticesDataPresent(_buffer.VertexBuffer.TangentKind)&&(defines.TANGENT=!0);for(let i=1;6>=i;++i)defines["UV"+i]=defines._needUVs?mesh.isVerticesDataPresent(`uv${1===i?"":i}`):!1;useVertexColor&&(useVertexColor=mesh.useVertexColors&&mesh.isVerticesDataPresent(_buffer.VertexBuffer.ColorKind),defines.VERTEXCOLOR=useVertexColor,defines.VERTEXALPHA=mesh.hasVertexAlpha&&useVertexColor&&useVertexAlpha);
mesh.isVerticesDataPresent(_buffer.VertexBuffer.ColorInstanceKind)&&(mesh.hasInstances||mesh.hasThinInstances)&&(defines.INSTANCESCOLOR=!0);useBones&&this.PrepareDefinesForBones(mesh,defines);useMorphTargets&&this.PrepareDefinesForMorphTargets(mesh,defines);useBakedVertexAnimation&&this.PrepareDefinesForBakedVertexAnimation(mesh,defines);return!0}static PrepareDefinesForMultiview(scene,defines){if(scene.activeCamera){const previousMultiview=defines.MULTIVIEW;defines.MULTIVIEW=null!==scene.activeCamera.outputRenderTarget&&
1<scene.activeCamera.outputRenderTarget.getViewCount();defines.MULTIVIEW!=previousMultiview&&defines.markAsUnprocessed()}}static PrepareDefinesForOIT(scene,defines,needAlphaBlending){const previousDefine=defines.ORDER_INDEPENDENT_TRANSPARENCY,previousDefine16Bits=defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;defines.ORDER_INDEPENDENT_TRANSPARENCY=scene.useOrderIndependentTransparency&&needAlphaBlending;defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS=!scene.getEngine().getCaps().textureFloatLinearFiltering;
previousDefine===defines.ORDER_INDEPENDENT_TRANSPARENCY&&previousDefine16Bits===defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS||defines.markAsUnprocessed()}static PrepareDefinesForPrePass(scene,defines,canRenderToMRT){const previousPrePass=defines.PREPASS;if(defines._arePrePassDirty){var texturesList=[{type:1,define:"PREPASS_POSITION",index:"PREPASS_POSITION_INDEX"},{type:2,define:"PREPASS_VELOCITY",index:"PREPASS_VELOCITY_INDEX"},{type:3,define:"PREPASS_REFLECTIVITY",index:"PREPASS_REFLECTIVITY_INDEX"},
{type:0,define:"PREPASS_IRRADIANCE",index:"PREPASS_IRRADIANCE_INDEX"},{type:7,define:"PREPASS_ALBEDO_SQRT",index:"PREPASS_ALBEDO_SQRT_INDEX"},{type:5,define:"PREPASS_DEPTH",index:"PREPASS_DEPTH_INDEX"},{type:6,define:"PREPASS_NORMAL",index:"PREPASS_NORMAL_INDEX"}];if(scene.prePassRenderer&&scene.prePassRenderer.enabled&&canRenderToMRT)for(defines.PREPASS=!0,defines.SCENE_MRT_COUNT=scene.prePassRenderer.mrtCount,canRenderToMRT=0;canRenderToMRT<texturesList.length;canRenderToMRT++){const index=scene.prePassRenderer.getIndex(texturesList[canRenderToMRT].type);
-1!==index?(defines[texturesList[canRenderToMRT].define]=!0,defines[texturesList[canRenderToMRT].index]=index):defines[texturesList[canRenderToMRT].define]=!1}else for(defines.PREPASS=!1,scene=0;scene<texturesList.length;scene++)defines[texturesList[scene].define]=!1;defines.PREPASS!=previousPrePass&&(defines.markAsUnprocessed(),defines.markAsImageProcessingDirty())}}static PrepareDefinesForLight(scene,mesh,light,lightIndex,defines,specularSupported,state){var _a;state.needNormals=!0;void 0===defines["LIGHT"+
lightIndex]&&(state.needRebuild=!0);defines["LIGHT"+lightIndex]=!0;defines["SPOTLIGHT"+lightIndex]=!1;defines["HEMILIGHT"+lightIndex]=!1;defines["POINTLIGHT"+lightIndex]=!1;defines["DIRLIGHT"+lightIndex]=!1;light.prepareLightSpecificDefines(defines,lightIndex);defines["LIGHT_FALLOFF_PHYSICAL"+lightIndex]=!1;defines["LIGHT_FALLOFF_GLTF"+lightIndex]=!1;defines["LIGHT_FALLOFF_STANDARD"+lightIndex]=!1;switch(light.falloffType){case _lightConstants.LightConstants.FALLOFF_GLTF:defines["LIGHT_FALLOFF_GLTF"+
lightIndex]=!0;break;case _lightConstants.LightConstants.FALLOFF_PHYSICAL:defines["LIGHT_FALLOFF_PHYSICAL"+lightIndex]=!0;break;case _lightConstants.LightConstants.FALLOFF_STANDARD:defines["LIGHT_FALLOFF_STANDARD"+lightIndex]=!0}specularSupported&&!light.specular.equalsFloats(0,0,0)&&(state.specularEnabled=!0);defines["SHADOW"+lightIndex]=!1;defines["SHADOWCSM"+lightIndex]=!1;defines["SHADOWCSMDEBUG"+lightIndex]=!1;defines["SHADOWCSMNUM_CASCADES"+lightIndex]=!1;defines["SHADOWCSMUSESHADOWMAXZ"+lightIndex]=
!1;defines["SHADOWCSMNOBLEND"+lightIndex]=!1;defines["SHADOWCSM_RIGHTHANDED"+lightIndex]=!1;defines["SHADOWPCF"+lightIndex]=!1;defines["SHADOWPCSS"+lightIndex]=!1;defines["SHADOWPOISSON"+lightIndex]=!1;defines["SHADOWESM"+lightIndex]=!1;defines["SHADOWCLOSEESM"+lightIndex]=!1;defines["SHADOWCUBE"+lightIndex]=!1;defines["SHADOWLOWQUALITY"+lightIndex]=!1;defines["SHADOWMEDIUMQUALITY"+lightIndex]=!1;mesh&&mesh.receiveShadows&&scene.shadowsEnabled&&light.shadowEnabled&&(scene=null!==(_a=light.getShadowGenerator(scene.activeCamera))&&
void 0!==_a?_a:light.getShadowGenerator())&&(_a=scene.getShadowMap())&&_a.renderList&&0<_a.renderList.length&&(state.shadowEnabled=!0,scene.prepareDefines(defines,lightIndex));light.lightmapMode!=_lightConstants.LightConstants.LIGHTMAP_DEFAULT?(state.lightmapMode=!0,defines["LIGHTMAPEXCLUDED"+lightIndex]=!0,defines["LIGHTMAPNOSPECULAR"+lightIndex]=light.lightmapMode==_lightConstants.LightConstants.LIGHTMAP_SHADOWSONLY):(defines["LIGHTMAPEXCLUDED"+lightIndex]=!1,defines["LIGHTMAPNOSPECULAR"+lightIndex]=
!1)}static PrepareDefinesForLights(scene,mesh,defines,specularSupported,maxSimultaneousLights=4,disableLighting=!1){if(!defines._areLightsDirty)return defines._needNormals;let lightIndex=0;const state={needNormals:defines._needNormals,needRebuild:!1,lightmapMode:!1,shadowEnabled:!1,specularEnabled:!1};if(scene.lightsEnabled&&!disableLighting)for(const light of mesh.lightSources)if(this.PrepareDefinesForLight(scene,mesh,light,lightIndex,defines,specularSupported,state),lightIndex++,lightIndex===maxSimultaneousLights)break;
defines.SPECULARTERM=state.specularEnabled;defines.SHADOWS=state.shadowEnabled;for(mesh=lightIndex;mesh<maxSimultaneousLights;mesh++)void 0!==defines["LIGHT"+mesh]&&(defines["LIGHT"+mesh]=!1,defines["HEMILIGHT"+mesh]=!1,defines["POINTLIGHT"+mesh]=!1,defines["DIRLIGHT"+mesh]=!1,defines["SPOTLIGHT"+mesh]=!1,defines["SHADOW"+mesh]=!1,defines["SHADOWCSM"+mesh]=!1,defines["SHADOWCSMDEBUG"+mesh]=!1,defines["SHADOWCSMNUM_CASCADES"+mesh]=!1,defines["SHADOWCSMUSESHADOWMAXZ"+mesh]=!1,defines["SHADOWCSMNOBLEND"+
mesh]=!1,defines["SHADOWCSM_RIGHTHANDED"+mesh]=!1,defines["SHADOWPCF"+mesh]=!1,defines["SHADOWPCSS"+mesh]=!1,defines["SHADOWPOISSON"+mesh]=!1,defines["SHADOWESM"+mesh]=!1,defines["SHADOWCLOSEESM"+mesh]=!1,defines["SHADOWCUBE"+mesh]=!1,defines["SHADOWLOWQUALITY"+mesh]=!1,defines["SHADOWMEDIUMQUALITY"+mesh]=!1);scene=scene.getEngine().getCaps();void 0===defines.SHADOWFLOAT&&(state.needRebuild=!0);defines.SHADOWFLOAT=state.shadowEnabled&&(scene.textureFloatRender&&scene.textureFloatLinearFiltering||
scene.textureHalfFloatRender&&scene.textureHalfFloatLinearFiltering);defines.LIGHTMAPEXCLUDED=state.lightmapMode;state.needRebuild&&defines.rebuild();return state.needNormals}static PrepareUniformsAndSamplersForLight(lightIndex,uniformsList,samplersList,projectedLightTexture,uniformBuffersList=null,updateOnlyBuffersList=!1){uniformBuffersList&&uniformBuffersList.push("Light"+lightIndex);updateOnlyBuffersList||(uniformsList.push("vLightData"+lightIndex,"vLightDiffuse"+lightIndex,"vLightSpecular"+lightIndex,
"vLightDirection"+lightIndex,"vLightFalloff"+lightIndex,"vLightGround"+lightIndex,"lightMatrix"+lightIndex,"shadowsInfo"+lightIndex,"depthValues"+lightIndex),samplersList.push("shadowSampler"+lightIndex),samplersList.push("depthSampler"+lightIndex),uniformsList.push("viewFrustumZ"+lightIndex,"cascadeBlendFactor"+lightIndex,"lightSizeUVCorrection"+lightIndex,"depthCorrection"+lightIndex,"penumbraDarkness"+lightIndex,"frustumLengths"+lightIndex),projectedLightTexture&&(samplersList.push("projectionLightSampler"+
lightIndex),uniformsList.push("textureProjectionMatrix"+lightIndex)))}static PrepareUniformsAndSamplersList(uniformsListOrOptions,samplersList,defines,maxSimultaneousLights=4){let uniformsList,uniformBuffersList=null;uniformsListOrOptions.uniformsNames?(uniformsList=uniformsListOrOptions.uniformsNames,uniformBuffersList=uniformsListOrOptions.uniformBuffersNames,samplersList=uniformsListOrOptions.samplers,defines=uniformsListOrOptions.defines,maxSimultaneousLights=uniformsListOrOptions.maxSimultaneousLights||
0):(uniformsList=uniformsListOrOptions,samplersList||(samplersList=[]));for(uniformsListOrOptions=0;uniformsListOrOptions<maxSimultaneousLights&&defines["LIGHT"+uniformsListOrOptions];uniformsListOrOptions++)this.PrepareUniformsAndSamplersForLight(uniformsListOrOptions,uniformsList,samplersList,defines["PROJECTEDLIGHTTEXTURE"+uniformsListOrOptions],uniformBuffersList);defines.NUM_MORPH_INFLUENCERS&&uniformsList.push("morphTargetInfluences");defines.BAKED_VERTEX_ANIMATION_TEXTURE&&(uniformsList.push("bakedVertexAnimationSettings"),
uniformsList.push("bakedVertexAnimationTextureSizeInverted"),uniformsList.push("bakedVertexAnimationTime"),samplersList.push("bakedVertexAnimationTexture"))}static HandleFallbacksForShadows(defines,fallbacks,maxSimultaneousLights=4,rank=0){let lightFallbackRank=0;for(let lightIndex=0;lightIndex<maxSimultaneousLights&&defines["LIGHT"+lightIndex];lightIndex++)0<lightIndex&&(lightFallbackRank=rank+lightIndex,fallbacks.addFallback(lightFallbackRank,"LIGHT"+lightIndex)),defines.SHADOWS||(defines["SHADOW"+
lightIndex]&&fallbacks.addFallback(rank,"SHADOW"+lightIndex),defines["SHADOWPCF"+lightIndex]&&fallbacks.addFallback(rank,"SHADOWPCF"+lightIndex),defines["SHADOWPCSS"+lightIndex]&&fallbacks.addFallback(rank,"SHADOWPCSS"+lightIndex),defines["SHADOWPOISSON"+lightIndex]&&fallbacks.addFallback(rank,"SHADOWPOISSON"+lightIndex),defines["SHADOWESM"+lightIndex]&&fallbacks.addFallback(rank,"SHADOWESM"+lightIndex),defines["SHADOWCLOSEESM"+lightIndex]&&fallbacks.addFallback(rank,"SHADOWCLOSEESM"+lightIndex));
return lightFallbackRank++}static PrepareAttributesForMorphTargetsInfluencers(attribs,mesh,influencers){this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS=influencers;this.PrepareAttributesForMorphTargets(attribs,mesh,this._TmpMorphInfluencers)}static PrepareAttributesForMorphTargets(attribs,mesh,defines){const influencers=defines.NUM_MORPH_INFLUENCERS;if(0<influencers&&_engineStore.EngineStore.LastCreatedEngine){const maxAttributesCount=_engineStore.EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;
var manager=mesh.morphTargetManager;if(null===manager||void 0===manager||!manager.isUsingTextureForTargets){var normal=manager&&manager.supportsNormals&&defines.NORMAL,tangent=manager&&manager.supportsTangents&&defines.TANGENT;defines=manager&&manager.supportsUVs&&defines.UV1;for(manager=0;manager<influencers;manager++)attribs.push(_buffer.VertexBuffer.PositionKind+manager),normal&&attribs.push(_buffer.VertexBuffer.NormalKind+manager),tangent&&attribs.push(_buffer.VertexBuffer.TangentKind+manager),
defines&&attribs.push(_buffer.VertexBuffer.UVKind+"_"+manager),attribs.length>maxAttributesCount&&_logger.Logger.Error("Cannot add more vertex attributes for mesh "+mesh.name)}}}static PrepareAttributesForBakedVertexAnimation(attribs,mesh,defines){defines.BAKED_VERTEX_ANIMATION_TEXTURE&&defines.INSTANCES&&attribs.push("bakedVertexAnimationSettingsInstanced")}static PrepareAttributesForBones(attribs,mesh,defines,fallbacks){0<defines.NUM_BONE_INFLUENCERS&&(fallbacks.addCPUSkinningFallback(0,mesh),attribs.push(_buffer.VertexBuffer.MatricesIndicesKind),
attribs.push(_buffer.VertexBuffer.MatricesWeightsKind),4<defines.NUM_BONE_INFLUENCERS&&(attribs.push(_buffer.VertexBuffer.MatricesIndicesExtraKind),attribs.push(_buffer.VertexBuffer.MatricesWeightsExtraKind)))}static PrepareAttributesForInstances(attribs,defines){(defines.INSTANCES||defines.THIN_INSTANCES)&&this.PushAttributesForInstances(attribs,!!defines.PREPASS_VELOCITY);defines.INSTANCESCOLOR&&attribs.push(_buffer.VertexBuffer.ColorInstanceKind)}static PushAttributesForInstances(attribs,needsPreviousMatrices=
!1){attribs.push("world0");attribs.push("world1");attribs.push("world2");attribs.push("world3");needsPreviousMatrices&&(attribs.push("previousWorld0"),attribs.push("previousWorld1"),attribs.push("previousWorld2"),attribs.push("previousWorld3"))}static BindLightProperties(light,effect,lightIndex){light.transferToEffect(effect,lightIndex+"")}static BindLight(light,lightIndex,scene,effect,useSpecular,receiveShadows=!0){light._bindLight(lightIndex,scene,effect,useSpecular,receiveShadows)}static BindLights(scene,
mesh,effect,defines,maxSimultaneousLights=4){maxSimultaneousLights=Math.min(mesh.lightSources.length,maxSimultaneousLights);for(let i=0;i<maxSimultaneousLights;i++)this.BindLight(mesh.lightSources[i],i,scene,effect,"boolean"===typeof defines?defines:defines.SPECULARTERM,mesh.receiveShadows)}static BindFogParameters(scene,mesh,effect,linearSpace=!1){scene.fogEnabled&&mesh.applyFog&&scene.fogMode!==_scene.Scene.FOGMODE_NONE&&(effect.setFloat4("vFogInfos",scene.fogMode,scene.fogStart,scene.fogEnd,scene.fogDensity),
linearSpace?(scene.fogColor.toLinearSpaceToRef(this._TempFogColor,scene.getEngine().useExactSrgbConversions),effect.setColor3("vFogColor",this._TempFogColor)):effect.setColor3("vFogColor",scene.fogColor))}static BindBonesParameters(mesh,effect,prePassConfiguration){if(effect&&mesh&&(mesh.computeBonesUsingShaders&&effect._bonesComputationForcedToCPU&&(mesh.computeBonesUsingShaders=!1),mesh.useBones&&mesh.computeBonesUsingShaders&&mesh.skeleton)){var skeleton=mesh.skeleton;if(skeleton.isUsingTextureForMatrices&&
-1<effect.getUniformIndex("boneTextureWidth"))mesh=skeleton.getTransformMatrixTexture(mesh),effect.setTexture("boneSampler",mesh),effect.setFloat("boneTextureWidth",4*(skeleton.bones.length+1));else if(skeleton=skeleton.getTransformMatrices(mesh))effect.setMatrices("mBones",skeleton),prePassConfiguration&&mesh.getScene().prePassRenderer&&mesh.getScene().prePassRenderer.getIndex(2)&&(prePassConfiguration.previousBones[mesh.uniqueId]||(prePassConfiguration.previousBones[mesh.uniqueId]=skeleton.slice()),
effect.setMatrices("mPreviousBones",prePassConfiguration.previousBones[mesh.uniqueId]),MaterialHelper._CopyBonesTransformationMatrices(skeleton,prePassConfiguration.previousBones[mesh.uniqueId]))}}static _CopyBonesTransformationMatrices(source,target){target.set(source);return target}static BindMorphTargetParameters(abstractMesh,effect){const manager=abstractMesh.morphTargetManager;abstractMesh&&manager&&effect.setFloatArray("morphTargetInfluences",manager.influences)}static BindLogDepth(defines,
effect,scene){if(!defines||defines.LOGARITHMICDEPTH||defines.indexOf&&0<=defines.indexOf("LOGARITHMICDEPTH"))defines=scene.activeCamera,defines.mode===_camera.Camera.ORTHOGRAPHIC_CAMERA&&_logger.Logger.Error("Logarithmic depth is not compatible with orthographic cameras!",20),effect.setFloat("logarithmicDepthConstant",2/(Math.log(defines.maxZ+1)/Math.LN2))}}exports.MaterialHelper=MaterialHelper;MaterialHelper._TmpMorphInfluencers={NUM_MORPH_INFLUENCERS:0};MaterialHelper._TempFogColor=global.Color3.Black()}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Materials$materialHelper.js.map
