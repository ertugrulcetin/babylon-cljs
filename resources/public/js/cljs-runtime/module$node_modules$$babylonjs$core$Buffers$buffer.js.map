{
"version":3,
"file":"module$node_modules$$babylonjs$core$Buffers$buffer.js",
"lineCount":18,
"mappings":"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",
"sources":["node_modules/@babylonjs/core/Buffers/buffer.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$babylonjs$core$Buffers$buffer\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.VertexBuffer = exports.Buffer = void 0;\n\nvar _dataBuffer = require(\"./dataBuffer.js\");\n\n/**\n * Class used to store data that will be store in GPU memory\n */\nclass Buffer {\n  /**\n   * Constructor\n   * @param engine the engine\n   * @param data the data to use for this buffer\n   * @param updatable whether the data is updatable\n   * @param stride the stride (optional)\n   * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\n   * @param instanced whether the buffer is instanced (optional)\n   * @param useBytes set to true if the stride in in bytes (optional)\n   * @param divisor sets an optional divisor for instances (1 by default)\n   */\n  constructor(engine, data, updatable, stride = 0, postponeInternalCreation = false, instanced = false, useBytes = false, divisor) {\n    this._isAlreadyOwned = false;\n\n    if (engine.getScene) {\n      // old versions of VertexBuffer accepted 'mesh' instead of 'engine'\n      this._engine = engine.getScene().getEngine();\n    } else {\n      this._engine = engine;\n    }\n\n    this._updatable = updatable;\n    this._instanced = instanced;\n    this._divisor = divisor || 1;\n\n    if (data instanceof _dataBuffer.DataBuffer) {\n      this._data = null;\n      this._buffer = data;\n    } else {\n      this._data = data;\n      this._buffer = null;\n    }\n\n    this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;\n\n    if (!postponeInternalCreation) {\n      // by default\n      this.create();\n    }\n  }\n  /**\n   * Create a new VertexBuffer based on the current buffer\n   * @param kind defines the vertex buffer kind (position, normal, etc.)\n   * @param offset defines offset in the buffer (0 by default)\n   * @param size defines the size in floats of attributes (position is 3 for instance)\n   * @param stride defines the stride size in floats in the buffer (the offset to apply to reach next value when data is interleaved)\n   * @param instanced defines if the vertex buffer contains indexed data\n   * @param useBytes defines if the offset and stride are in bytes     *\n   * @param divisor sets an optional divisor for instances (1 by default)\n   * @returns the new vertex buffer\n   */\n\n\n  createVertexBuffer(kind, offset, size, stride, instanced, useBytes = false, divisor) {\n    const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;\n    const byteStride = stride ? useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT : this.byteStride; // a lot of these parameters are ignored as they are overridden by the buffer\n\n    return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === undefined ? this._instanced : instanced, byteOffset, size, undefined, undefined, true, this._divisor || divisor);\n  } // Properties\n\n  /**\n   * Gets a boolean indicating if the Buffer is updatable?\n   * @returns true if the buffer is updatable\n   */\n\n\n  isUpdatable() {\n    return this._updatable;\n  }\n  /**\n   * Gets current buffer's data\n   * @returns a DataArray or null\n   */\n\n\n  getData() {\n    return this._data;\n  }\n  /**\n   * Gets underlying native buffer\n   * @returns underlying native buffer\n   */\n\n\n  getBuffer() {\n    return this._buffer;\n  }\n  /**\n   * Gets the stride in float32 units (i.e. byte stride / 4).\n   * May not be an integer if the byte stride is not divisible by 4.\n   * @returns the stride in float32 units\n   * @deprecated Please use byteStride instead.\n   */\n\n\n  getStrideSize() {\n    return this.byteStride / Float32Array.BYTES_PER_ELEMENT;\n  } // Methods\n\n  /**\n   * Store data into the buffer. Creates the buffer if not used already.\n   * If the buffer was already used, it will be updated only if it is updatable, otherwise it will do nothing.\n   * @param data defines the data to store\n   */\n\n\n  create(data = null) {\n    if (!data && this._buffer) {\n      return; // nothing to do\n    }\n\n    data = data || this._data;\n\n    if (!data) {\n      return;\n    }\n\n    if (!this._buffer) {\n      // create buffer\n      if (this._updatable) {\n        this._buffer = this._engine.createDynamicVertexBuffer(data);\n        this._data = data;\n      } else {\n        this._buffer = this._engine.createVertexBuffer(data);\n      }\n    } else if (this._updatable) {\n      // update buffer\n      this._engine.updateDynamicVertexBuffer(this._buffer, data);\n\n      this._data = data;\n    }\n  }\n  /** @internal */\n\n\n  _rebuild() {\n    this._buffer = null;\n    this.create(this._data);\n  }\n  /**\n   * Update current buffer data\n   * @param data defines the data to store\n   */\n\n\n  update(data) {\n    this.create(data);\n  }\n  /**\n   * Updates the data directly.\n   * @param data the new data\n   * @param offset the new offset\n   * @param vertexCount the vertex count (optional)\n   * @param useBytes set to true if the offset is in bytes\n   */\n\n\n  updateDirectly(data, offset, vertexCount, useBytes = false) {\n    if (!this._buffer) {\n      return;\n    }\n\n    if (this._updatable) {\n      // update buffer\n      this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, vertexCount ? vertexCount * this.byteStride : undefined);\n\n      if (offset === 0 && vertexCount === undefined) {\n        // Keep the data if we easily can\n        this._data = data;\n      } else {\n        this._data = null;\n      }\n    }\n  }\n  /** @internal */\n\n\n  _increaseReferences() {\n    if (!this._buffer) {\n      return;\n    }\n\n    if (!this._isAlreadyOwned) {\n      this._isAlreadyOwned = true;\n      return;\n    }\n\n    this._buffer.references++;\n  }\n  /**\n   * Release all resources\n   */\n\n\n  dispose() {\n    if (!this._buffer) {\n      return;\n    }\n\n    if (this._engine._releaseBuffer(this._buffer)) {\n      this._buffer = null;\n      this._data = null;\n    }\n  }\n\n}\n/**\n * Specialized buffer used to store vertex data\n */\n\n\nexports.Buffer = Buffer;\n\nclass VertexBuffer {\n  /**\n   * Gets or sets the instance divisor when in instanced mode\n   */\n  get instanceDivisor() {\n    return this._instanceDivisor;\n  }\n\n  set instanceDivisor(value) {\n    const isInstanced = value != 0;\n    this._instanceDivisor = value;\n\n    if (isInstanced !== this._instanced) {\n      this._instanced = isInstanced;\n\n      this._computeHashCode();\n    }\n  }\n  /**\n   * Constructor\n   * @param engine the engine\n   * @param data the data to use for this vertex buffer\n   * @param kind the vertex buffer kind\n   * @param updatable whether the data is updatable\n   * @param postponeInternalCreation whether to postpone creating the internal WebGL buffer (optional)\n   * @param stride the stride (optional)\n   * @param instanced whether the buffer is instanced (optional)\n   * @param offset the offset of the data (optional)\n   * @param size the number of components (optional)\n   * @param type the type of the component (optional)\n   * @param normalized whether the data contains normalized data (optional)\n   * @param useBytes set to true if stride and offset are in bytes (optional)\n   * @param divisor defines the instance divisor to use (1 by default)\n   * @param takeBufferOwnership defines if the buffer should be released when the vertex buffer is disposed\n   */\n\n\n  constructor(engine, data, kind, updatable, postponeInternalCreation, stride, instanced, offset, size, type, normalized = false, useBytes = false, divisor = 1, takeBufferOwnership = false) {\n    if (data instanceof Buffer) {\n      this._buffer = data;\n      this._ownsBuffer = takeBufferOwnership;\n    } else {\n      this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes);\n      this._ownsBuffer = true;\n    }\n\n    this.uniqueId = VertexBuffer._Counter++;\n    this._kind = kind;\n\n    if (type == undefined) {\n      const vertexData = this.getData();\n      this.type = VertexBuffer.FLOAT;\n\n      if (vertexData instanceof Int8Array) {\n        this.type = VertexBuffer.BYTE;\n      } else if (vertexData instanceof Uint8Array) {\n        this.type = VertexBuffer.UNSIGNED_BYTE;\n      } else if (vertexData instanceof Int16Array) {\n        this.type = VertexBuffer.SHORT;\n      } else if (vertexData instanceof Uint16Array) {\n        this.type = VertexBuffer.UNSIGNED_SHORT;\n      } else if (vertexData instanceof Int32Array) {\n        this.type = VertexBuffer.INT;\n      } else if (vertexData instanceof Uint32Array) {\n        this.type = VertexBuffer.UNSIGNED_INT;\n      }\n    } else {\n      this.type = type;\n    }\n\n    const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);\n\n    if (useBytes) {\n      this._size = size || (stride ? stride / typeByteLength : VertexBuffer.DeduceStride(kind));\n      this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;\n      this.byteOffset = offset || 0;\n    } else {\n      this._size = size || stride || VertexBuffer.DeduceStride(kind);\n      this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;\n      this.byteOffset = (offset || 0) * typeByteLength;\n    }\n\n    this.normalized = normalized;\n    this._instanced = instanced !== undefined ? instanced : false;\n    this._instanceDivisor = instanced ? divisor : 0;\n\n    this._computeHashCode();\n  }\n\n  _computeHashCode() {\n    // note: cast to any because the property is declared readonly\n    this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + (this.byteStride << 12);\n  }\n  /** @internal */\n\n\n  _rebuild() {\n    if (!this._buffer) {\n      return;\n    }\n\n    this._buffer._rebuild();\n  }\n  /**\n   * Returns the kind of the VertexBuffer (string)\n   * @returns a string\n   */\n\n\n  getKind() {\n    return this._kind;\n  } // Properties\n\n  /**\n   * Gets a boolean indicating if the VertexBuffer is updatable?\n   * @returns true if the buffer is updatable\n   */\n\n\n  isUpdatable() {\n    return this._buffer.isUpdatable();\n  }\n  /**\n   * Gets current buffer's data\n   * @returns a DataArray or null\n   */\n\n\n  getData() {\n    return this._buffer.getData();\n  }\n  /**\n   * Gets current buffer's data as a float array. Float data is constructed if the vertex buffer data cannot be returned directly.\n   * @param totalVertices number of vertices in the buffer to take into account\n   * @param forceCopy defines a boolean indicating that the returned array must be cloned upon returning it\n   * @returns a float array containing vertex data\n   */\n\n\n  getFloatData(totalVertices, forceCopy) {\n    const data = this.getData();\n\n    if (!data) {\n      return null;\n    }\n\n    const tightlyPackedByteStride = this.getSize() * VertexBuffer.GetTypeByteLength(this.type);\n    const count = totalVertices * this.getSize();\n\n    if (this.type !== VertexBuffer.FLOAT || this.byteStride !== tightlyPackedByteStride) {\n      const copy = new Float32Array(count);\n      this.forEach(count, (value, index) => copy[index] = value);\n      return copy;\n    }\n\n    if (!(data instanceof Array || data instanceof Float32Array) || this.byteOffset !== 0 || data.length !== count) {\n      if (data instanceof Array) {\n        const offset = this.byteOffset / 4;\n        return data.slice(offset, offset + count);\n      } else if (data instanceof ArrayBuffer) {\n        return new Float32Array(data, this.byteOffset, count);\n      } else {\n        let offset = data.byteOffset + this.byteOffset;\n\n        if (forceCopy) {\n          const result = new Float32Array(count);\n          const source = new Float32Array(data.buffer, offset, count);\n          result.set(source);\n          return result;\n        } // Protect against bad data\n\n\n        const remainder = offset % 4;\n\n        if (remainder) {\n          offset = Math.max(0, offset - remainder);\n        }\n\n        return new Float32Array(data.buffer, offset, count);\n      }\n    }\n\n    if (forceCopy) {\n      return data.slice();\n    }\n\n    return data;\n  }\n  /**\n   * Gets underlying native buffer\n   * @returns underlying native buffer\n   */\n\n\n  getBuffer() {\n    return this._buffer.getBuffer();\n  }\n  /**\n   * Gets the stride in float32 units (i.e. byte stride / 4).\n   * May not be an integer if the byte stride is not divisible by 4.\n   * @returns the stride in float32 units\n   * @deprecated Please use byteStride instead.\n   */\n\n\n  getStrideSize() {\n    return this.byteStride / VertexBuffer.GetTypeByteLength(this.type);\n  }\n  /**\n   * Returns the offset as a multiple of the type byte length.\n   * @returns the offset in bytes\n   * @deprecated Please use byteOffset instead.\n   */\n\n\n  getOffset() {\n    return this.byteOffset / VertexBuffer.GetTypeByteLength(this.type);\n  }\n  /**\n   * Returns the number of components or the byte size per vertex attribute\n   * @param sizeInBytes If true, returns the size in bytes or else the size in number of components of the vertex attribute (default: false)\n   * @returns the number of components\n   */\n\n\n  getSize(sizeInBytes = false) {\n    return sizeInBytes ? this._size * VertexBuffer.GetTypeByteLength(this.type) : this._size;\n  }\n  /**\n   * Gets a boolean indicating is the internal buffer of the VertexBuffer is instanced\n   * @returns true if this buffer is instanced\n   */\n\n\n  getIsInstanced() {\n    return this._instanced;\n  }\n  /**\n   * Returns the instancing divisor, zero for non-instanced (integer).\n   * @returns a number\n   */\n\n\n  getInstanceDivisor() {\n    return this._instanceDivisor;\n  } // Methods\n\n  /**\n   * Store data into the buffer. If the buffer was already used it will be either recreated or updated depending on isUpdatable property\n   * @param data defines the data to store\n   */\n\n\n  create(data) {\n    this._buffer.create(data);\n  }\n  /**\n   * Updates the underlying buffer according to the passed numeric array or Float32Array.\n   * This function will create a new buffer if the current one is not updatable\n   * @param data defines the data to store\n   */\n\n\n  update(data) {\n    this._buffer.update(data);\n  }\n  /**\n   * Updates directly the underlying WebGLBuffer according to the passed numeric array or Float32Array.\n   * Returns the directly updated WebGLBuffer.\n   * @param data the new data\n   * @param offset the new offset\n   * @param useBytes set to true if the offset is in bytes\n   */\n\n\n  updateDirectly(data, offset, useBytes = false) {\n    this._buffer.updateDirectly(data, offset, undefined, useBytes);\n  }\n  /**\n   * Disposes the VertexBuffer and the underlying WebGLBuffer.\n   */\n\n\n  dispose() {\n    if (this._ownsBuffer) {\n      this._buffer.dispose();\n    }\n  }\n  /**\n   * Enumerates each value of this vertex buffer as numbers.\n   * @param count the number of values to enumerate\n   * @param callback the callback function called for each value\n   */\n\n\n  forEach(count, callback) {\n    VertexBuffer.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);\n  }\n  /**\n   * Deduces the stride given a kind.\n   * @param kind The kind string to deduce\n   * @returns The deduced stride\n   */\n\n\n  static DeduceStride(kind) {\n    switch (kind) {\n      case VertexBuffer.UVKind:\n      case VertexBuffer.UV2Kind:\n      case VertexBuffer.UV3Kind:\n      case VertexBuffer.UV4Kind:\n      case VertexBuffer.UV5Kind:\n      case VertexBuffer.UV6Kind:\n        return 2;\n\n      case VertexBuffer.NormalKind:\n      case VertexBuffer.PositionKind:\n        return 3;\n\n      case VertexBuffer.ColorKind:\n      case VertexBuffer.MatricesIndicesKind:\n      case VertexBuffer.MatricesIndicesExtraKind:\n      case VertexBuffer.MatricesWeightsKind:\n      case VertexBuffer.MatricesWeightsExtraKind:\n      case VertexBuffer.TangentKind:\n        return 4;\n\n      default:\n        throw new Error(\"Invalid kind '\" + kind + \"'\");\n    }\n  }\n  /**\n   * Gets the byte length of the given type.\n   * @param type the type\n   * @returns the number of bytes\n   */\n\n\n  static GetTypeByteLength(type) {\n    switch (type) {\n      case VertexBuffer.BYTE:\n      case VertexBuffer.UNSIGNED_BYTE:\n        return 1;\n\n      case VertexBuffer.SHORT:\n      case VertexBuffer.UNSIGNED_SHORT:\n        return 2;\n\n      case VertexBuffer.INT:\n      case VertexBuffer.UNSIGNED_INT:\n      case VertexBuffer.FLOAT:\n        return 4;\n\n      default:\n        throw new Error(`Invalid type '${type}'`);\n    }\n  }\n  /**\n   * Enumerates each value of the given parameters as numbers.\n   * @param data the data to enumerate\n   * @param byteOffset the byte offset of the data\n   * @param byteStride the byte stride of the data\n   * @param componentCount the number of components per element\n   * @param componentType the type of the component\n   * @param count the number of values to enumerate\n   * @param normalized whether the data is normalized\n   * @param callback the callback function called for each value\n   */\n\n\n  static ForEach(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {\n    if (data instanceof Array) {\n      let offset = byteOffset / 4;\n      const stride = byteStride / 4;\n\n      for (let index = 0; index < count; index += componentCount) {\n        for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\n          callback(data[offset + componentIndex], index + componentIndex);\n        }\n\n        offset += stride;\n      }\n    } else {\n      const dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);\n      const componentByteLength = VertexBuffer.GetTypeByteLength(componentType);\n\n      for (let index = 0; index < count; index += componentCount) {\n        let componentByteOffset = byteOffset;\n\n        for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\n          const value = VertexBuffer._GetFloatValue(dataView, componentType, componentByteOffset, normalized);\n\n          callback(value, index + componentIndex);\n          componentByteOffset += componentByteLength;\n        }\n\n        byteOffset += byteStride;\n      }\n    }\n  }\n\n  static _GetFloatValue(dataView, type, byteOffset, normalized) {\n    switch (type) {\n      case VertexBuffer.BYTE:\n        {\n          let value = dataView.getInt8(byteOffset);\n\n          if (normalized) {\n            value = Math.max(value / 127, -1);\n          }\n\n          return value;\n        }\n\n      case VertexBuffer.UNSIGNED_BYTE:\n        {\n          let value = dataView.getUint8(byteOffset);\n\n          if (normalized) {\n            value = value / 255;\n          }\n\n          return value;\n        }\n\n      case VertexBuffer.SHORT:\n        {\n          let value = dataView.getInt16(byteOffset, true);\n\n          if (normalized) {\n            value = Math.max(value / 32767, -1);\n          }\n\n          return value;\n        }\n\n      case VertexBuffer.UNSIGNED_SHORT:\n        {\n          let value = dataView.getUint16(byteOffset, true);\n\n          if (normalized) {\n            value = value / 65535;\n          }\n\n          return value;\n        }\n\n      case VertexBuffer.INT:\n        {\n          return dataView.getInt32(byteOffset, true);\n        }\n\n      case VertexBuffer.UNSIGNED_INT:\n        {\n          return dataView.getUint32(byteOffset, true);\n        }\n\n      case VertexBuffer.FLOAT:\n        {\n          return dataView.getFloat32(byteOffset, true);\n        }\n\n      default:\n        {\n          throw new Error(`Invalid component type ${type}`);\n        }\n    }\n  }\n\n}\n\nexports.VertexBuffer = VertexBuffer;\nVertexBuffer._Counter = 0;\n/**\n * The byte type.\n */\n\nVertexBuffer.BYTE = 5120;\n/**\n * The unsigned byte type.\n */\n\nVertexBuffer.UNSIGNED_BYTE = 5121;\n/**\n * The short type.\n */\n\nVertexBuffer.SHORT = 5122;\n/**\n * The unsigned short type.\n */\n\nVertexBuffer.UNSIGNED_SHORT = 5123;\n/**\n * The integer type.\n */\n\nVertexBuffer.INT = 5124;\n/**\n * The unsigned integer type.\n */\n\nVertexBuffer.UNSIGNED_INT = 5125;\n/**\n * The float type.\n */\n\nVertexBuffer.FLOAT = 5126; // Enums\n\n/**\n * Positions\n */\n\nVertexBuffer.PositionKind = \"position\";\n/**\n * Normals\n */\n\nVertexBuffer.NormalKind = \"normal\";\n/**\n * Tangents\n */\n\nVertexBuffer.TangentKind = \"tangent\";\n/**\n * Texture coordinates\n */\n\nVertexBuffer.UVKind = \"uv\";\n/**\n * Texture coordinates 2\n */\n\nVertexBuffer.UV2Kind = \"uv2\";\n/**\n * Texture coordinates 3\n */\n\nVertexBuffer.UV3Kind = \"uv3\";\n/**\n * Texture coordinates 4\n */\n\nVertexBuffer.UV4Kind = \"uv4\";\n/**\n * Texture coordinates 5\n */\n\nVertexBuffer.UV5Kind = \"uv5\";\n/**\n * Texture coordinates 6\n */\n\nVertexBuffer.UV6Kind = \"uv6\";\n/**\n * Colors\n */\n\nVertexBuffer.ColorKind = \"color\";\n/**\n * Instance Colors\n */\n\nVertexBuffer.ColorInstanceKind = \"instanceColor\";\n/**\n * Matrix indices (for bones)\n */\n\nVertexBuffer.MatricesIndicesKind = \"matricesIndices\";\n/**\n * Matrix weights (for bones)\n */\n\nVertexBuffer.MatricesWeightsKind = \"matricesWeights\";\n/**\n * Additional matrix indices (for bones)\n */\n\nVertexBuffer.MatricesIndicesExtraKind = \"matricesIndicesExtra\";\n/**\n * Additional matrix weights (for bones)\n */\n\nVertexBuffer.MatricesWeightsExtraKind = \"matricesWeightsExtra\";\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","VertexBuffer","Buffer","_dataBuffer","constructor","engine","data","updatable","stride","postponeInternalCreation","instanced","useBytes","divisor","_isAlreadyOwned","_engine","getScene","getEngine","_updatable","_instanced","_divisor","DataBuffer","_data","_buffer","byteStride","Float32Array","BYTES_PER_ELEMENT","create","createVertexBuffer","kind","offset","size","undefined","byteOffset","isUpdatable","getData","getBuffer","getStrideSize","updateDynamicVertexBuffer","createDynamicVertexBuffer","_rebuild","update","updateDirectly","vertexCount","_increaseReferences","references","dispose","_releaseBuffer","_instanceDivisor","isInstanced","_computeHashCode","type","normalized","takeBufferOwnership","_ownsBuffer","uniqueId","_Counter","_kind","vertexData","FLOAT","Int8Array","BYTE","Uint8Array","UNSIGNED_BYTE","Int16Array","SHORT","Uint16Array","UNSIGNED_SHORT","Int32Array","INT","Uint32Array","UNSIGNED_INT","typeByteLength","GetTypeByteLength","_size","DeduceStride","hashCode","getKind","getFloatData","totalVertices","forceCopy","tightlyPackedByteStride","getSize","count","copy","forEach","index","Array","length","slice","ArrayBuffer","result","source","buffer","set","remainder","Math","max","getOffset","sizeInBytes","getIsInstanced","getInstanceDivisor","callback","ForEach","UVKind","UV2Kind","UV3Kind","UV4Kind","UV5Kind","UV6Kind","NormalKind","PositionKind","ColorKind","MatricesIndicesKind","MatricesIndicesExtraKind","MatricesWeightsKind","MatricesWeightsExtraKind","TangentKind","Error","componentCount","componentType","componentIndex","dataView","DataView","byteLength","componentByteLength","componentByteOffset","_GetFloatValue","getInt8","getUint8","getInt16","getUint16","getInt32","getUint32","getFloat32","ColorInstanceKind"]
}
