{
"version":3,
"file":"module$node_modules$$babylonjs$core$Maths$math_scalar.js",
"lineCount":6,
"mappings":"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",
"sources":["node_modules/@babylonjs/core/Maths/math.scalar.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$$babylonjs$core$Maths$math_scalar\"] = function(global,require,module,exports) {\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Scalar = void 0;\n\n/**\n * Scalar computation library\n */\nclass Scalar {\n  /**\n   * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n   * @param a number\n   * @param b number\n   * @param epsilon (default = 1.401298E-45)\n   * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n   */\n  static WithinEpsilon(a, b, epsilon = 1.401298e-45) {\n    return Math.abs(a - b) <= epsilon;\n  }\n  /**\n   * Returns a string : the upper case translation of the number i to hexadecimal.\n   * @param i number\n   * @returns the upper case translation of the number i to hexadecimal.\n   */\n\n\n  static ToHex(i) {\n    const str = i.toString(16);\n\n    if (i <= 15) {\n      return (\"0\" + str).toUpperCase();\n    }\n\n    return str.toUpperCase();\n  }\n  /**\n   * Returns -1 if value is negative and +1 is value is positive.\n   * @param value the value\n   * @returns the value itself if it's equal to zero.\n   */\n\n\n  static Sign(value) {\n    value = +value; // convert to a number\n\n    if (value === 0 || isNaN(value)) {\n      return value;\n    }\n\n    return value > 0 ? 1 : -1;\n  }\n  /**\n   * Returns the value itself if it's between min and max.\n   * Returns min if the value is lower than min.\n   * Returns max if the value is greater than max.\n   * @param value the value to clmap\n   * @param min the min value to clamp to (default: 0)\n   * @param max the max value to clamp to (default: 1)\n   * @returns the clamped value\n   */\n\n\n  static Clamp(value, min = 0, max = 1) {\n    return Math.min(max, Math.max(min, value));\n  }\n  /**\n   * the log2 of value.\n   * @param value the value to compute log2 of\n   * @returns the log2 of value.\n   */\n\n\n  static Log2(value) {\n    return Math.log(value) * Math.LOG2E;\n  }\n  /**\n   * the floor part of a log2 value.\n   * @param value the value to compute log2 of\n   * @returns the log2 of value.\n   */\n\n\n  static ILog2(value) {\n    if (Math.log2) {\n      return Math.floor(Math.log2(value));\n    }\n\n    if (value < 0) {\n      return NaN;\n    } else if (value === 0) {\n      return -Infinity;\n    }\n\n    let n = 0;\n\n    if (value < 1) {\n      while (value < 1) {\n        n++;\n        value = value * 2;\n      }\n\n      n = -n;\n    } else if (value > 1) {\n      while (value > 1) {\n        n++;\n        value = Math.floor(value / 2);\n      }\n    }\n\n    return n;\n  }\n  /**\n   * Loops the value, so that it is never larger than length and never smaller than 0.\n   *\n   * This is similar to the modulo operator but it works with floating point numbers.\n   * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\n   * With t = 5 and length = 2.5, the result would be 0.0.\n   * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\n   * @param value the value\n   * @param length the length\n   * @returns the looped value\n   */\n\n\n  static Repeat(value, length) {\n    return value - Math.floor(value / length) * length;\n  }\n  /**\n   * Normalize the value between 0.0 and 1.0 using min and max values\n   * @param value value to normalize\n   * @param min max to normalize between\n   * @param max min to normalize between\n   * @returns the normalized value\n   */\n\n\n  static Normalize(value, min, max) {\n    return (value - min) / (max - min);\n  }\n  /**\n   * Denormalize the value from 0.0 and 1.0 using min and max values\n   * @param normalized value to denormalize\n   * @param min max to denormalize between\n   * @param max min to denormalize between\n   * @returns the denormalized value\n   */\n\n\n  static Denormalize(normalized, min, max) {\n    return normalized * (max - min) + min;\n  }\n  /**\n   * Calculates the shortest difference between two given angles given in degrees.\n   * @param current current angle in degrees\n   * @param target target angle in degrees\n   * @returns the delta\n   */\n\n\n  static DeltaAngle(current, target) {\n    let num = Scalar.Repeat(target - current, 360.0);\n\n    if (num > 180.0) {\n      num -= 360.0;\n    }\n\n    return num;\n  }\n  /**\n   * PingPongs the value t, so that it is never larger than length and never smaller than 0.\n   * @param tx value\n   * @param length length\n   * @returns The returned value will move back and forth between 0 and length\n   */\n\n\n  static PingPong(tx, length) {\n    const t = Scalar.Repeat(tx, length * 2.0);\n    return length - Math.abs(t - length);\n  }\n  /**\n   * Interpolates between min and max with smoothing at the limits.\n   *\n   * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\n   * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\n   * @param from from\n   * @param to to\n   * @param tx value\n   * @returns the smooth stepped value\n   */\n\n\n  static SmoothStep(from, to, tx) {\n    let t = Scalar.Clamp(tx);\n    t = -2.0 * t * t * t + 3.0 * t * t;\n    return to * t + from * (1.0 - t);\n  }\n  /**\n   * Moves a value current towards target.\n   *\n   * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\n   * Negative values of maxDelta pushes the value away from target.\n   * @param current current value\n   * @param target target value\n   * @param maxDelta max distance to move\n   * @returns resulting value\n   */\n\n\n  static MoveTowards(current, target, maxDelta) {\n    let result = 0;\n\n    if (Math.abs(target - current) <= maxDelta) {\n      result = target;\n    } else {\n      result = current + Scalar.Sign(target - current) * maxDelta;\n    }\n\n    return result;\n  }\n  /**\n   * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\n   *\n   * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\n   *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\n   * @param current current value\n   * @param target target value\n   * @param maxDelta max distance to move\n   * @returns resulting angle\n   */\n\n\n  static MoveTowardsAngle(current, target, maxDelta) {\n    const num = Scalar.DeltaAngle(current, target);\n    let result = 0;\n\n    if (-maxDelta < num && num < maxDelta) {\n      result = target;\n    } else {\n      target = current + num;\n      result = Scalar.MoveTowards(current, target, maxDelta);\n    }\n\n    return result;\n  }\n  /**\n   * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\n   * @param start start value\n   * @param end target value\n   * @param amount amount to lerp between\n   * @returns the lerped value\n   */\n\n\n  static Lerp(start, end, amount) {\n    return start + (end - start) * amount;\n  }\n  /**\n   * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\n   * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\n   * @param start start value\n   * @param end target value\n   * @param amount amount to lerp between\n   * @returns the lerped value\n   */\n\n\n  static LerpAngle(start, end, amount) {\n    let num = Scalar.Repeat(end - start, 360.0);\n\n    if (num > 180.0) {\n      num -= 360.0;\n    }\n\n    return start + num * Scalar.Clamp(amount);\n  }\n  /**\n   * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\n   * @param a start value\n   * @param b target value\n   * @param value value between a and b\n   * @returns the inverseLerp value\n   */\n\n\n  static InverseLerp(a, b, value) {\n    let result = 0;\n\n    if (a != b) {\n      result = Scalar.Clamp((value - a) / (b - a));\n    } else {\n      result = 0.0;\n    }\n\n    return result;\n  }\n  /**\n   * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\n   * @see http://mathworld.wolfram.com/HermitePolynomial.html\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param amount defines the amount on the interpolation spline (between 0 and 1)\n   * @returns hermite result\n   */\n\n\n  static Hermite(value1, tangent1, value2, tangent2, amount) {\n    const squared = amount * amount;\n    const cubed = amount * squared;\n    const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n    const part2 = -2.0 * cubed + 3.0 * squared;\n    const part3 = cubed - 2.0 * squared + amount;\n    const part4 = cubed - squared;\n    return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\n  }\n  /**\n   * Returns a new scalar which is the 1st derivative of the Hermite spline defined by the scalars \"value1\", \"value2\", \"tangent1\", \"tangent2\".\n   * @param value1 defines the first control point\n   * @param tangent1 defines the first tangent\n   * @param value2 defines the second control point\n   * @param tangent2 defines the second tangent\n   * @param time define where the derivative must be done\n   * @returns 1st derivative\n   */\n\n\n  static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {\n    const t2 = time * time;\n    return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;\n  }\n  /**\n   * Returns a random float number between and min and max values\n   * @param min min value of random\n   * @param max max value of random\n   * @returns random value\n   */\n\n\n  static RandomRange(min, max) {\n    if (min === max) {\n      return min;\n    }\n\n    return Math.random() * (max - min) + min;\n  }\n  /**\n   * This function returns percentage of a number in a given range.\n   *\n   * RangeToPercent(40,20,60) will return 0.5 (50%)\n   * RangeToPercent(34,0,100) will return 0.34 (34%)\n   * @param number to convert to percentage\n   * @param min min range\n   * @param max max range\n   * @returns the percentage\n   */\n\n\n  static RangeToPercent(number, min, max) {\n    return (number - min) / (max - min);\n  }\n  /**\n   * This function returns number that corresponds to the percentage in a given range.\n   *\n   * PercentToRange(0.34,0,100) will return 34.\n   * @param percent to convert to number\n   * @param min min range\n   * @param max max range\n   * @returns the number\n   */\n\n\n  static PercentToRange(percent, min, max) {\n    return (max - min) * percent + min;\n  }\n  /**\n   * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\n   * @param angle The angle to normalize in radian.\n   * @returns The converted angle.\n   */\n\n\n  static NormalizeRadians(angle) {\n    // More precise but slower version kept for reference.\n    // angle = angle % Tools.TwoPi;\n    // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\n    //if (angle > Math.PI) {\n    //\tangle -= Tools.TwoPi;\n    //}\n    angle -= Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi);\n    return angle;\n  }\n  /**\n   * Returns the highest common factor of two integers.\n   * @param a first parameter\n   * @param b second parameter\n   * @returns HCF of a and b\n   */\n\n\n  static HCF(a, b) {\n    const r = a % b;\n\n    if (r === 0) {\n      return b;\n    }\n\n    return Scalar.HCF(b, r);\n  }\n\n}\n/**\n * Two pi constants convenient for computation.\n */\n\n\nexports.Scalar = Scalar;\nScalar.TwoPi = Math.PI * 2;\n};"],
"names":["shadow$provide","global","require","module","exports","Object","defineProperty","value","Scalar","WithinEpsilon","a","b","epsilon","Math","abs","ToHex","i","str","toString","toUpperCase","Sign","isNaN","Clamp","min","max","Log2","log","LOG2E","ILog2","log2","floor","NaN","Infinity","n","Repeat","length","Normalize","Denormalize","normalized","DeltaAngle","current","target","num","PingPong","tx","t","SmoothStep","from","to","MoveTowards","maxDelta","result","MoveTowardsAngle","Lerp","start","end","amount","LerpAngle","InverseLerp","Hermite","value1","tangent1","value2","tangent2","squared","cubed","Hermite1stDerivative","time","t2","RandomRange","random","RangeToPercent","number","PercentToRange","percent","NormalizeRadians","angle","TwoPi","PI","HCF","r"]
}
