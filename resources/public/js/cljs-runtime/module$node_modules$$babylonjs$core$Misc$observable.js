shadow$provide.module$node_modules$$babylonjs$core$Misc$observable=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.Observable=exports.Observer=exports.EventState=void 0;class EventState{constructor(mask,skipNextObservers=!1,target,currentTarget){this.initialize(mask,skipNextObservers,target,currentTarget)}initialize(mask,skipNextObservers=!1,target,currentTarget){this.mask=mask;this.skipNextObservers=skipNextObservers;this.target=target;this.currentTarget=
currentTarget;return this}}exports.EventState=EventState;class Observer{constructor(callback,mask,scope=null){this.callback=callback;this.mask=mask;this.scope=scope;this.unregisterOnNextCall=this._willBeUnregistered=!1;this._remove=null}remove(){this._remove&&this._remove()}}exports.Observer=Observer;class Observable{static FromPromise(promise,onErrorObservable){const observable=new Observable;promise.then(ret=>{observable.notifyObservers(ret)}).catch(err=>{if(onErrorObservable)onErrorObservable.notifyObservers(err);
else throw err;});return observable}get observers(){return this._observers}constructor(onObserverAdded,notifyIfTriggered=!1){this.notifyIfTriggered=notifyIfTriggered;this._observers=[];this._numObserversMarkedAsDeleted=0;this._hasNotified=!1;this._eventState=new EventState(0);onObserverAdded&&(this._onObserverAdded=onObserverAdded)}add(callback,mask=-1,insertFirst=!1,scope=null,unregisterOnFirstCall=!1){if(!callback)return null;const observer=new Observer(callback,mask,scope);observer.unregisterOnNextCall=
unregisterOnFirstCall;insertFirst?this._observers.unshift(observer):this._observers.push(observer);this._onObserverAdded&&this._onObserverAdded(observer);this._hasNotified&&this.notifyIfTriggered&&void 0!==this._lastNotifiedValue&&this.notifyObserver(observer,this._lastNotifiedValue);observer._remove=()=>{this.remove(observer)};return observer}addOnce(callback){return this.add(callback,void 0,void 0,void 0,!0)}remove(observer){if(!observer)return!1;observer._remove=null;return-1!==this._observers.indexOf(observer)?
(this._deferUnregister(observer),!0):!1}removeCallback(callback,scope){for(let index=0;index<this._observers.length;index++){const observer=this._observers[index];if(!(observer._willBeUnregistered||observer.callback!==callback||scope&&scope!==observer.scope))return this._deferUnregister(observer),!0}return!1}_deferUnregister(observer){observer._willBeUnregistered||(this._numObserversMarkedAsDeleted++,observer.unregisterOnNextCall=!1,observer._willBeUnregistered=!0,setTimeout(()=>{this._remove(observer)},
0))}_remove(observer,updateCounter=!0){if(!observer)return!1;observer=this._observers.indexOf(observer);return-1!==observer?(updateCounter&&this._numObserversMarkedAsDeleted--,this._observers.splice(observer,1),!0):!1}makeObserverTopPriority(observer){this._remove(observer,!1);this._observers.unshift(observer)}makeObserverBottomPriority(observer){this._remove(observer,!1);this._observers.push(observer)}notifyObservers(eventData,mask=-1,target,currentTarget,userInfo){this.notifyIfTriggered&&(this._hasNotified=
!0,this._lastNotifiedValue=eventData);if(!this._observers.length)return!0;const state=this._eventState;state.mask=mask;state.target=target;state.currentTarget=currentTarget;state.skipNextObservers=!1;state.lastReturnValue=eventData;state.userInfo=userInfo;for(const obs of this._observers)if(!obs._willBeUnregistered&&(obs.mask&mask&&(obs.unregisterOnNextCall&&this._deferUnregister(obs),state.lastReturnValue=obs.scope?obs.callback.apply(obs.scope,[eventData,state]):obs.callback(eventData,state)),state.skipNextObservers))return!1;
return!0}notifyObserver(observer,eventData,mask=-1){this.notifyIfTriggered&&(this._hasNotified=!0,this._lastNotifiedValue=eventData);if(!observer._willBeUnregistered){var state=this._eventState;state.mask=mask;state.skipNextObservers=!1;observer.unregisterOnNextCall&&this._deferUnregister(observer);observer.callback(eventData,state)}}hasObservers(){return 0<this._observers.length-this._numObserversMarkedAsDeleted}clear(){for(;this._observers.length;){const o=this._observers.pop();o&&(o._remove=null)}this._onObserverAdded=
null;this._numObserversMarkedAsDeleted=0;this.cleanLastNotifiedState()}cleanLastNotifiedState(){this._hasNotified=!1;this._lastNotifiedValue=void 0}clone(){const result=new Observable;result._observers=this._observers.slice(0);return result}hasSpecificMask(mask=-1){for(const obs of this._observers)if(obs.mask&mask||obs.mask===mask)return!0;return!1}}exports.Observable=Observable}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Misc$observable.js.map
