shadow$provide.module$node_modules$$babylonjs$core$Misc$arrayTools=function(global,require,module,exports){function _observeArrayfunction(object,functionName,callback){const oldFunction=object[functionName];if("function"!==typeof oldFunction)return null;const newFunction=function(){const previousLength=object.length,returnValue=newFunction.previous.apply(object,arguments);callback(functionName,previousLength);return returnValue};oldFunction.next=newFunction;newFunction.previous=oldFunction;object[functionName]=
newFunction;return()=>{const previous=newFunction.previous;if(previous){var next=newFunction.next;next?(previous.next=next,next.previous=previous):(previous.next=void 0,object[functionName]=previous);newFunction.next=void 0;newFunction.previous=void 0}}}Object.defineProperty(exports,"__esModule",{value:!0});exports._ObserveArray=function(array,callback){const unObserveFunctions=observedArrayFunctions.map(name=>_observeArrayfunction(array,name,callback));return()=>{unObserveFunctions.forEach(unObserveFunction=>
{null===unObserveFunction||void 0===unObserveFunction?void 0:unObserveFunction()})}};exports.ArrayTools=void 0;class ArrayTools{static BuildArray(size,itemBuilder){const a=[];for(let i=0;i<size;++i)a.push(itemBuilder());return a}static BuildTuple(size,itemBuilder){return ArrayTools.BuildArray(size,itemBuilder)}}exports.ArrayTools=ArrayTools;const observedArrayFunctions=["push","splice","pop","shift","unshift"]}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Misc$arrayTools.js.map
