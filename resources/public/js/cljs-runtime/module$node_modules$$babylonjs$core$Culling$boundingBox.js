shadow$provide.module$node_modules$$babylonjs$core$Culling$boundingBox=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.BoundingBox=void 0;var _arrayTools=require("module$node_modules$$babylonjs$core$Misc$arrayTools"),_mathVector=require("module$node_modules$$babylonjs$core$Maths$math_vector"),_mathConstants=require("module$node_modules$$babylonjs$core$Maths$math_constants");class BoundingBox{constructor(min,max,worldMatrix){this.vectors=_arrayTools.ArrayTools.BuildArray(8,
_mathVector.Vector3.Zero);this.center=_mathVector.Vector3.Zero();this.centerWorld=_mathVector.Vector3.Zero();this.extendSize=_mathVector.Vector3.Zero();this.extendSizeWorld=_mathVector.Vector3.Zero();this.directions=_arrayTools.ArrayTools.BuildArray(3,_mathVector.Vector3.Zero);this.vectorsWorld=_arrayTools.ArrayTools.BuildArray(8,_mathVector.Vector3.Zero);this.minimumWorld=_mathVector.Vector3.Zero();this.maximumWorld=_mathVector.Vector3.Zero();this.minimum=_mathVector.Vector3.Zero();this.maximum=
_mathVector.Vector3.Zero();this._drawWrapperBack=this._drawWrapperFront=null;this.reConstruct(min,max,worldMatrix)}reConstruct(min,max,worldMatrix){const minX=min.x,minY=min.y,minZ=min.z,maxX=max.x,maxY=max.y,maxZ=max.z,vectors=this.vectors;this.minimum.copyFromFloats(minX,minY,minZ);this.maximum.copyFromFloats(maxX,maxY,maxZ);vectors[0].copyFromFloats(minX,minY,minZ);vectors[1].copyFromFloats(maxX,maxY,maxZ);vectors[2].copyFromFloats(maxX,minY,minZ);vectors[3].copyFromFloats(minX,maxY,minZ);vectors[4].copyFromFloats(minX,
minY,maxZ);vectors[5].copyFromFloats(maxX,maxY,minZ);vectors[6].copyFromFloats(minX,maxY,maxZ);vectors[7].copyFromFloats(maxX,minY,maxZ);max.addToRef(min,this.center).scaleInPlace(.5);max.subtractToRef(min,this.extendSize).scaleInPlace(.5);this._worldMatrix=worldMatrix||_mathVector.Matrix.IdentityReadOnly;this._update(this._worldMatrix)}scale(factor){var tmpVectors=BoundingBox._TmpVector3,diff=this.maximum.subtractToRef(this.minimum,tmpVectors[0]);const len=diff.length();diff.normalizeFromLength(len);
diff=diff.scaleInPlace(len*factor*.5);factor=this.center.subtractToRef(diff,tmpVectors[1]);tmpVectors=this.center.addToRef(diff,tmpVectors[2]);this.reConstruct(factor,tmpVectors,this._worldMatrix);return this}getWorldMatrix(){return this._worldMatrix}_update(world){var minWorld=this.minimumWorld;const maxWorld=this.maximumWorld,directions=this.directions,vectorsWorld=this.vectorsWorld,vectors=this.vectors;if(world.isIdentity()){minWorld.copyFrom(this.minimum);maxWorld.copyFrom(this.maximum);for(minWorld=
0;8>minWorld;++minWorld)vectorsWorld[minWorld].copyFrom(vectors[minWorld]);this.extendSizeWorld.copyFrom(this.extendSize);this.centerWorld.copyFrom(this.center)}else{minWorld.setAll(Number.MAX_VALUE);maxWorld.setAll(-Number.MAX_VALUE);for(let index=0;8>index;++index){const v=vectorsWorld[index];_mathVector.Vector3.TransformCoordinatesToRef(vectors[index],world,v);minWorld.minimizeInPlace(v);maxWorld.maximizeInPlace(v)}maxWorld.subtractToRef(minWorld,this.extendSizeWorld).scaleInPlace(.5);maxWorld.addToRef(minWorld,
this.centerWorld).scaleInPlace(.5)}_mathVector.Vector3.FromArrayToRef(world.m,0,directions[0]);_mathVector.Vector3.FromArrayToRef(world.m,4,directions[1]);_mathVector.Vector3.FromArrayToRef(world.m,8,directions[2]);this._worldMatrix=world}isInFrustum(frustumPlanes){return BoundingBox.IsInFrustum(this.vectorsWorld,frustumPlanes)}isCompletelyInFrustum(frustumPlanes){return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld,frustumPlanes)}intersectsPoint(point){var min=this.minimumWorld;const max=this.maximumWorld,
minX=min.x,minY=min.y;min=min.z;const pointX=point.x,pointY=point.y;point=point.z;const delta=-_mathConstants.Epsilon;return max.x-pointX<delta||delta>pointX-minX||max.y-pointY<delta||delta>pointY-minY||max.z-point<delta||delta>point-min?!1:!0}intersectsSphere(sphere){return BoundingBox.IntersectsSphere(this.minimumWorld,this.maximumWorld,sphere.centerWorld,sphere.radiusWorld)}intersectsMinMax(min,max){var myMin=this.minimumWorld;const myMax=this.maximumWorld,myMinX=myMin.x,myMinY=myMin.y;myMin=myMin.z;
const maxX=max.x,maxY=max.y;max=max.z;return myMax.x<min.x||myMinX>maxX||myMax.y<min.y||myMinY>maxY||myMax.z<min.z||myMin>max?!1:!0}dispose(){var _a,_b;null===(_a=this._drawWrapperFront)||void 0===_a?void 0:_a.dispose();null===(_b=this._drawWrapperBack)||void 0===_b?void 0:_b.dispose()}static Intersects(box0,box1){return box0.intersectsMinMax(box1.minimumWorld,box1.maximumWorld)}static IntersectsSphere(minPoint,maxPoint,sphereCenter,sphereRadius){const vector=BoundingBox._TmpVector3[0];_mathVector.Vector3.ClampToRef(sphereCenter,
minPoint,maxPoint,vector);return _mathVector.Vector3.DistanceSquared(sphereCenter,vector)<=sphereRadius*sphereRadius}static IsCompletelyInFrustum(boundingVectors,frustumPlanes){for(let p=0;6>p;++p){const frustumPlane=frustumPlanes[p];for(let i=0;8>i;++i)if(0>frustumPlane.dotCoordinate(boundingVectors[i]))return!1}return!0}static IsInFrustum(boundingVectors,frustumPlanes){for(let p=0;6>p;++p){let canReturnFalse=!0;const frustumPlane=frustumPlanes[p];for(let i=0;8>i;++i)if(0<=frustumPlane.dotCoordinate(boundingVectors[i])){canReturnFalse=
!1;break}if(canReturnFalse)return!1}return!0}}exports.BoundingBox=BoundingBox;BoundingBox._TmpVector3=_arrayTools.ArrayTools.BuildArray(3,_mathVector.Vector3.Zero)}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Culling$boundingBox.js.map
