shadow$provide.module$node_modules$$babylonjs$core$Collisions$pickingInfo=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.PickingInfo=void 0;var _mathVector=require("module$node_modules$$babylonjs$core$Maths$math_vector"),_buffer=require("module$node_modules$$babylonjs$core$Buffers$buffer");class PickingInfo{constructor(){this.hit=!1;this.distance=0;this.pickedMesh=this.pickedPoint=null;this.bv=this.bu=0;this.subMeshFaceId=this.faceId=-1;this.subMeshId=
0;this.pickedSprite=null;this.thinInstanceIndex=-1;this.gripTransform=this.aimTransform=this.originMesh=this.ray=null}getNormal(useWorldCoordinates=!1,useVerticesNormals=!0){if(!this.pickedMesh||useVerticesNormals&&!this.pickedMesh.isVerticesDataPresent(_buffer.VertexBuffer.NormalKind))return null;var indices=this.pickedMesh.getIndices();0===(null===indices||void 0===indices?void 0:indices.length)&&(indices=null);var tmp0=_mathVector.TmpVectors.Vector3[0],tmp1=_mathVector.TmpVectors.Vector3[1],tmp2=
_mathVector.TmpVectors.Vector3[2];useVerticesNormals?(useVerticesNormals=this.pickedMesh.getVerticesData(_buffer.VertexBuffer.NormalKind),tmp0=indices?_mathVector.Vector3.FromArrayToRef(useVerticesNormals,3*indices[3*this.faceId],tmp0):tmp0.copyFromFloats(useVerticesNormals[9*this.faceId],useVerticesNormals[9*this.faceId+1],useVerticesNormals[9*this.faceId+2]),tmp1=indices?_mathVector.Vector3.FromArrayToRef(useVerticesNormals,3*indices[3*this.faceId+1],tmp1):tmp1.copyFromFloats(useVerticesNormals[3*
(3*this.faceId+1)],useVerticesNormals[3*(3*this.faceId+1)+1],useVerticesNormals[3*(3*this.faceId+1)+2]),indices=indices?_mathVector.Vector3.FromArrayToRef(useVerticesNormals,3*indices[3*this.faceId+2],tmp2):tmp2.copyFromFloats(useVerticesNormals[3*(3*this.faceId+2)],useVerticesNormals[3*(3*this.faceId+2)+1],useVerticesNormals[3*(3*this.faceId+2)+2]),tmp0=tmp0.scale(this.bu),tmp1=tmp1.scale(this.bv),indices=indices.scale(1-this.bu-this.bv),indices=new _mathVector.Vector3(tmp0.x+tmp1.x+indices.x,tmp0.y+
tmp1.y+indices.y,tmp0.z+tmp1.z+indices.z)):(useVerticesNormals=this.pickedMesh.getVerticesData(_buffer.VertexBuffer.PositionKind),tmp0=indices?_mathVector.Vector3.FromArrayToRef(useVerticesNormals,3*indices[3*this.faceId],tmp0):tmp0.copyFromFloats(useVerticesNormals[9*this.faceId],useVerticesNormals[9*this.faceId+1],useVerticesNormals[9*this.faceId+2]),tmp1=indices?_mathVector.Vector3.FromArrayToRef(useVerticesNormals,3*indices[3*this.faceId+1],tmp1):tmp1.copyFromFloats(useVerticesNormals[3*(3*this.faceId+
1)],useVerticesNormals[3*(3*this.faceId+1)+1],useVerticesNormals[3*(3*this.faceId+1)+2]),indices=indices?_mathVector.Vector3.FromArrayToRef(useVerticesNormals,3*indices[3*this.faceId+2],tmp2):tmp2.copyFromFloats(useVerticesNormals[3*(3*this.faceId+2)],useVerticesNormals[3*(3*this.faceId+2)+1],useVerticesNormals[3*(3*this.faceId+2)+2]),tmp2=tmp0.subtract(tmp1),indices=indices.subtract(tmp1),indices=_mathVector.Vector3.Cross(tmp2,indices));tmp2=(pickedMesh,n)=>{let wm=pickedMesh.getWorldMatrix();pickedMesh.nonUniformScaling&&
(_mathVector.TmpVectors.Matrix[0].copyFrom(wm),wm=_mathVector.TmpVectors.Matrix[0],wm.setTranslationFromFloats(0,0,0),wm.invert(),wm.transposeToRef(_mathVector.TmpVectors.Matrix[1]),wm=_mathVector.TmpVectors.Matrix[1]);_mathVector.Vector3.TransformNormalToRef(n,wm,n)};useWorldCoordinates&&tmp2(this.pickedMesh,indices);this.ray&&(tmp1=_mathVector.TmpVectors.Vector3[0].copyFrom(indices),useWorldCoordinates||tmp2(this.pickedMesh,tmp1),0<_mathVector.Vector3.Dot(tmp1,this.ray.direction)&&indices.negateInPlace());
indices.normalize();return indices}getTextureCoordinates(uvSet=_buffer.VertexBuffer.UVKind){if(!this.pickedMesh||!this.pickedMesh.isVerticesDataPresent(uvSet))return null;var indices=this.pickedMesh.getIndices();if(!indices)return null;const uvs=this.pickedMesh.getVerticesData(uvSet);if(!uvs)return null;uvSet=_mathVector.Vector2.FromArray(uvs,2*indices[3*this.faceId]);let uv1=_mathVector.Vector2.FromArray(uvs,2*indices[3*this.faceId+1]);indices=_mathVector.Vector2.FromArray(uvs,2*indices[3*this.faceId+
2]);uvSet=uvSet.scale(this.bu);uv1=uv1.scale(this.bv);indices=indices.scale(1-this.bu-this.bv);return new _mathVector.Vector2(uvSet.x+uv1.x+indices.x,uvSet.y+uv1.y+indices.y)}}exports.PickingInfo=PickingInfo}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Collisions$pickingInfo.js.map
