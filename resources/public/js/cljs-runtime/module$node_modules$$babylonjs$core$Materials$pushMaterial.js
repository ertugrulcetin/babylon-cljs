shadow$provide.module$node_modules$$babylonjs$core$Materials$pushMaterial=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.PushMaterial=void 0;var _mathVector=require("module$node_modules$$babylonjs$core$Maths$math_vector");global=require("module$node_modules$$babylonjs$core$Materials$material");class PushMaterial extends global.Material{constructor(name,scene,storeEffectOnSubMeshes=!0){super(name,scene);this._normalMatrix=new _mathVector.Matrix;
this._storeEffectOnSubMeshes=storeEffectOnSubMeshes}getEffect(){return this._storeEffectOnSubMeshes?this._activeEffect:super.getEffect()}isReady(mesh,useInstances){return mesh?this._storeEffectOnSubMeshes&&mesh.subMeshes&&0!==mesh.subMeshes.length?this.isReadyForSubMesh(mesh,mesh.subMeshes[0],useInstances):!0:!1}_isReadyForSubMesh(subMesh){const defines=subMesh.materialDefines;return!this.checkReadyOnEveryCall&&subMesh.effect&&defines&&defines._renderId===this.getScene().getRenderId()?!0:!1}bindOnlyWorldMatrix(world){this._activeEffect.setMatrix("world",
world)}bindOnlyNormalMatrix(normalMatrix){this._activeEffect.setMatrix("normalMatrix",normalMatrix)}bind(world,mesh){mesh&&this.bindForSubMesh(world,mesh,mesh.subMeshes[0])}_afterBind(mesh,effect=null){super._afterBind(mesh,effect);if(this.getScene()._cachedEffect=effect)effect._forceRebindOnNextCall=!1}_mustRebind(scene,effect,visibility=1){return scene.isCachedMaterialInvalid(this,effect,visibility)}dispose(forceDisposeEffect,forceDisposeTextures,notBoundToMesh){this._activeEffect=void 0;super.dispose(forceDisposeEffect,
forceDisposeTextures,notBoundToMesh)}}exports.PushMaterial=PushMaterial}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Materials$pushMaterial.js.map
