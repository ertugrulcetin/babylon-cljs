shadow$provide.module$node_modules$$babylonjs$core$Maths$math_vector=function(global,require,module,exports){Object.defineProperty(exports,"__esModule",{value:!0});exports.TmpVectors=exports.Matrix=exports.Quaternion=exports.Vector4=exports.Vector3=exports.Vector2=void 0;var _mathScalar=require("module$node_modules$$babylonjs$core$Maths$math_scalar"),_mathConstants=require("module$node_modules$$babylonjs$core$Maths$math_constants");global=require("module$node_modules$$babylonjs$core$Misc$arrayTools");
module=require("module$node_modules$$babylonjs$core$Misc$typeStore");var _performanceConfigurator=require("module$node_modules$$babylonjs$core$Engines$performanceConfigurator"),_engineStore=require("module$node_modules$$babylonjs$core$Engines$engineStore");const _ExtractAsInt=value=>parseInt(value.toString().replace(/\W/g,""));class Vector2{constructor(x=0,y=0){this.x=x;this.y=y}toString(){return`{X: ${this.x} Y: ${this.y}}`}getClassName(){return"Vector2"}getHashCode(){const x=_ExtractAsInt(this.x),
y=_ExtractAsInt(this.y);return 397*x^y}toArray(array,index=0){array[index]=this.x;array[index+1]=this.y;return this}fromArray(array,index=0){Vector2.FromArrayToRef(array,index,this);return this}asArray(){const result=[];this.toArray(result,0);return result}copyFrom(source){this.x=source.x;this.y=source.y;return this}copyFromFloats(x,y){this.x=x;this.y=y;return this}set(x,y){return this.copyFromFloats(x,y)}add(otherVector){return new this.constructor(this.x+otherVector.x,this.y+otherVector.y)}addToRef(otherVector,
result){result.x=this.x+otherVector.x;result.y=this.y+otherVector.y;return result}addInPlace(otherVector){this.x+=otherVector.x;this.y+=otherVector.y;return this}addVector3(otherVector){return new this.constructor(this.x+otherVector.x,this.y+otherVector.y)}subtract(otherVector){return new this.constructor(this.x-otherVector.x,this.y-otherVector.y)}subtractToRef(otherVector,result){result.x=this.x-otherVector.x;result.y=this.y-otherVector.y;return result}subtractInPlace(otherVector){this.x-=otherVector.x;
this.y-=otherVector.y;return this}multiplyInPlace(otherVector){this.x*=otherVector.x;this.y*=otherVector.y;return this}multiply(otherVector){return new this.constructor(this.x*otherVector.x,this.y*otherVector.y)}multiplyToRef(otherVector,result){result.x=this.x*otherVector.x;result.y=this.y*otherVector.y;return result}multiplyByFloats(x,y){return new this.constructor(this.x*x,this.y*y)}divide(otherVector){return new this.constructor(this.x/otherVector.x,this.y/otherVector.y)}divideToRef(otherVector,
result){result.x=this.x/otherVector.x;result.y=this.y/otherVector.y;return result}divideInPlace(otherVector){return this.divideToRef(otherVector,this)}negate(){return new this.constructor(-this.x,-this.y)}negateInPlace(){this.x*=-1;this.y*=-1;return this}negateToRef(result){return result.copyFromFloats(-1*this.x,-1*this.y)}scaleInPlace(scale){this.x*=scale;this.y*=scale;return this}scale(scale){const result=new this.constructor(0,0);this.scaleToRef(scale,result);return result}scaleToRef(scale,result){result.x=
this.x*scale;result.y=this.y*scale;return result}scaleAndAddToRef(scale,result){result.x+=this.x*scale;result.y+=this.y*scale;return result}equals(otherVector){return otherVector&&this.x===otherVector.x&&this.y===otherVector.y}equalsWithEpsilon(otherVector,epsilon=_mathConstants.Epsilon){return otherVector&&_mathScalar.Scalar.WithinEpsilon(this.x,otherVector.x,epsilon)&&_mathScalar.Scalar.WithinEpsilon(this.y,otherVector.y,epsilon)}floor(){return new this.constructor(Math.floor(this.x),Math.floor(this.y))}fract(){return new this.constructor(this.x-
Math.floor(this.x),this.y-Math.floor(this.y))}rotateToRef(angle,result){const cos=Math.cos(angle);angle=Math.sin(angle);const y=angle*this.x+cos*this.y;result.x=cos*this.x-angle*this.y;result.y=y;return result}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}lengthSquared(){return this.x*this.x+this.y*this.y}normalize(){Vector2.NormalizeToRef(this,this);return this}clone(){return new this.constructor(this.x,this.y)}static Zero(){return new Vector2(0,0)}static One(){return new Vector2(1,1)}static Random(min=
0,max=1){return new Vector2(_mathScalar.Scalar.RandomRange(min,max),_mathScalar.Scalar.RandomRange(min,max))}static get ZeroReadOnly(){return Vector2._ZeroReadOnly}static FromArray(array,offset=0){return new Vector2(array[offset],array[offset+1])}static FromArrayToRef(array,offset,result){result.x=array[offset];result.y=array[offset+1];return result}static CatmullRom(value1,value2,value3,value4,amount){const squared=amount*amount,cubed=amount*squared;return new value1.constructor(.5*(2*value2.x+(-value1.x+
value3.x)*amount+(2*value1.x-5*value2.x+4*value3.x-value4.x)*squared+(-value1.x+3*value2.x-3*value3.x+value4.x)*cubed),.5*(2*value2.y+(-value1.y+value3.y)*amount+(2*value1.y-5*value2.y+4*value3.y-value4.y)*squared+(-value1.y+3*value2.y-3*value3.y+value4.y)*cubed))}static Clamp(value,min,max){let x=value.x;x=x>max.x?max.x:x;x=x<min.x?min.x:x;let y=value.y;y=y>max.y?max.y:y;y=y<min.y?min.y:y;return new value.constructor(x,y)}static Hermite(value1,tangent1,value2,tangent2,amount){var squared=amount*
amount;const cubed=amount*squared,part1=2*cubed-3*squared+1,part2=-2*cubed+3*squared;amount=cubed-2*squared+amount;squared=cubed-squared;return new value1.constructor(value1.x*part1+value2.x*part2+tangent1.x*amount+tangent2.x*squared,value1.y*part1+value2.y*part2+tangent1.y*amount+tangent2.y*squared)}static Hermite1stDerivative(value1,tangent1,value2,tangent2,time){const result=new value1.constructor;this.Hermite1stDerivativeToRef(value1,tangent1,value2,tangent2,time,result);return result}static Hermite1stDerivativeToRef(value1,
tangent1,value2,tangent2,time,result){const t2=time*time;result.x=6*(t2-time)*value1.x+(3*t2-4*time+1)*tangent1.x+6*(-t2+time)*value2.x+(3*t2-2*time)*tangent2.x;result.y=6*(t2-time)*value1.y+(3*t2-4*time+1)*tangent1.y+6*(-t2+time)*value2.y+(3*t2-2*time)*tangent2.y;return result}static Lerp(start,end,amount){return new start.constructor(start.x+(end.x-start.x)*amount,start.y+(end.y-start.y)*amount)}static Dot(left,right){return left.x*right.x+left.y*right.y}static Normalize(vector){const newVector=
new vector.constructor;this.NormalizeToRef(vector,newVector);return newVector}static NormalizeToRef(vector,result){const len=vector.length();if(0===len)return result;result.x=vector.x/len;result.y=vector.y/len;return result}static Minimize(left,right){return new left.constructor(left.x<right.x?left.x:right.x,left.y<right.y?left.y:right.y)}static Maximize(left,right){return new left.constructor(left.x>right.x?left.x:right.x,left.y>right.y?left.y:right.y)}static Transform(vector,transformation){const result=
new vector.constructor;Vector2.TransformToRef(vector,transformation,result);return result}static TransformToRef(vector,transformation,result){transformation=transformation.m;const y=vector.x*transformation[1]+vector.y*transformation[5]+transformation[13];result.x=vector.x*transformation[0]+vector.y*transformation[4]+transformation[12];result.y=y;return result}static PointInTriangle(p,p0,p1,p2){const a=.5*(-p1.y*p2.x+p0.y*(-p1.x+p2.x)+p0.x*(p1.y-p2.y)+p1.x*p2.y),sign=0>a?-1:1;p2=(p0.y*p2.x-p0.x*p2.y+
(p2.y-p0.y)*p.x+(p0.x-p2.x)*p.y)*sign;p=(p0.x*p1.y-p0.y*p1.x+(p0.y-p1.y)*p.x+(p1.x-p0.x)*p.y)*sign;return 0<p2&&0<p&&p2+p<2*a*sign}static Distance(value1,value2){return Math.sqrt(Vector2.DistanceSquared(value1,value2))}static DistanceSquared(value1,value2){const x=value1.x-value2.x;value1=value1.y-value2.y;return x*x+value1*value1}static Center(value1,value2){const result=new value1.constructor;return Vector2.CenterToRef(value1,value2,result)}static CenterToRef(value1,value2,ref){return ref.copyFromFloats((value1.x+
value2.x)/2,(value1.y+value2.y)/2)}static DistanceOfPointFromSegment(p,segA,segB){var l2=Vector2.DistanceSquared(segA,segB);if(0===l2)return Vector2.Distance(p,segA);segB=segB.subtract(segA);l2=Math.max(0,Math.min(1,Vector2.Dot(p.subtract(segA),segB)/l2));segA=segA.add(segB.multiplyByFloats(l2,l2));return Vector2.Distance(p,segA)}}exports.Vector2=Vector2;Vector2._ZeroReadOnly=Vector2.Zero();class Vector3{get x(){return this._x}set x(value){this._x=value;this._isDirty=!0}get y(){return this._y}set y(value){this._y=
value;this._isDirty=!0}get z(){return this._z}set z(value){this._z=value;this._isDirty=!0}constructor(x=0,y=0,z=0){this._isDirty=!0;this._x=x;this._y=y;this._z=z}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z}}`}getClassName(){return"Vector3"}getHashCode(){var x=_ExtractAsInt(this._x);const y=_ExtractAsInt(this._y),z=_ExtractAsInt(this._z);return x=397*(397*x^y)^z}asArray(){const result=[];this.toArray(result,0);return result}toArray(array,index=0){array[index]=this._x;array[index+1]=
this._y;array[index+2]=this._z;return this}fromArray(array,index=0){Vector3.FromArrayToRef(array,index,this);return this}toQuaternion(){return Quaternion.RotationYawPitchRoll(this._y,this._x,this._z)}addInPlace(otherVector){return this.addInPlaceFromFloats(otherVector._x,otherVector._y,otherVector._z)}addInPlaceFromFloats(x,y,z){this._x+=x;this._y+=y;this._z+=z;this._isDirty=!0;return this}add(otherVector){return new this.constructor(this._x+otherVector._x,this._y+otherVector._y,this._z+otherVector._z)}addToRef(otherVector,
result){return result.copyFromFloats(this._x+otherVector._x,this._y+otherVector._y,this._z+otherVector._z)}subtractInPlace(otherVector){this._x-=otherVector._x;this._y-=otherVector._y;this._z-=otherVector._z;this._isDirty=!0;return this}subtract(otherVector){return new this.constructor(this._x-otherVector._x,this._y-otherVector._y,this._z-otherVector._z)}subtractToRef(otherVector,result){return this.subtractFromFloatsToRef(otherVector._x,otherVector._y,otherVector._z,result)}subtractFromFloats(x,
y,z){return new this.constructor(this._x-x,this._y-y,this._z-z)}subtractFromFloatsToRef(x,y,z,result){return result.copyFromFloats(this._x-x,this._y-y,this._z-z)}negate(){return new this.constructor(-this._x,-this._y,-this._z)}negateInPlace(){this._x*=-1;this._y*=-1;this._z*=-1;this._isDirty=!0;return this}negateToRef(result){return result.copyFromFloats(-1*this._x,-1*this._y,-1*this._z)}scaleInPlace(scale){this._x*=scale;this._y*=scale;this._z*=scale;this._isDirty=!0;return this}scale(scale){return new this.constructor(this._x*
scale,this._y*scale,this._z*scale)}scaleToRef(scale,result){return result.copyFromFloats(this._x*scale,this._y*scale,this._z*scale)}getNormalToRef(result){const radius=this.length();let theta=Math.acos(this.y/radius);const phi=Math.atan2(this.z,this.x);theta=theta>Math.PI/2?theta-Math.PI/2:theta+Math.PI/2;result.set(radius*Math.sin(theta)*Math.cos(phi),radius*Math.cos(theta),radius*Math.sin(theta)*Math.sin(phi));return result}applyRotationQuaternionToRef(q,result){const ix=q._w*this._x+q._y*this._z-
q._z*this._y,iy=q._w*this._y+q._z*this._x-q._x*this._z,iz=q._w*this._z+q._x*this._y-q._y*this._x,iw=-q._x*this._x-q._y*this._y-q._z*this._z;result._x=ix*q._w+iw*-q._x+iy*-q._z-iz*-q._y;result._y=iy*q._w+iw*-q._y+iz*-q._x-ix*-q._z;result._z=iz*q._w+iw*-q._z+ix*-q._y-iy*-q._x;result._isDirty=!0;return result}applyRotationQuaternionInPlace(q){return this.applyRotationQuaternionToRef(q,this)}applyRotationQuaternion(q){return this.applyRotationQuaternionToRef(q,new this.constructor)}scaleAndAddToRef(scale,
result){return result.addInPlaceFromFloats(this._x*scale,this._y*scale,this._z*scale)}projectOnPlane(plane,origin){const result=new this.constructor;this.projectOnPlaneToRef(plane,origin,result);return result}projectOnPlaneToRef(plane,origin,result){var n=plane.normal;const d=plane.d;plane=MathTmp.Vector3[0];this.subtractToRef(origin,plane);plane.normalize();const denom=Vector3.Dot(plane,n);Math.abs(denom)<Math.pow(10,-10)?result.setAll(Infinity):(n=-(Vector3.Dot(origin,n)+d)/denom,n=plane.scaleInPlace(n),
origin.addToRef(n,result));return result}equals(otherVector){return otherVector&&this._x===otherVector._x&&this._y===otherVector._y&&this._z===otherVector._z}equalsWithEpsilon(otherVector,epsilon=_mathConstants.Epsilon){return otherVector&&_mathScalar.Scalar.WithinEpsilon(this._x,otherVector._x,epsilon)&&_mathScalar.Scalar.WithinEpsilon(this._y,otherVector._y,epsilon)&&_mathScalar.Scalar.WithinEpsilon(this._z,otherVector._z,epsilon)}equalsToFloats(x,y,z){return this._x===x&&this._y===y&&this._z===
z}multiplyInPlace(otherVector){this._x*=otherVector._x;this._y*=otherVector._y;this._z*=otherVector._z;this._isDirty=!0;return this}multiply(otherVector){return this.multiplyByFloats(otherVector._x,otherVector._y,otherVector._z)}multiplyToRef(otherVector,result){return result.copyFromFloats(this._x*otherVector._x,this._y*otherVector._y,this._z*otherVector._z)}multiplyByFloats(x,y,z){return new this.constructor(this._x*x,this._y*y,this._z*z)}divide(otherVector){return new this.constructor(this._x/
otherVector._x,this._y/otherVector._y,this._z/otherVector._z)}divideToRef(otherVector,result){return result.copyFromFloats(this._x/otherVector._x,this._y/otherVector._y,this._z/otherVector._z)}divideInPlace(otherVector){return this.divideToRef(otherVector,this)}minimizeInPlace(other){return this.minimizeInPlaceFromFloats(other._x,other._y,other._z)}maximizeInPlace(other){return this.maximizeInPlaceFromFloats(other._x,other._y,other._z)}minimizeInPlaceFromFloats(x,y,z){x<this._x&&(this.x=x);y<this._y&&
(this.y=y);z<this._z&&(this.z=z);return this}maximizeInPlaceFromFloats(x,y,z){x>this._x&&(this.x=x);y>this._y&&(this.y=y);z>this._z&&(this.z=z);return this}isNonUniformWithinEpsilon(epsilon){const absX=Math.abs(this._x),absY=Math.abs(this._y);if(!_mathScalar.Scalar.WithinEpsilon(absX,absY,epsilon))return!0;const absZ=Math.abs(this._z);return _mathScalar.Scalar.WithinEpsilon(absX,absZ,epsilon)&&_mathScalar.Scalar.WithinEpsilon(absY,absZ,epsilon)?!1:!0}get isNonUniform(){const absX=Math.abs(this._x);
return absX!==Math.abs(this._y)||absX!==Math.abs(this._z)?!0:!1}floor(){return new this.constructor(Math.floor(this._x),Math.floor(this._y),Math.floor(this._z))}fract(){return new this.constructor(this._x-Math.floor(this._x),this._y-Math.floor(this._y),this._z-Math.floor(this._z))}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z)}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z}get hasAZeroComponent(){return 0===this._x*this._y*this._z}normalize(){return this.normalizeFromLength(this.length())}reorderInPlace(order){order=
order.toLowerCase();if("xyz"===order)return this;MathTmp.Vector3[0].copyFrom(this);["x","y","z"].forEach((val,i)=>{this[val]=MathTmp.Vector3[0][order[i]]});return this}rotateByQuaternionToRef(quaternion,result){quaternion.toRotationMatrix(MathTmp.Matrix[0]);Vector3.TransformCoordinatesToRef(this,MathTmp.Matrix[0],result);return result}rotateByQuaternionAroundPointToRef(quaternion,point,result){this.subtractToRef(point,MathTmp.Vector3[0]);MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion,MathTmp.Vector3[0]);
point.addToRef(MathTmp.Vector3[0],result);return result}cross(other){const result=new this.constructor;return Vector3.CrossToRef(this,other,result)}normalizeFromLength(len){return 0===len||1===len?this:this.scaleInPlace(1/len)}normalizeToNew(){const normalized=new this.constructor(0,0,0);this.normalizeToRef(normalized);return normalized}normalizeToRef(reference){const len=this.length();return 0===len||1===len?reference.copyFromFloats(this._x,this._y,this._z):this.scaleToRef(1/len,reference)}clone(){return new this.constructor(this._x,
this._y,this._z)}copyFrom(source){return this.copyFromFloats(source._x,source._y,source._z)}copyFromFloats(x,y,z){this._x=x;this._y=y;this._z=z;this._isDirty=!0;return this}set(x,y,z){return this.copyFromFloats(x,y,z)}setAll(v){this._x=this._y=this._z=v;this._isDirty=!0;return this}static GetClipFactor(vector0,vector1,axis,size){vector0=Vector3.Dot(vector0,axis)-size;vector1=Vector3.Dot(vector1,axis)-size;return vector0/(vector0-vector1)}static GetAngleBetweenVectors(vector0,vector1,normal){vector0=
vector0.normalizeToRef(MathTmp.Vector3[1]);vector1=vector1.normalizeToRef(MathTmp.Vector3[2]);let dot=Vector3.Dot(vector0,vector1);dot=_mathScalar.Scalar.Clamp(dot,-1,1);const angle=Math.acos(dot),n=MathTmp.Vector3[3];Vector3.CrossToRef(vector0,vector1,n);return 0<Vector3.Dot(n,normal)?isNaN(angle)?0:angle:isNaN(angle)?-Math.PI:-Math.acos(dot)}static GetAngleBetweenVectorsOnPlane(vector0,vector1,normal){MathTmp.Vector3[0].copyFrom(vector0);vector0=MathTmp.Vector3[0];MathTmp.Vector3[1].copyFrom(vector1);
vector1=MathTmp.Vector3[1];MathTmp.Vector3[2].copyFrom(normal);normal=MathTmp.Vector3[2];const right=MathTmp.Vector3[3],forward=MathTmp.Vector3[4];vector0.normalize();vector1.normalize();normal.normalize();Vector3.CrossToRef(normal,vector0,right);Vector3.CrossToRef(right,normal,forward);vector0=Math.atan2(Vector3.Dot(vector1,right),Vector3.Dot(vector1,forward));return _mathScalar.Scalar.NormalizeRadians(vector0)}static PitchYawRollToMoveBetweenPointsToRef(start,target,ref){const diff=TmpVectors.Vector3[0];
target.subtractToRef(start,diff);ref._y=Math.atan2(diff.x,diff.z)||0;ref._x=Math.atan2(Math.sqrt(diff.x**2+diff.z**2),diff.y)||0;ref._z=0;ref._isDirty=!0;return ref}static PitchYawRollToMoveBetweenPoints(start,target){const ref=Vector3.Zero();return Vector3.PitchYawRollToMoveBetweenPointsToRef(start,target,ref)}static SlerpToRef(vector0,vector1,slerp,result){slerp=_mathScalar.Scalar.Clamp(slerp,0,1);const vector0Dir=MathTmp.Vector3[0],vector1Dir=MathTmp.Vector3[1];vector0Dir.copyFrom(vector0);vector0=
vector0Dir.length();vector0Dir.normalizeFromLength(vector0);vector1Dir.copyFrom(vector1);vector1=vector1Dir.length();vector1Dir.normalizeFromLength(vector1);var dot=Vector3.Dot(vector0Dir,vector1Dir);if(dot<1-_mathConstants.Epsilon){var scale1=Math.acos(dot);const invSin=1/Math.sin(scale1);dot=Math.sin((1-slerp)*scale1)*invSin;scale1=Math.sin(slerp*scale1)*invSin}else dot=1-slerp,scale1=slerp;vector0Dir.scaleInPlace(dot);vector1Dir.scaleInPlace(scale1);result.copyFrom(vector0Dir).addInPlace(vector1Dir);
result.scaleInPlace(_mathScalar.Scalar.Lerp(vector0,vector1,slerp));return result}static SmoothToRef(source,goal,deltaTime,lerpTime,result){Vector3.SlerpToRef(source,goal,0===lerpTime?1:deltaTime/lerpTime,result);return result}static FromArray(array,offset=0){return new Vector3(array[offset],array[offset+1],array[offset+2])}static FromFloatArray(array,offset){return Vector3.FromArray(array,offset)}static FromArrayToRef(array,offset,result){result._x=array[offset];result._y=array[offset+1];result._z=
array[offset+2];result._isDirty=!0;return result}static FromFloatArrayToRef(array,offset,result){return Vector3.FromArrayToRef(array,offset,result)}static FromFloatsToRef(x,y,z,result){result.copyFromFloats(x,y,z);return result}static Zero(){return new Vector3(0,0,0)}static One(){return new Vector3(1,1,1)}static Up(){return new Vector3(0,1,0)}static get UpReadOnly(){return Vector3._UpReadOnly}static get DownReadOnly(){return Vector3._DownReadOnly}static get RightReadOnly(){return Vector3._RightReadOnly}static get LeftReadOnly(){return Vector3._LeftReadOnly}static get LeftHandedForwardReadOnly(){return Vector3._LeftHandedForwardReadOnly}static get RightHandedForwardReadOnly(){return Vector3._RightHandedForwardReadOnly}static get LeftHandedBackwardReadOnly(){return Vector3._LeftHandedBackwardReadOnly}static get RightHandedBackwardReadOnly(){return Vector3._RightHandedBackwardReadOnly}static get ZeroReadOnly(){return Vector3._ZeroReadOnly}static get OneReadOnly(){return Vector3._OneReadOnly}static Down(){return new Vector3(0,
-1,0)}static Forward(rightHandedSystem=!1){return new Vector3(0,0,rightHandedSystem?-1:1)}static Backward(rightHandedSystem=!1){return new Vector3(0,0,rightHandedSystem?1:-1)}static Right(){return new Vector3(1,0,0)}static Left(){return new Vector3(-1,0,0)}static Random(min=0,max=1){return new Vector3(_mathScalar.Scalar.RandomRange(min,max),_mathScalar.Scalar.RandomRange(min,max),_mathScalar.Scalar.RandomRange(min,max))}static TransformCoordinates(vector,transformation){const result=Vector3.Zero();
Vector3.TransformCoordinatesToRef(vector,transformation,result);return result}static TransformCoordinatesToRef(vector,transformation,result){Vector3.TransformCoordinatesFromFloatsToRef(vector._x,vector._y,vector._z,transformation,result);return result}static TransformCoordinatesFromFloatsToRef(x,y,z,transformation,result){transformation=transformation.m;const ry=x*transformation[1]+y*transformation[5]+z*transformation[9]+transformation[13],rz=x*transformation[2]+y*transformation[6]+z*transformation[10]+
transformation[14],rw=1/(x*transformation[3]+y*transformation[7]+z*transformation[11]+transformation[15]);result._x=(x*transformation[0]+y*transformation[4]+z*transformation[8]+transformation[12])*rw;result._y=ry*rw;result._z=rz*rw;result._isDirty=!0;return result}static TransformNormal(vector,transformation){const result=Vector3.Zero();Vector3.TransformNormalToRef(vector,transformation,result);return result}static TransformNormalToRef(vector,transformation,result){this.TransformNormalFromFloatsToRef(vector._x,
vector._y,vector._z,transformation,result);return result}static TransformNormalFromFloatsToRef(x,y,z,transformation,result){transformation=transformation.m;result._x=x*transformation[0]+y*transformation[4]+z*transformation[8];result._y=x*transformation[1]+y*transformation[5]+z*transformation[9];result._z=x*transformation[2]+y*transformation[6]+z*transformation[10];result._isDirty=!0;return result}static CatmullRom(value1,value2,value3,value4,amount){const squared=amount*amount,cubed=amount*squared;
return new value1.constructor(.5*(2*value2._x+(-value1._x+value3._x)*amount+(2*value1._x-5*value2._x+4*value3._x-value4._x)*squared+(-value1._x+3*value2._x-3*value3._x+value4._x)*cubed),.5*(2*value2._y+(-value1._y+value3._y)*amount+(2*value1._y-5*value2._y+4*value3._y-value4._y)*squared+(-value1._y+3*value2._y-3*value3._y+value4._y)*cubed),.5*(2*value2._z+(-value1._z+value3._z)*amount+(2*value1._z-5*value2._z+4*value3._z-value4._z)*squared+(-value1._z+3*value2._z-3*value3._z+value4._z)*cubed))}static Clamp(value,
min,max){const result=new value.constructor;Vector3.ClampToRef(value,min,max,result);return result}static ClampToRef(value,min,max,result){let x=value._x;x=x>max._x?max._x:x;x=x<min._x?min._x:x;let y=value._y;y=y>max._y?max._y:y;y=y<min._y?min._y:y;value=value._z;value=value>max._z?max._z:value;value=value<min._z?min._z:value;result.copyFromFloats(x,y,value);return result}static CheckExtends(v,min,max){min.minimizeInPlace(v);max.maximizeInPlace(v)}static Hermite(value1,tangent1,value2,tangent2,amount){var squared=
amount*amount;const cubed=amount*squared,part1=2*cubed-3*squared+1,part2=-2*cubed+3*squared;amount=cubed-2*squared+amount;squared=cubed-squared;return new value1.constructor(value1._x*part1+value2._x*part2+tangent1._x*amount+tangent2._x*squared,value1._y*part1+value2._y*part2+tangent1._y*amount+tangent2._y*squared,value1._z*part1+value2._z*part2+tangent1._z*amount+tangent2._z*squared)}static Hermite1stDerivative(value1,tangent1,value2,tangent2,time){const result=new value1.constructor;this.Hermite1stDerivativeToRef(value1,
tangent1,value2,tangent2,time,result);return result}static Hermite1stDerivativeToRef(value1,tangent1,value2,tangent2,time,result){const t2=time*time;result._x=6*(t2-time)*value1._x+(3*t2-4*time+1)*tangent1._x+6*(-t2+time)*value2._x+(3*t2-2*time)*tangent2._x;result._y=6*(t2-time)*value1._y+(3*t2-4*time+1)*tangent1._y+6*(-t2+time)*value2._y+(3*t2-2*time)*tangent2._y;result._z=6*(t2-time)*value1._z+(3*t2-4*time+1)*tangent1._z+6*(-t2+time)*value2._z+(3*t2-2*time)*tangent2._z;result._isDirty=!0;return result}static Lerp(start,
end,amount){const result=new start.constructor(0,0,0);Vector3.LerpToRef(start,end,amount,result);return result}static LerpToRef(start,end,amount,result){result._x=start._x+(end._x-start._x)*amount;result._y=start._y+(end._y-start._y)*amount;result._z=start._z+(end._z-start._z)*amount;result._isDirty=!0;return result}static Dot(left,right){return left._x*right._x+left._y*right._y+left._z*right._z}static Cross(left,right){const result=new left.constructor;Vector3.CrossToRef(left,right,result);return result}static CrossToRef(left,
right,result){result.copyFromFloats(left._y*right._z-left._z*right._y,left._z*right._x-left._x*right._z,left._x*right._y-left._y*right._x);return result}static Normalize(vector){const result=Vector3.Zero();Vector3.NormalizeToRef(vector,result);return result}static NormalizeToRef(vector,result){vector.normalizeToRef(result);return result}static Project(vector,world,transform,viewport){const result=new vector.constructor;Vector3.ProjectToRef(vector,world,transform,viewport,result);return result}static ProjectToRef(vector,
world,transform,viewport,result){const cw=viewport.width,ch=viewport.height,viewportMatrix=MathTmp.Matrix[1];Matrix.FromValuesToRef(cw/2,0,0,0,0,-ch/2,0,0,0,0,.5,0,viewport.x+cw/2,ch/2+viewport.y,.5,1,viewportMatrix);viewport=MathTmp.Matrix[0];world.multiplyToRef(transform,viewport);viewport.multiplyToRef(viewportMatrix,viewport);Vector3.TransformCoordinatesToRef(vector,viewport,result);return result}static Reflect(inDirection,normal){return this.ReflectToRef(inDirection,normal,new Vector3)}static ReflectToRef(inDirection,
normal,ref){const tmp=TmpVectors.Vector3[0];tmp.copyFrom(normal).scaleInPlace(2*Vector3.Dot(inDirection,normal));return ref.copyFrom(inDirection).subtractInPlace(tmp)}static _UnprojectFromInvertedMatrixToRef(source,matrix,result){Vector3.TransformCoordinatesToRef(source,matrix,result);matrix=matrix.m;source=source._x*matrix[3]+source._y*matrix[7]+source._z*matrix[11]+matrix[15];_mathScalar.Scalar.WithinEpsilon(source,1)&&result.scaleInPlace(1/source);return result}static UnprojectFromTransform(source,
viewportWidth,viewportHeight,world,transform){return this.Unproject(source,viewportWidth,viewportHeight,world,transform,Matrix.IdentityReadOnly)}static Unproject(source,viewportWidth,viewportHeight,world,view,projection){const result=new source.constructor;Vector3.UnprojectToRef(source,viewportWidth,viewportHeight,world,view,projection,result);return result}static UnprojectToRef(source,viewportWidth,viewportHeight,world,view,projection,result){Vector3.UnprojectFloatsToRef(source._x,source._y,source._z,
viewportWidth,viewportHeight,world,view,projection,result);return result}static UnprojectFloatsToRef(sourceX,sourceY,sourceZ,viewportWidth,viewportHeight,world,view,projection,result){var _a;const matrix=MathTmp.Matrix[0];world.multiplyToRef(view,matrix);matrix.multiplyToRef(projection,matrix);matrix.invert();world=MathTmp.Vector3[0];world.x=sourceX/viewportWidth*2-1;world.y=-(sourceY/viewportHeight*2-1);(null===(_a=_engineStore.EngineStore.LastCreatedEngine)||void 0===_a?0:_a.isNDCHalfZRange)?world.z=
sourceZ:world.z=2*sourceZ-1;Vector3._UnprojectFromInvertedMatrixToRef(world,matrix,result);return result}static Minimize(left,right){const min=new left.constructor;min.copyFrom(left);min.minimizeInPlace(right);return min}static Maximize(left,right){const max=new left.constructor;max.copyFrom(left);max.maximizeInPlace(right);return max}static Distance(value1,value2){return Math.sqrt(Vector3.DistanceSquared(value1,value2))}static DistanceSquared(value1,value2){const x=value1._x-value2._x,y=value1._y-
value2._y;value1=value1._z-value2._z;return x*x+y*y+value1*value1}static ProjectOnTriangleToRef(vector,p0,p1,p2,ref){var p1p0=MathTmp.Vector3[0];const p2p0=MathTmp.Vector3[1],p2p1=MathTmp.Vector3[2];var normal=MathTmp.Vector3[3],vectorp0=MathTmp.Vector3[4];p1.subtractToRef(p0,p1p0);p2.subtractToRef(p0,p2p0);p2.subtractToRef(p1,p2p1);var p1p0L=p1p0.length(),p2p0L=p2p0.length(),p2p1L=p2p1.length();if(p1p0L<_mathConstants.Epsilon||p2p0L<_mathConstants.Epsilon||p2p1L<_mathConstants.Epsilon)return ref.copyFrom(p0),
Vector3.Distance(vector,p0);vector.subtractToRef(p0,vectorp0);Vector3.CrossToRef(p1p0,p2p0,normal);var nl=normal.length();if(nl<_mathConstants.Epsilon)return ref.copyFrom(p0),Vector3.Distance(vector,p0);normal.normalizeFromLength(nl);var l=vectorp0.length();if(l<_mathConstants.Epsilon)return ref.copyFrom(p0),0;vectorp0.normalizeFromLength(l);var cosA=Vector3.Dot(normal,vectorp0);nl=MathTmp.Vector3[5];vectorp0=MathTmp.Vector3[6];nl.copyFrom(normal).scaleInPlace(-l*cosA);vectorp0.copyFrom(vector).addInPlace(nl);
var v0=MathTmp.Vector3[4];const v1=MathTmp.Vector3[5];var v2=MathTmp.Vector3[7];nl=MathTmp.Vector3[8];v0.copyFrom(p1p0).scaleInPlace(1/p1p0L);nl.copyFrom(p2p0).scaleInPlace(1/p2p0L);v0.addInPlace(nl).scaleInPlace(-1);v1.copyFrom(p1p0).scaleInPlace(-1/p1p0L);nl.copyFrom(p2p1).scaleInPlace(1/p2p1L);v1.addInPlace(nl).scaleInPlace(-1);v2.copyFrom(p2p1).scaleInPlace(-1/p2p1L);nl.copyFrom(p2p0).scaleInPlace(-1/p2p0L);v2.addInPlace(nl).scaleInPlace(-1);p2p0L=MathTmp.Vector3[9];p2p0L.copyFrom(vectorp0).subtractInPlace(p0);
Vector3.CrossToRef(v0,p2p0L,nl);p1p0L=v0=Vector3.Dot(nl,normal);p2p0L.copyFrom(vectorp0).subtractInPlace(p1);Vector3.CrossToRef(v1,p2p0L,nl);p2p1L=v0=Vector3.Dot(nl,normal);p2p0L.copyFrom(vectorp0).subtractInPlace(p2);Vector3.CrossToRef(v2,p2p0L,nl);p2p0L=v0=Vector3.Dot(nl,normal);v2=MathTmp.Vector3[10];0<p1p0L&&0>p2p1L?(v2.copyFrom(p1p0),p1p0=p0):0<p2p1L&&0>p2p0L?(v2.copyFrom(p2p1),p1p0=p1,p1=p2):(v2.copyFrom(p2p0).scaleInPlace(-1),p1p0=p2,p1=p0);p2=MathTmp.Vector3[9];p0=MathTmp.Vector3[4];p1p0.subtractToRef(vectorp0,
nl);p1.subtractToRef(vectorp0,p2);Vector3.CrossToRef(nl,p2,p0);if(!(0>Vector3.Dot(p0,normal)))return ref.copyFrom(vectorp0),Math.abs(l*cosA);l=MathTmp.Vector3[5];Vector3.CrossToRef(v2,p0,l);l.normalize();normal=MathTmp.Vector3[9];normal.copyFrom(p1p0).subtractInPlace(vectorp0);cosA=normal.length();if(cosA<_mathConstants.Epsilon)return ref.copyFrom(p1p0),Vector3.Distance(vector,p1p0);normal.normalizeFromLength(cosA);p0=Vector3.Dot(l,normal);normal=MathTmp.Vector3[7];normal.copyFrom(vectorp0).addInPlace(l.scaleInPlace(cosA*
p0));nl.copyFrom(normal).subtractInPlace(p1p0);l=v2.length();v2.normalizeFromLength(l);vectorp0=Vector3.Dot(nl,v2)/Math.max(l,_mathConstants.Epsilon);vectorp0=_mathScalar.Scalar.Clamp(vectorp0,0,1);normal.copyFrom(p1p0).addInPlace(v2.scaleInPlace(vectorp0*l));ref.copyFrom(normal);return Vector3.Distance(vector,normal)}static Center(value1,value2){return Vector3.CenterToRef(value1,value2,Vector3.Zero())}static CenterToRef(value1,value2,ref){return ref.copyFromFloats((value1._x+value2._x)/2,(value1._y+
value2._y)/2,(value1._z+value2._z)/2)}static RotationFromAxis(axis1,axis2,axis3){const rotation=new axis1.constructor;Vector3.RotationFromAxisToRef(axis1,axis2,axis3,rotation);return rotation}static RotationFromAxisToRef(axis1,axis2,axis3,ref){const quat=MathTmp.Quaternion[0];Quaternion.RotationQuaternionFromAxisToRef(axis1,axis2,axis3,quat);quat.toEulerAnglesToRef(ref);return ref}}exports.Vector3=Vector3;Vector3._UpReadOnly=Vector3.Up();Vector3._DownReadOnly=Vector3.Down();Vector3._LeftHandedForwardReadOnly=
Vector3.Forward(!1);Vector3._RightHandedForwardReadOnly=Vector3.Forward(!0);Vector3._LeftHandedBackwardReadOnly=Vector3.Backward(!1);Vector3._RightHandedBackwardReadOnly=Vector3.Backward(!0);Vector3._RightReadOnly=Vector3.Right();Vector3._LeftReadOnly=Vector3.Left();Vector3._ZeroReadOnly=Vector3.Zero();Vector3._OneReadOnly=Vector3.One();class Vector4{constructor(x=0,y=0,z=0,w=0){this.x=x;this.y=y;this.z=z;this.w=w}toString(){return`{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`}getClassName(){return"Vector4"}getHashCode(){var x=
_ExtractAsInt(this.x);const y=_ExtractAsInt(this.y),z=_ExtractAsInt(this.z),w=_ExtractAsInt(this.w);x=397*(397*x^y)^z;return x=397*x^w}asArray(){const result=[];this.toArray(result,0);return result}toArray(array,index){void 0===index&&(index=0);array[index]=this.x;array[index+1]=this.y;array[index+2]=this.z;array[index+3]=this.w;return this}fromArray(array,index=0){Vector4.FromArrayToRef(array,index,this);return this}addInPlace(otherVector){this.x+=otherVector.x;this.y+=otherVector.y;this.z+=otherVector.z;
this.w+=otherVector.w;return this}add(otherVector){return new this.constructor(this.x+otherVector.x,this.y+otherVector.y,this.z+otherVector.z,this.w+otherVector.w)}addToRef(otherVector,result){result.x=this.x+otherVector.x;result.y=this.y+otherVector.y;result.z=this.z+otherVector.z;result.w=this.w+otherVector.w;return result}subtractInPlace(otherVector){this.x-=otherVector.x;this.y-=otherVector.y;this.z-=otherVector.z;this.w-=otherVector.w;return this}subtract(otherVector){return new this.constructor(this.x-
otherVector.x,this.y-otherVector.y,this.z-otherVector.z,this.w-otherVector.w)}subtractToRef(otherVector,result){result.x=this.x-otherVector.x;result.y=this.y-otherVector.y;result.z=this.z-otherVector.z;result.w=this.w-otherVector.w;return result}subtractFromFloats(x,y,z,w){return new this.constructor(this.x-x,this.y-y,this.z-z,this.w-w)}subtractFromFloatsToRef(x,y,z,w,result){result.x=this.x-x;result.y=this.y-y;result.z=this.z-z;result.w=this.w-w;return result}negate(){return new this.constructor(-this.x,
-this.y,-this.z,-this.w)}negateInPlace(){this.x*=-1;this.y*=-1;this.z*=-1;this.w*=-1;return this}negateToRef(result){return result.copyFromFloats(-1*this.x,-1*this.y,-1*this.z,-1*this.w)}scaleInPlace(scale){this.x*=scale;this.y*=scale;this.z*=scale;this.w*=scale;return this}scale(scale){return new this.constructor(this.x*scale,this.y*scale,this.z*scale,this.w*scale)}scaleToRef(scale,result){result.x=this.x*scale;result.y=this.y*scale;result.z=this.z*scale;result.w=this.w*scale;return result}scaleAndAddToRef(scale,
result){result.x+=this.x*scale;result.y+=this.y*scale;result.z+=this.z*scale;result.w+=this.w*scale;return result}equals(otherVector){return otherVector&&this.x===otherVector.x&&this.y===otherVector.y&&this.z===otherVector.z&&this.w===otherVector.w}equalsWithEpsilon(otherVector,epsilon=_mathConstants.Epsilon){return otherVector&&_mathScalar.Scalar.WithinEpsilon(this.x,otherVector.x,epsilon)&&_mathScalar.Scalar.WithinEpsilon(this.y,otherVector.y,epsilon)&&_mathScalar.Scalar.WithinEpsilon(this.z,otherVector.z,
epsilon)&&_mathScalar.Scalar.WithinEpsilon(this.w,otherVector.w,epsilon)}equalsToFloats(x,y,z,w){return this.x===x&&this.y===y&&this.z===z&&this.w===w}multiplyInPlace(otherVector){this.x*=otherVector.x;this.y*=otherVector.y;this.z*=otherVector.z;this.w*=otherVector.w;return this}multiply(otherVector){return new this.constructor(this.x*otherVector.x,this.y*otherVector.y,this.z*otherVector.z,this.w*otherVector.w)}multiplyToRef(otherVector,result){result.x=this.x*otherVector.x;result.y=this.y*otherVector.y;
result.z=this.z*otherVector.z;result.w=this.w*otherVector.w;return result}multiplyByFloats(x,y,z,w){return new this.constructor(this.x*x,this.y*y,this.z*z,this.w*w)}divide(otherVector){return new this.constructor(this.x/otherVector.x,this.y/otherVector.y,this.z/otherVector.z,this.w/otherVector.w)}divideToRef(otherVector,result){result.x=this.x/otherVector.x;result.y=this.y/otherVector.y;result.z=this.z/otherVector.z;result.w=this.w/otherVector.w;return result}divideInPlace(otherVector){return this.divideToRef(otherVector,
this)}minimizeInPlace(other){other.x<this.x&&(this.x=other.x);other.y<this.y&&(this.y=other.y);other.z<this.z&&(this.z=other.z);other.w<this.w&&(this.w=other.w);return this}maximizeInPlace(other){other.x>this.x&&(this.x=other.x);other.y>this.y&&(this.y=other.y);other.z>this.z&&(this.z=other.z);other.w>this.w&&(this.w=other.w);return this}floor(){return new this.constructor(Math.floor(this.x),Math.floor(this.y),Math.floor(this.z),Math.floor(this.w))}fract(){return new this.constructor(this.x-Math.floor(this.x),
this.y-Math.floor(this.y),this.z-Math.floor(this.z),this.w-Math.floor(this.w))}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}normalize(){const len=this.length();return 0===len?this:this.scaleInPlace(1/len)}toVector3(){return new Vector3(this.x,this.y,this.z)}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copyFrom(source){this.x=source.x;this.y=source.y;this.z=source.z;
this.w=source.w;return this}copyFromFloats(x,y,z,w){this.x=x;this.y=y;this.z=z;this.w=w;return this}set(x,y,z,w){return this.copyFromFloats(x,y,z,w)}setAll(v){this.x=this.y=this.z=this.w=v;return this}static FromArray(array,offset){offset||(offset=0);return new Vector4(array[offset],array[offset+1],array[offset+2],array[offset+3])}static FromArrayToRef(array,offset,result){result.x=array[offset];result.y=array[offset+1];result.z=array[offset+2];result.w=array[offset+3];return result}static FromFloatArrayToRef(array,
offset,result){Vector4.FromArrayToRef(array,offset,result);return result}static FromFloatsToRef(x,y,z,w,result){result.x=x;result.y=y;result.z=z;result.w=w;return result}static Zero(){return new Vector4(0,0,0,0)}static One(){return new Vector4(1,1,1,1)}static Random(min=0,max=1){return new Vector4(_mathScalar.Scalar.RandomRange(min,max),_mathScalar.Scalar.RandomRange(min,max),_mathScalar.Scalar.RandomRange(min,max),_mathScalar.Scalar.RandomRange(min,max))}static get ZeroReadOnly(){return Vector4._ZeroReadOnly}static Normalize(vector){const result=
Vector4.Zero();Vector4.NormalizeToRef(vector,result);return result}static NormalizeToRef(vector,result){result.copyFrom(vector);result.normalize();return result}static Minimize(left,right){const min=new left.constructor;min.copyFrom(left);min.minimizeInPlace(right);return min}static Maximize(left,right){const max=new left.constructor;max.copyFrom(left);max.maximizeInPlace(right);return max}static Distance(value1,value2){return Math.sqrt(Vector4.DistanceSquared(value1,value2))}static DistanceSquared(value1,
value2){const x=value1.x-value2.x,y=value1.y-value2.y,z=value1.z-value2.z;value1=value1.w-value2.w;return x*x+y*y+z*z+value1*value1}static Center(value1,value2){return Vector4.CenterToRef(value1,value2,Vector4.Zero())}static CenterToRef(value1,value2,ref){return ref.copyFromFloats((value1.x+value2.x)/2,(value1.y+value2.y)/2,(value1.z+value2.z)/2,(value1.w+value2.w)/2)}static TransformCoordinates(vector,transformation){const result=Vector4.Zero();Vector4.TransformCoordinatesToRef(vector,transformation,
result);return result}static TransformCoordinatesToRef(vector,transformation,result){Vector4.TransformCoordinatesFromFloatsToRef(vector._x,vector._y,vector._z,transformation,result);return result}static TransformCoordinatesFromFloatsToRef(x,y,z,transformation,result){transformation=transformation.m;const ry=x*transformation[1]+y*transformation[5]+z*transformation[9]+transformation[13],rz=x*transformation[2]+y*transformation[6]+z*transformation[10]+transformation[14],rw=x*transformation[3]+y*transformation[7]+
z*transformation[11]+transformation[15];result.x=x*transformation[0]+y*transformation[4]+z*transformation[8]+transformation[12];result.y=ry;result.z=rz;result.w=rw;return result}static TransformNormal(vector,transformation){const result=new vector.constructor;Vector4.TransformNormalToRef(vector,transformation,result);return result}static TransformNormalToRef(vector,transformation,result){transformation=transformation.m;const y=vector.x*transformation[1]+vector.y*transformation[5]+vector.z*transformation[9],
z=vector.x*transformation[2]+vector.y*transformation[6]+vector.z*transformation[10];result.x=vector.x*transformation[0]+vector.y*transformation[4]+vector.z*transformation[8];result.y=y;result.z=z;result.w=vector.w;return result}static TransformNormalFromFloatsToRef(x,y,z,w,transformation,result){transformation=transformation.m;result.x=x*transformation[0]+y*transformation[4]+z*transformation[8];result.y=x*transformation[1]+y*transformation[5]+z*transformation[9];result.z=x*transformation[2]+y*transformation[6]+
z*transformation[10];result.w=w;return result}static FromVector3(source,w=0){return new Vector4(source._x,source._y,source._z,w)}}exports.Vector4=Vector4;Vector4._ZeroReadOnly=Vector4.Zero();class Quaternion{get x(){return this._x}set x(value){this._x=value;this._isDirty=!0}get y(){return this._y}set y(value){this._y=value;this._isDirty=!0}get z(){return this._z}set z(value){this._z=value;this._isDirty=!0}get w(){return this._w}set w(value){this._w=value;this._isDirty=!0}constructor(x=0,y=0,z=0,w=
1){this._isDirty=!0;this._x=x;this._y=y;this._z=z;this._w=w}toString(){return`{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`}getClassName(){return"Quaternion"}getHashCode(){var x=_ExtractAsInt(this._x);const y=_ExtractAsInt(this._y),z=_ExtractAsInt(this._z),w=_ExtractAsInt(this._w);x=397*(397*x^y)^z;return x=397*x^w}asArray(){return[this._x,this._y,this._z,this._w]}toArray(array,index=0){array[index]=this._x;array[index+1]=this._y;array[index+2]=this._z;array[index+3]=this._w;return this}equals(otherQuaternion){return otherQuaternion&&
this._x===otherQuaternion._x&&this._y===otherQuaternion._y&&this._z===otherQuaternion._z&&this._w===otherQuaternion._w}equalsWithEpsilon(otherQuaternion,epsilon=_mathConstants.Epsilon){return otherQuaternion&&_mathScalar.Scalar.WithinEpsilon(this._x,otherQuaternion._x,epsilon)&&_mathScalar.Scalar.WithinEpsilon(this._y,otherQuaternion._y,epsilon)&&_mathScalar.Scalar.WithinEpsilon(this._z,otherQuaternion._z,epsilon)&&_mathScalar.Scalar.WithinEpsilon(this._w,otherQuaternion._w,epsilon)}clone(){return new this.constructor(this._x,
this._y,this._z,this._w)}copyFrom(other){this._x=other._x;this._y=other._y;this._z=other._z;this._w=other._w;this._isDirty=!0;return this}copyFromFloats(x,y,z,w){this._x=x;this._y=y;this._z=z;this._w=w;this._isDirty=!0;return this}set(x,y,z,w){return this.copyFromFloats(x,y,z,w)}add(other){return new this.constructor(this._x+other._x,this._y+other._y,this._z+other._z,this._w+other._w)}addInPlace(other){this._x+=other._x;this._y+=other._y;this._z+=other._z;this._w+=other._w;this._isDirty=!0;return this}subtract(other){return new this.constructor(this._x-
other._x,this._y-other._y,this._z-other._z,this._w-other._w)}subtractInPlace(other){this._x-=other._x;this._y-=other._y;this._z-=other._z;this._w-=other._w;this._isDirty=!0;return this}scale(value){return new this.constructor(this._x*value,this._y*value,this._z*value,this._w*value)}scaleToRef(scale,result){result._x=this._x*scale;result._y=this._y*scale;result._z=this._z*scale;result._w=this._w*scale;result._isDirty=!0;return result}scaleInPlace(value){this._x*=value;this._y*=value;this._z*=value;
this._w*=value;this._isDirty=!0;return this}scaleAndAddToRef(scale,result){result._x+=this._x*scale;result._y+=this._y*scale;result._z+=this._z*scale;result._w+=this._w*scale;result._isDirty=!0;return result}multiply(q1){const result=new this.constructor(0,0,0,1);this.multiplyToRef(q1,result);return result}multiplyToRef(q1,result){result.copyFromFloats(this._x*q1._w+this._y*q1._z-this._z*q1._y+this._w*q1._x,-this._x*q1._z+this._y*q1._w+this._z*q1._x+this._w*q1._y,this._x*q1._y-this._y*q1._x+this._z*
q1._w+this._w*q1._z,-this._x*q1._x-this._y*q1._y-this._z*q1._z+this._w*q1._w);return result}multiplyInPlace(q1){this.multiplyToRef(q1,this);return this}conjugateToRef(ref){ref.copyFromFloats(-this._x,-this._y,-this._z,this._w);return ref}conjugateInPlace(){this._x*=-1;this._y*=-1;this._z*=-1;this._isDirty=!0;return this}conjugate(){return new this.constructor(-this._x,-this._y,-this._z,this._w)}invert(){const conjugate=this.conjugate(),lengthSquared=this.lengthSquared();if(0==lengthSquared||1==lengthSquared)return conjugate;
conjugate.scaleInPlace(1/lengthSquared);return conjugate}invertInPlace(){this.conjugateInPlace();const lengthSquared=this.lengthSquared();if(0==lengthSquared||1==lengthSquared)return this;this.scaleInPlace(1/lengthSquared);return this}lengthSquared(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this.lengthSquared())}normalize(){const len=this.length();if(0===len)return this;this.scaleInPlace(1/len);return this}normalizeToNew(){const len=this.length();
return 0===len?this.clone():this.scale(1/len)}toEulerAngles(){const result=Vector3.Zero();this.toEulerAnglesToRef(result);return result}toEulerAnglesToRef(result){const qz=this._z,qx=this._x,qy=this._y,qw=this._w,zAxisY=qy*qz-qx*qw;if(-.4999999>zAxisY)result._y=2*Math.atan2(qy,qw),result._x=Math.PI/2,result._z=0;else if(.4999999<zAxisY)result._y=2*Math.atan2(qy,qw),result._x=-Math.PI/2,result._z=0;else{const sqw=qw*qw,sqz=qz*qz,sqx=qx*qx,sqy=qy*qy;result._z=Math.atan2(2*(qx*qy+qz*qw),-sqz-sqx+sqy+
sqw);result._x=Math.asin(-2*zAxisY);result._y=Math.atan2(2*(qz*qx+qy*qw),sqz-sqx-sqy+sqw)}result._isDirty=!0;return result}toRotationMatrix(result){Matrix.FromQuaternionToRef(this,result);return result}fromRotationMatrix(matrix){Quaternion.FromRotationMatrixToRef(matrix,this);return this}static FromRotationMatrix(matrix){const result=new Quaternion;Quaternion.FromRotationMatrixToRef(matrix,result);return result}static FromRotationMatrixToRef(matrix,result){var data=matrix.m,m11=data[0];matrix=data[4];
const m13=data[8],m21=data[1],m22=data[5],m23=data[9],m31=data[2],m32=data[6];data=data[10];const trace=m11+m22+data;0<trace?(m11=.5/Math.sqrt(trace+1),result._w=.25/m11,result._x=(m32-m23)*m11,result._y=(m13-m31)*m11,result._z=(m21-matrix)*m11):m11>m22&&m11>data?(m11=2*Math.sqrt(1+m11-m22-data),result._w=(m32-m23)/m11,result._x=.25*m11,result._y=(matrix+m21)/m11,result._z=(m13+m31)/m11):m22>data?(m11=2*Math.sqrt(1+m22-m11-data),result._w=(m13-m31)/m11,result._x=(matrix+m21)/m11,result._y=.25*m11,
result._z=(m23+m32)/m11):(m11=2*Math.sqrt(1+data-m11-m22),result._w=(m21-matrix)/m11,result._x=(m13+m31)/m11,result._y=(m23+m32)/m11,result._z=.25*m11);result._isDirty=!0;return result}static Dot(left,right){return left._x*right._x+left._y*right._y+left._z*right._z+left._w*right._w}static AreClose(quat0,quat1,epsilon=.1){quat0=Quaternion.Dot(quat0,quat1);return 1-quat0*quat0<=epsilon}static SmoothToRef(source,goal,deltaTime,lerpTime,result){deltaTime=_mathScalar.Scalar.Clamp(0===lerpTime?1:deltaTime/
lerpTime,0,1);Quaternion.SlerpToRef(source,goal,deltaTime,result);return result}static Zero(){return new Quaternion(0,0,0,0)}static Inverse(q){return new q.constructor(-q._x,-q._y,-q._z,q._w)}static InverseToRef(q,result){result.set(-q._x,-q._y,-q._z,q._w);return result}static Identity(){return new Quaternion(0,0,0,1)}static IsIdentity(quaternion){return quaternion&&0===quaternion._x&&0===quaternion._y&&0===quaternion._z&&1===quaternion._w}static RotationAxis(axis,angle){return Quaternion.RotationAxisToRef(axis,
angle,new Quaternion)}static RotationAxisToRef(axis,angle,result){const sin=Math.sin(angle/2);axis.normalize();result._w=Math.cos(angle/2);result._x=axis._x*sin;result._y=axis._y*sin;result._z=axis._z*sin;result._isDirty=!0;return result}static FromArray(array,offset){offset||(offset=0);return new Quaternion(array[offset],array[offset+1],array[offset+2],array[offset+3])}static FromArrayToRef(array,offset,result){result._x=array[offset];result._y=array[offset+1];result._z=array[offset+2];result._w=
array[offset+3];result._isDirty=!0;return result}static FromEulerAngles(x,y,z){const q=new Quaternion;Quaternion.RotationYawPitchRollToRef(y,x,z,q);return q}static FromEulerAnglesToRef(x,y,z,result){Quaternion.RotationYawPitchRollToRef(y,x,z,result);return result}static FromEulerVector(vec){const q=new Quaternion;Quaternion.RotationYawPitchRollToRef(vec._y,vec._x,vec._z,q);return q}static FromEulerVectorToRef(vec,result){Quaternion.RotationYawPitchRollToRef(vec._y,vec._x,vec._z,result);return result}static FromUnitVectorsToRef(vecFrom,
vecTo,result,epsilon=_mathConstants.Epsilon){const r=Vector3.Dot(vecFrom,vecTo)+1;r<epsilon?Math.abs(vecFrom.x)>Math.abs(vecFrom.z)?result.set(-vecFrom.y,vecFrom.x,0,0):result.set(0,-vecFrom.z,vecFrom.y,0):(Vector3.CrossToRef(vecFrom,vecTo,TmpVectors.Vector3[0]),result.set(TmpVectors.Vector3[0].x,TmpVectors.Vector3[0].y,TmpVectors.Vector3[0].z,r));return result.normalize()}static RotationYawPitchRoll(yaw,pitch,roll){const q=new Quaternion;Quaternion.RotationYawPitchRollToRef(yaw,pitch,roll,q);return q}static RotationYawPitchRollToRef(yaw,
pitch,roll,result){roll*=.5;var halfPitch=.5*pitch;pitch=.5*yaw;yaw=Math.sin(roll);roll=Math.cos(roll);const sinPitch=Math.sin(halfPitch);halfPitch=Math.cos(halfPitch);const sinYaw=Math.sin(pitch);pitch=Math.cos(pitch);result._x=pitch*sinPitch*roll+sinYaw*halfPitch*yaw;result._y=sinYaw*halfPitch*roll-pitch*sinPitch*yaw;result._z=pitch*halfPitch*yaw-sinYaw*sinPitch*roll;result._w=pitch*halfPitch*roll+sinYaw*sinPitch*yaw;result._isDirty=!0;return result}static RotationAlphaBetaGamma(alpha,beta,gamma){const result=
new Quaternion;Quaternion.RotationAlphaBetaGammaToRef(alpha,beta,gamma,result);return result}static RotationAlphaBetaGammaToRef(alpha,beta,gamma,result){const halfGammaPlusAlpha=.5*(gamma+alpha);alpha=.5*(gamma-alpha);beta*=.5;result._x=Math.cos(alpha)*Math.sin(beta);result._y=Math.sin(alpha)*Math.sin(beta);result._z=Math.sin(halfGammaPlusAlpha)*Math.cos(beta);result._w=Math.cos(halfGammaPlusAlpha)*Math.cos(beta);result._isDirty=!0;return result}static RotationQuaternionFromAxis(axis1,axis2,axis3){const quat=
new Quaternion(0,0,0,0);Quaternion.RotationQuaternionFromAxisToRef(axis1,axis2,axis3,quat);return quat}static RotationQuaternionFromAxisToRef(axis1,axis2,axis3,ref){const rotMat=MathTmp.Matrix[0];Matrix.FromXYZAxesToRef(axis1.normalize(),axis2.normalize(),axis3.normalize(),rotMat);Quaternion.FromRotationMatrixToRef(rotMat,ref);return ref}static FromLookDirectionLH(forward,up){const quat=new Quaternion;Quaternion.FromLookDirectionLHToRef(forward,up,quat);return quat}static FromLookDirectionLHToRef(forward,
up,ref){const rotMat=MathTmp.Matrix[0];Matrix.LookDirectionLHToRef(forward,up,rotMat);Quaternion.FromRotationMatrixToRef(rotMat,ref);return ref}static FromLookDirectionRH(forward,up){const quat=new Quaternion;Quaternion.FromLookDirectionRHToRef(forward,up,quat);return quat}static FromLookDirectionRHToRef(forward,up,ref){const rotMat=MathTmp.Matrix[0];Matrix.LookDirectionRHToRef(forward,up,rotMat);return Quaternion.FromRotationMatrixToRef(rotMat,ref)}static Slerp(left,right,amount){const result=Quaternion.Identity();
Quaternion.SlerpToRef(left,right,amount,result);return result}static SlerpToRef(left,right,amount,result){var num3=left._x*right._x+left._y*right._y+left._z*right._z+left._w*right._w;let flag=!1;0>num3&&(flag=!0,num3=-num3);if(.999999<num3)num3=1-amount,amount=flag?-amount:amount;else{const num5=Math.acos(num3),num6=1/Math.sin(num5);num3=Math.sin((1-amount)*num5)*num6;amount=flag?-Math.sin(amount*num5)*num6:Math.sin(amount*num5)*num6}result._x=num3*left._x+amount*right._x;result._y=num3*left._y+amount*
right._y;result._z=num3*left._z+amount*right._z;result._w=num3*left._w+amount*right._w;result._isDirty=!0;return result}static Hermite(value1,tangent1,value2,tangent2,amount){var squared=amount*amount;const cubed=amount*squared,part1=2*cubed-3*squared+1,part2=-2*cubed+3*squared;amount=cubed-2*squared+amount;squared=cubed-squared;return new value1.constructor(value1._x*part1+value2._x*part2+tangent1._x*amount+tangent2._x*squared,value1._y*part1+value2._y*part2+tangent1._y*amount+tangent2._y*squared,
value1._z*part1+value2._z*part2+tangent1._z*amount+tangent2._z*squared,value1._w*part1+value2._w*part2+tangent1._w*amount+tangent2._w*squared)}static Hermite1stDerivative(value1,tangent1,value2,tangent2,time){const result=new value1.constructor;this.Hermite1stDerivativeToRef(value1,tangent1,value2,tangent2,time,result);return result}static Hermite1stDerivativeToRef(value1,tangent1,value2,tangent2,time,result){const t2=time*time;result._x=6*(t2-time)*value1._x+(3*t2-4*time+1)*tangent1._x+6*(-t2+time)*
value2._x+(3*t2-2*time)*tangent2._x;result._y=6*(t2-time)*value1._y+(3*t2-4*time+1)*tangent1._y+6*(-t2+time)*value2._y+(3*t2-2*time)*tangent2._y;result._z=6*(t2-time)*value1._z+(3*t2-4*time+1)*tangent1._z+6*(-t2+time)*value2._z+(3*t2-2*time)*tangent2._z;result._w=6*(t2-time)*value1._w+(3*t2-4*time+1)*tangent1._w+6*(-t2+time)*value2._w+(3*t2-2*time)*tangent2._w;result._isDirty=!0;return result}}exports.Quaternion=Quaternion;class Matrix{static get Use64Bits(){return _performanceConfigurator.PerformanceConfigurator.MatrixUse64Bits}get m(){return this._m}markAsUpdated(){this.updateFlag=
Matrix._UpdateFlagSeed++;this._isIdentity3x2=this._isIdentity=!1;this._isIdentity3x2Dirty=this._isIdentityDirty=!0}_updateIdentityStatus(isIdentity,isIdentityDirty=!1,isIdentity3x2=!1,isIdentity3x2Dirty=!0){this._isIdentity3x2=(this._isIdentity=isIdentity)||isIdentity3x2;this._isIdentityDirty=this._isIdentity?!1:isIdentityDirty;this._isIdentity3x2Dirty=this._isIdentity3x2?!1:isIdentity3x2Dirty}constructor(){this._isIdentity=!1;this._isIdentity3x2Dirty=this._isIdentity3x2=this._isIdentityDirty=!0;
this.updateFlag=-1;_performanceConfigurator.PerformanceConfigurator.MatrixTrackPrecisionChange&&_performanceConfigurator.PerformanceConfigurator.MatrixTrackedMatrices.push(this);this._m=new _performanceConfigurator.PerformanceConfigurator.MatrixCurrentType(16);this.markAsUpdated()}isIdentity(){if(this._isIdentityDirty){this._isIdentityDirty=!1;const m=this._m;this._isIdentity=1===m[0]&&0===m[1]&&0===m[2]&&0===m[3]&&0===m[4]&&1===m[5]&&0===m[6]&&0===m[7]&&0===m[8]&&0===m[9]&&1===m[10]&&0===m[11]&&
0===m[12]&&0===m[13]&&0===m[14]&&1===m[15]}return this._isIdentity}isIdentityAs3x2(){this._isIdentity3x2Dirty&&(this._isIdentity3x2Dirty=!1,this._isIdentity3x2=1!==this._m[0]||1!==this._m[5]||1!==this._m[15]?!1:0!==this._m[1]||0!==this._m[2]||0!==this._m[3]||0!==this._m[4]||0!==this._m[6]||0!==this._m[7]||0!==this._m[8]||0!==this._m[9]||0!==this._m[10]||0!==this._m[11]||0!==this._m[12]||0!==this._m[13]||0!==this._m[14]?!1:!0);return this._isIdentity3x2}determinant(){if(!0===this._isIdentity)return 1;
const m=this._m,m10=m[4],m11=m[5],m12=m[6],m13=m[7];var m20=m[8];const m21=m[9];var m22=m[10],m23=m[11];const m30=m[12],m31=m[13],m32=m[14],m33=m[15],det_22_33=m22*m33-m32*m23,det_21_33=m21*m33-m31*m23,det_21_32=m21*m32-m31*m22;m23=m20*m33-m30*m23;m22=m20*m32-m22*m30;m20=m20*m31-m30*m21;return m[0]*+(m11*det_22_33-m12*det_21_33+m13*det_21_32)+m[1]*-(m10*det_22_33-m12*m23+m13*m22)+m[2]*+(m10*det_21_33-m11*m23+m13*m20)+m[3]*-(m10*det_21_32-m11*m22+m12*m20)}toArray(){return this._m}asArray(){return this._m}invert(){this.invertToRef(this);
return this}reset(){Matrix.FromValuesToRef(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,this);this._updateIdentityStatus(!1);return this}add(other){const result=new this.constructor;this.addToRef(other,result);return result}addToRef(other,result){const m=this._m,resultM=result._m;other=other.m;for(let index=0;16>index;index++)resultM[index]=m[index]+other[index];result.markAsUpdated();return result}addToSelf(other){const m=this._m;other=other.m;for(let index=0;16>index;index++)m[index]+=other[index];this.markAsUpdated();
return this}invertToRef(other){if(!0===this._isIdentity)return Matrix.IdentityToRef(other),other;var m=this._m;const m00=m[0],m01=m[1],m02=m[2],m03=m[3];var m10=m[4];const m11=m[5];var m12=m[6],m13=m[7];const m20=m[8],m21=m[9],m22=m[10],m23=m[11];var m30=m[12],m31=m[13],m32=m[14],m33=m[15];m=m22*m33-m32*m23;const det_21_33=m21*m33-m31*m23,det_21_32=m21*m32-m31*m22,det_20_33=m20*m33-m30*m23,det_20_32=m20*m32-m22*m30,det_20_31=m20*m31-m30*m21,cofact_00=+(m11*m-m12*det_21_33+m13*det_21_32),cofact_01=
-(m10*m-m12*det_20_33+m13*det_20_32),cofact_02=+(m10*det_21_33-m11*det_20_33+m13*det_20_31),cofact_03=-(m10*det_21_32-m11*det_20_32+m12*det_20_31);var det=m00*cofact_00+m01*cofact_01+m02*cofact_02+m03*cofact_03;if(0===det)return other.copyFrom(this),other;det=1/det;const det_12_33=m12*m33-m32*m13,det_11_33=m11*m33-m31*m13,det_11_32=m11*m32-m31*m12;m33=m10*m33-m30*m13;m32=m10*m32-m30*m12;m30=m10*m31-m30*m11;m31=m12*m23-m22*m13;const det_11_23=m11*m23-m21*m13,det_11_22=m11*m22-m21*m12;m13=m10*m23-m20*
m13;m12=m10*m22-m20*m12;m10=m10*m21-m20*m11;Matrix.FromValuesToRef(cofact_00*det,-(m01*m-m02*det_21_33+m03*det_21_32)*det,+(m01*det_12_33-m02*det_11_33+m03*det_11_32)*det,-(m01*m31-m02*det_11_23+m03*det_11_22)*det,cofact_01*det,+(m00*m-m02*det_20_33+m03*det_20_32)*det,-(m00*det_12_33-m02*m33+m03*m32)*det,+(m00*m31-m02*m13+m03*m12)*det,cofact_02*det,-(m00*det_21_33-m01*det_20_33+m03*det_20_31)*det,+(m00*det_11_33-m01*m33+m03*m30)*det,-(m00*det_11_23-m01*m13+m03*m10)*det,cofact_03*det,+(m00*det_21_32-
m01*det_20_32+m02*det_20_31)*det,-(m00*det_11_32-m01*m32+m02*m30)*det,+(m00*det_11_22-m01*m12+m02*m10)*det,other);return other}addAtIndex(index,value){this._m[index]+=value;this.markAsUpdated();return this}multiplyAtIndex(index,value){this._m[index]*=value;this.markAsUpdated();return this}setTranslationFromFloats(x,y,z){this._m[12]=x;this._m[13]=y;this._m[14]=z;this.markAsUpdated();return this}addTranslationFromFloats(x,y,z){this._m[12]+=x;this._m[13]+=y;this._m[14]+=z;this.markAsUpdated();return this}setTranslation(vector3){return this.setTranslationFromFloats(vector3._x,
vector3._y,vector3._z)}getTranslation(){return new Vector3(this._m[12],this._m[13],this._m[14])}getTranslationToRef(result){result.x=this._m[12];result.y=this._m[13];result.z=this._m[14];return result}removeRotationAndScaling(){const m=this.m;Matrix.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,m[12],m[13],m[14],m[15],this);this._updateIdentityStatus(0===m[12]&&0===m[13]&&0===m[14]&&1===m[15]);return this}multiply(other){const result=new this.constructor;this.multiplyToRef(other,result);return result}copyFrom(other){other.copyToArray(this._m);
this.updateFlag=other.updateFlag;this._updateIdentityStatus(other._isIdentity,other._isIdentityDirty,other._isIdentity3x2,other._isIdentity3x2Dirty);return this}copyToArray(array,offset=0){const source=this._m;array[offset]=source[0];array[offset+1]=source[1];array[offset+2]=source[2];array[offset+3]=source[3];array[offset+4]=source[4];array[offset+5]=source[5];array[offset+6]=source[6];array[offset+7]=source[7];array[offset+8]=source[8];array[offset+9]=source[9];array[offset+10]=source[10];array[offset+
11]=source[11];array[offset+12]=source[12];array[offset+13]=source[13];array[offset+14]=source[14];array[offset+15]=source[15];return this}multiplyToRef(other,result){if(this._isIdentity)return result.copyFrom(other),result;if(other._isIdentity)return result.copyFrom(this),result;this.multiplyToArray(other,result._m,0);result.markAsUpdated();return result}multiplyToArray(other,result,offset){var m=this._m,otherM=other.m;other=m[0];const tm1=m[1],tm2=m[2],tm3=m[3],tm4=m[4],tm5=m[5],tm6=m[6],tm7=m[7],
tm8=m[8],tm9=m[9],tm10=m[10],tm11=m[11],tm12=m[12],tm13=m[13],tm14=m[14];m=m[15];const om0=otherM[0],om1=otherM[1],om2=otherM[2],om3=otherM[3],om4=otherM[4],om5=otherM[5],om6=otherM[6],om7=otherM[7],om8=otherM[8],om9=otherM[9],om10=otherM[10],om11=otherM[11],om12=otherM[12],om13=otherM[13],om14=otherM[14];otherM=otherM[15];result[offset]=other*om0+tm1*om4+tm2*om8+tm3*om12;result[offset+1]=other*om1+tm1*om5+tm2*om9+tm3*om13;result[offset+2]=other*om2+tm1*om6+tm2*om10+tm3*om14;result[offset+3]=other*
om3+tm1*om7+tm2*om11+tm3*otherM;result[offset+4]=tm4*om0+tm5*om4+tm6*om8+tm7*om12;result[offset+5]=tm4*om1+tm5*om5+tm6*om9+tm7*om13;result[offset+6]=tm4*om2+tm5*om6+tm6*om10+tm7*om14;result[offset+7]=tm4*om3+tm5*om7+tm6*om11+tm7*otherM;result[offset+8]=tm8*om0+tm9*om4+tm10*om8+tm11*om12;result[offset+9]=tm8*om1+tm9*om5+tm10*om9+tm11*om13;result[offset+10]=tm8*om2+tm9*om6+tm10*om10+tm11*om14;result[offset+11]=tm8*om3+tm9*om7+tm10*om11+tm11*otherM;result[offset+12]=tm12*om0+tm13*om4+tm14*om8+m*om12;
result[offset+13]=tm12*om1+tm13*om5+tm14*om9+m*om13;result[offset+14]=tm12*om2+tm13*om6+tm14*om10+m*om14;result[offset+15]=tm12*om3+tm13*om7+tm14*om11+m*otherM;return this}equals(value){if(!value)return!1;if((this._isIdentity||value._isIdentity)&&!this._isIdentityDirty&&!value._isIdentityDirty)return this._isIdentity&&value._isIdentity;const m=this.m;value=value.m;return m[0]===value[0]&&m[1]===value[1]&&m[2]===value[2]&&m[3]===value[3]&&m[4]===value[4]&&m[5]===value[5]&&m[6]===value[6]&&m[7]===value[7]&&
m[8]===value[8]&&m[9]===value[9]&&m[10]===value[10]&&m[11]===value[11]&&m[12]===value[12]&&m[13]===value[13]&&m[14]===value[14]&&m[15]===value[15]}clone(){const matrix=new this.constructor;matrix.copyFrom(this);return matrix}getClassName(){return"Matrix"}getHashCode(){let hash=_ExtractAsInt(this._m[0]);for(let i=1;16>i;i++)hash=397*hash^_ExtractAsInt(this._m[i]);return hash}decomposeToTransformNode(node){node.rotationQuaternion=node.rotationQuaternion||new Quaternion;return this.decompose(node.scaling,
node.rotationQuaternion,node.position)}decompose(scale,rotation,translation,preserveScalingNode){if(this._isIdentity)return translation&&translation.setAll(0),scale&&scale.setAll(1),rotation&&rotation.copyFromFloats(0,0,0,1),!0;const m=this._m;translation&&translation.copyFromFloats(m[12],m[13],m[14]);scale=scale||MathTmp.Vector3[0];scale.x=Math.sqrt(m[0]*m[0]+m[1]*m[1]+m[2]*m[2]);scale.y=Math.sqrt(m[4]*m[4]+m[5]*m[5]+m[6]*m[6]);scale.z=Math.sqrt(m[8]*m[8]+m[9]*m[9]+m[10]*m[10]);if(preserveScalingNode){translation=
0>preserveScalingNode.scaling.y?-1:1;const signZ=0>preserveScalingNode.scaling.z?-1:1;scale.x*=0>preserveScalingNode.scaling.x?-1:1;scale.y*=translation;scale.z*=signZ}else 0>=this.determinant()&&(scale.y*=-1);if(0===scale._x||0===scale._y||0===scale._z)return rotation&&rotation.copyFromFloats(0,0,0,1),!1;rotation&&(preserveScalingNode=1/scale._x,translation=1/scale._y,scale=1/scale._z,Matrix.FromValuesToRef(m[0]*preserveScalingNode,m[1]*preserveScalingNode,m[2]*preserveScalingNode,0,m[4]*translation,
m[5]*translation,m[6]*translation,0,m[8]*scale,m[9]*scale,m[10]*scale,0,0,0,0,1,MathTmp.Matrix[0]),Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0],rotation));return!0}getRow(index){if(0>index||3<index)return null;index*=4;return new Vector4(this._m[index+0],this._m[index+1],this._m[index+2],this._m[index+3])}getRowToRef(index,rowVector){0<=index&&3>index&&(index*=4,rowVector.x=this._m[index+0],rowVector.y=this._m[index+1],rowVector.z=this._m[index+2],rowVector.w=this._m[index+3]);return rowVector}setRow(index,
row){return this.setRowFromFloats(index,row.x,row.y,row.z,row.w)}transpose(){const result=new this.constructor;Matrix.TransposeToRef(this,result);return result}transposeToRef(result){Matrix.TransposeToRef(this,result);return result}setRowFromFloats(index,x,y,z,w){if(0>index||3<index)return this;index*=4;this._m[index+0]=x;this._m[index+1]=y;this._m[index+2]=z;this._m[index+3]=w;this.markAsUpdated();return this}scale(scale){const result=new this.constructor;this.scaleToRef(scale,result);return result}scaleToRef(scale,
result){for(let index=0;16>index;index++)result._m[index]=this._m[index]*scale;result.markAsUpdated();return result}scaleAndAddToRef(scale,result){for(let index=0;16>index;index++)result._m[index]+=this._m[index]*scale;result.markAsUpdated();return result}toNormalMatrix(ref){var tmp=MathTmp.Matrix[0];this.invertToRef(tmp);tmp.transposeToRef(ref);tmp=ref._m;Matrix.FromValuesToRef(tmp[0],tmp[1],tmp[2],0,tmp[4],tmp[5],tmp[6],0,tmp[8],tmp[9],tmp[10],0,0,0,0,1,ref);return ref}getRotationMatrix(){const result=
new this.constructor;this.getRotationMatrixToRef(result);return result}getRotationMatrixToRef(result){var scale=MathTmp.Vector3[0];if(!this.decompose(scale))return Matrix.IdentityToRef(result),result;const m=this._m,sx=1/scale._x,sy=1/scale._y;scale=1/scale._z;Matrix.FromValuesToRef(m[0]*sx,m[1]*sx,m[2]*sx,0,m[4]*sy,m[5]*sy,m[6]*sy,0,m[8]*scale,m[9]*scale,m[10]*scale,0,0,0,0,1,result);return result}toggleModelMatrixHandInPlace(){const m=this._m;m[2]*=-1;m[6]*=-1;m[8]*=-1;m[9]*=-1;m[14]*=-1;this.markAsUpdated();
return this}toggleProjectionMatrixHandInPlace(){const m=this._m;m[8]*=-1;m[9]*=-1;m[10]*=-1;m[11]*=-1;this.markAsUpdated();return this}static FromArray(array,offset=0){const result=new Matrix;Matrix.FromArrayToRef(array,offset,result);return result}static FromArrayToRef(array,offset,result){for(let index=0;16>index;index++)result._m[index]=array[index+offset];result.markAsUpdated();return result}static FromFloat32ArrayToRefScaled(array,offset,scale,result){for(let index=0;16>index;index++)result._m[index]=
array[index+offset]*scale;result.markAsUpdated();return result}static get IdentityReadOnly(){return Matrix._IdentityReadOnly}static FromValuesToRef(initialM11,initialM12,initialM13,initialM14,initialM21,initialM22,initialM23,initialM24,initialM31,initialM32,initialM33,initialM34,initialM41,initialM42,initialM43,initialM44,result){const m=result._m;m[0]=initialM11;m[1]=initialM12;m[2]=initialM13;m[3]=initialM14;m[4]=initialM21;m[5]=initialM22;m[6]=initialM23;m[7]=initialM24;m[8]=initialM31;m[9]=initialM32;
m[10]=initialM33;m[11]=initialM34;m[12]=initialM41;m[13]=initialM42;m[14]=initialM43;m[15]=initialM44;result.markAsUpdated()}static FromValues(initialM11,initialM12,initialM13,initialM14,initialM21,initialM22,initialM23,initialM24,initialM31,initialM32,initialM33,initialM34,initialM41,initialM42,initialM43,initialM44){const result=new Matrix,m=result._m;m[0]=initialM11;m[1]=initialM12;m[2]=initialM13;m[3]=initialM14;m[4]=initialM21;m[5]=initialM22;m[6]=initialM23;m[7]=initialM24;m[8]=initialM31;m[9]=
initialM32;m[10]=initialM33;m[11]=initialM34;m[12]=initialM41;m[13]=initialM42;m[14]=initialM43;m[15]=initialM44;result.markAsUpdated();return result}static Compose(scale,rotation,translation){const result=new Matrix;Matrix.ComposeToRef(scale,rotation,translation,result);return result}static ComposeToRef(scale,rotation,translation,result){const m=result._m;var x=rotation._x,y=rotation._y,z=rotation._z,w=rotation._w,x2=x+x,y2=y+y,z2=z+z;rotation=x*x2;const xy=x*y2;x*=z2;const yy=y*y2;y*=z2;z*=z2;x2*=
w;y2*=w;w*=z2;z2=scale._x;const sy=scale._y;scale=scale._z;m[0]=(1-(yy+z))*z2;m[1]=(xy+w)*z2;m[2]=(x-y2)*z2;m[3]=0;m[4]=(xy-w)*sy;m[5]=(1-(rotation+z))*sy;m[6]=(y+x2)*sy;m[7]=0;m[8]=(x+y2)*scale;m[9]=(y-x2)*scale;m[10]=(1-(rotation+yy))*scale;m[11]=0;m[12]=translation._x;m[13]=translation._y;m[14]=translation._z;m[15]=1;result.markAsUpdated();return result}static Identity(){const identity=Matrix.FromValues(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1);identity._updateIdentityStatus(!0);return identity}static IdentityToRef(result){Matrix.FromValuesToRef(1,
0,0,0,0,1,0,0,0,0,1,0,0,0,0,1,result);result._updateIdentityStatus(!0);return result}static Zero(){const zero=Matrix.FromValues(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);zero._updateIdentityStatus(!1);return zero}static RotationX(angle){const result=new Matrix;Matrix.RotationXToRef(angle,result);return result}static Invert(source){const result=new source.constructor;source.invertToRef(result);return result}static RotationXToRef(angle,result){const s=Math.sin(angle);angle=Math.cos(angle);Matrix.FromValuesToRef(1,
0,0,0,0,angle,s,0,0,-s,angle,0,0,0,0,1,result);result._updateIdentityStatus(1===angle&&0===s);return result}static RotationY(angle){const result=new Matrix;Matrix.RotationYToRef(angle,result);return result}static RotationYToRef(angle,result){const s=Math.sin(angle);angle=Math.cos(angle);Matrix.FromValuesToRef(angle,0,-s,0,0,1,0,0,s,0,angle,0,0,0,0,1,result);result._updateIdentityStatus(1===angle&&0===s);return result}static RotationZ(angle){const result=new Matrix;Matrix.RotationZToRef(angle,result);
return result}static RotationZToRef(angle,result){const s=Math.sin(angle);angle=Math.cos(angle);Matrix.FromValuesToRef(angle,s,0,0,-s,angle,0,0,0,0,1,0,0,0,0,1,result);result._updateIdentityStatus(1===angle&&0===s);return result}static RotationAxis(axis,angle){const result=new Matrix;Matrix.RotationAxisToRef(axis,angle,result);return result}static RotationAxisToRef(axis,angle,result){const s=Math.sin(-angle);angle=Math.cos(-angle);const c1=1-angle;axis.normalize();const m=result._m;m[0]=axis._x*axis._x*
c1+angle;m[1]=axis._x*axis._y*c1-axis._z*s;m[2]=axis._x*axis._z*c1+axis._y*s;m[3]=0;m[4]=axis._y*axis._x*c1+axis._z*s;m[5]=axis._y*axis._y*c1+angle;m[6]=axis._y*axis._z*c1-axis._x*s;m[7]=0;m[8]=axis._z*axis._x*c1-axis._y*s;m[9]=axis._z*axis._y*c1+axis._x*s;m[10]=axis._z*axis._z*c1+angle;m[11]=0;m[12]=0;m[13]=0;m[14]=0;m[15]=1;result.markAsUpdated();return result}static RotationAlignToRef(from,to,result){const c=Vector3.Dot(to,from),m=result._m;c<-1+_mathConstants.Epsilon?(m[0]=-1,m[1]=0,m[2]=0,m[3]=
0,m[4]=0,m[5]=-1,m[6]=0,m[7]=0,m[8]=0,m[9]=0,m[10]=1):(from=Vector3.Cross(to,from),to=1/(1+c),m[0]=from._x*from._x*to+c,m[1]=from._y*from._x*to-from._z,m[2]=from._z*from._x*to+from._y,m[3]=0,m[4]=from._x*from._y*to+from._z,m[5]=from._y*from._y*to+c,m[6]=from._z*from._y*to-from._x,m[7]=0,m[8]=from._x*from._z*to-from._y,m[9]=from._y*from._z*to+from._x,m[10]=from._z*from._z*to+c);m[11]=0;m[12]=0;m[13]=0;m[14]=0;m[15]=1;result.markAsUpdated();return result}static RotationYawPitchRoll(yaw,pitch,roll){const result=
new Matrix;Matrix.RotationYawPitchRollToRef(yaw,pitch,roll,result);return result}static RotationYawPitchRollToRef(yaw,pitch,roll,result){Quaternion.RotationYawPitchRollToRef(yaw,pitch,roll,MathTmp.Quaternion[0]);MathTmp.Quaternion[0].toRotationMatrix(result);return result}static Scaling(x,y,z){const result=new Matrix;Matrix.ScalingToRef(x,y,z,result);return result}static ScalingToRef(x,y,z,result){Matrix.FromValuesToRef(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1,result);result._updateIdentityStatus(1===x&&1===
y&&1===z);return result}static Translation(x,y,z){const result=new Matrix;Matrix.TranslationToRef(x,y,z,result);return result}static TranslationToRef(x,y,z,result){Matrix.FromValuesToRef(1,0,0,0,0,1,0,0,0,0,1,0,x,y,z,1,result);result._updateIdentityStatus(0===x&&0===y&&0===z);return result}static Lerp(startValue,endValue,gradient){const result=new startValue.constructor;Matrix.LerpToRef(startValue,endValue,gradient,result);return result}static LerpToRef(startValue,endValue,gradient,result){const resultM=
result._m;startValue=startValue.m;endValue=endValue.m;for(let index=0;16>index;index++)resultM[index]=startValue[index]*(1-gradient)+endValue[index]*gradient;result.markAsUpdated();return result}static DecomposeLerp(startValue,endValue,gradient){const result=new startValue.constructor;Matrix.DecomposeLerpToRef(startValue,endValue,gradient,result);return result}static DecomposeLerpToRef(startValue,endValue,gradient,result){var startScale=MathTmp.Vector3[0],startRotation=MathTmp.Quaternion[0];const startTranslation=
MathTmp.Vector3[1];startValue.decompose(startScale,startRotation,startTranslation);const endScale=MathTmp.Vector3[2],endRotation=MathTmp.Quaternion[1];startValue=MathTmp.Vector3[3];endValue.decompose(endScale,endRotation,startValue);endValue=MathTmp.Vector3[4];Vector3.LerpToRef(startScale,endScale,gradient,endValue);startScale=MathTmp.Quaternion[2];Quaternion.SlerpToRef(startRotation,endRotation,gradient,startScale);startRotation=MathTmp.Vector3[5];Vector3.LerpToRef(startTranslation,startValue,gradient,
startRotation);Matrix.ComposeToRef(endValue,startScale,startRotation,result);return result}static LookAtLH(eye,target,up){const result=new Matrix;Matrix.LookAtLHToRef(eye,target,up,result);return result}static LookAtLHToRef(eye,target,up,result){const xAxis=MathTmp.Vector3[0],yAxis=MathTmp.Vector3[1],zAxis=MathTmp.Vector3[2];target.subtractToRef(eye,zAxis);zAxis.normalize();Vector3.CrossToRef(up,zAxis,xAxis);target=xAxis.lengthSquared();0===target?xAxis.x=1:xAxis.normalizeFromLength(Math.sqrt(target));
Vector3.CrossToRef(zAxis,xAxis,yAxis);yAxis.normalize();target=-Vector3.Dot(xAxis,eye);up=-Vector3.Dot(yAxis,eye);eye=-Vector3.Dot(zAxis,eye);Matrix.FromValuesToRef(xAxis._x,yAxis._x,zAxis._x,0,xAxis._y,yAxis._y,zAxis._y,0,xAxis._z,yAxis._z,zAxis._z,0,target,up,eye,1,result)}static LookAtRH(eye,target,up){const result=new Matrix;Matrix.LookAtRHToRef(eye,target,up,result);return result}static LookAtRHToRef(eye,target,up,result){const xAxis=MathTmp.Vector3[0],yAxis=MathTmp.Vector3[1],zAxis=MathTmp.Vector3[2];
eye.subtractToRef(target,zAxis);zAxis.normalize();Vector3.CrossToRef(up,zAxis,xAxis);target=xAxis.lengthSquared();0===target?xAxis.x=1:xAxis.normalizeFromLength(Math.sqrt(target));Vector3.CrossToRef(zAxis,xAxis,yAxis);yAxis.normalize();target=-Vector3.Dot(xAxis,eye);up=-Vector3.Dot(yAxis,eye);eye=-Vector3.Dot(zAxis,eye);Matrix.FromValuesToRef(xAxis._x,yAxis._x,zAxis._x,0,xAxis._y,yAxis._y,zAxis._y,0,xAxis._z,yAxis._z,zAxis._z,0,target,up,eye,1,result);return result}static LookDirectionLH(forward,
up){const result=new Matrix;Matrix.LookDirectionLHToRef(forward,up,result);return result}static LookDirectionLHToRef(forward,up,result){const back=MathTmp.Vector3[0];back.copyFrom(forward);back.scaleInPlace(-1);forward=MathTmp.Vector3[1];Vector3.CrossToRef(up,back,forward);Matrix.FromValuesToRef(forward._x,forward._y,forward._z,0,up._x,up._y,up._z,0,back._x,back._y,back._z,0,0,0,0,1,result);return result}static LookDirectionRH(forward,up){const result=new Matrix;Matrix.LookDirectionRHToRef(forward,
up,result);return result}static LookDirectionRHToRef(forward,up,result){const right=MathTmp.Vector3[2];Vector3.CrossToRef(up,forward,right);Matrix.FromValuesToRef(right._x,right._y,right._z,0,up._x,up._y,up._z,0,forward._x,forward._y,forward._z,0,0,0,0,1,result);return result}static OrthoLH(width,height,znear,zfar,halfZRange){const matrix=new Matrix;Matrix.OrthoLHToRef(width,height,znear,zfar,matrix,halfZRange);return matrix}static OrthoLHToRef(width,height,znear,zfar,result,halfZRange){width=2/width;
height=2/height;const c=2/(zfar-znear);znear=-(zfar+znear)/(zfar-znear);Matrix.FromValuesToRef(width,0,0,0,0,height,0,0,0,0,c,0,0,0,znear,1,result);halfZRange&&result.multiplyToRef(mtxConvertNDCToHalfZRange,result);result._updateIdentityStatus(1===width&&1===height&&1===c&&0===znear);return result}static OrthoOffCenterLH(left,right,bottom,top,znear,zfar,halfZRange){const matrix=new Matrix;Matrix.OrthoOffCenterLHToRef(left,right,bottom,top,znear,zfar,matrix,halfZRange);return matrix}static OrthoOffCenterLHToRef(left,
right,bottom,top,znear,zfar,result,halfZRange){Matrix.FromValuesToRef(2/(right-left),0,0,0,0,2/(top-bottom),0,0,0,0,2/(zfar-znear),0,(left+right)/(left-right),(top+bottom)/(bottom-top),-(zfar+znear)/(zfar-znear),1,result);halfZRange&&result.multiplyToRef(mtxConvertNDCToHalfZRange,result);result.markAsUpdated();return result}static OrthoOffCenterRH(left,right,bottom,top,znear,zfar,halfZRange){const matrix=new Matrix;Matrix.OrthoOffCenterRHToRef(left,right,bottom,top,znear,zfar,matrix,halfZRange);return matrix}static OrthoOffCenterRHToRef(left,
right,bottom,top,znear,zfar,result,halfZRange){Matrix.OrthoOffCenterLHToRef(left,right,bottom,top,znear,zfar,result,halfZRange);result._m[10]*=-1;return result}static PerspectiveLH(width,height,znear,zfar,halfZRange,projectionPlaneTilt=0){const matrix=new Matrix;Matrix.FromValuesToRef(2*znear/width,0,0,0,0,2*znear/height,0,Math.tan(projectionPlaneTilt),0,0,(zfar+znear)/(zfar-znear),1,0,0,-2*zfar*znear/(zfar-znear),0,matrix);halfZRange&&matrix.multiplyToRef(mtxConvertNDCToHalfZRange,matrix);matrix._updateIdentityStatus(!1);
return matrix}static PerspectiveFovLH(fov,aspect,znear,zfar,halfZRange,projectionPlaneTilt=0,reverseDepthBufferMode=!1){const matrix=new Matrix;Matrix.PerspectiveFovLHToRef(fov,aspect,znear,zfar,matrix,!0,halfZRange,projectionPlaneTilt,reverseDepthBufferMode);return matrix}static PerspectiveFovLHToRef(fov,aspect,znear,zfar,result,isVerticalFovFixed=!0,halfZRange,projectionPlaneTilt=0,reverseDepthBufferMode=!1){fov=1/Math.tan(.5*fov);Matrix.FromValuesToRef(isVerticalFovFixed?fov/aspect:fov,0,0,0,0,
isVerticalFovFixed?fov:fov*aspect,0,Math.tan(projectionPlaneTilt),0,0,reverseDepthBufferMode&&0===znear?-1:0!==zfar?(zfar+znear)/(zfar-znear):1,1,0,0,reverseDepthBufferMode&&0===znear?2*zfar:0!==zfar?-2*zfar*znear/(zfar-znear):-2*znear,0,result);halfZRange&&result.multiplyToRef(mtxConvertNDCToHalfZRange,result);result._updateIdentityStatus(!1);return result}static PerspectiveFovReverseLHToRef(fov,aspect,znear,zfar,result,isVerticalFovFixed=!0,halfZRange,projectionPlaneTilt=0){fov=1/Math.tan(.5*fov);
Matrix.FromValuesToRef(isVerticalFovFixed?fov/aspect:fov,0,0,0,0,isVerticalFovFixed?fov:fov*aspect,0,Math.tan(projectionPlaneTilt),0,0,-znear,1,0,0,1,0,result);halfZRange&&result.multiplyToRef(mtxConvertNDCToHalfZRange,result);result._updateIdentityStatus(!1);return result}static PerspectiveFovRH(fov,aspect,znear,zfar,halfZRange,projectionPlaneTilt=0,reverseDepthBufferMode=!1){const matrix=new Matrix;Matrix.PerspectiveFovRHToRef(fov,aspect,znear,zfar,matrix,!0,halfZRange,projectionPlaneTilt,reverseDepthBufferMode);
return matrix}static PerspectiveFovRHToRef(fov,aspect,znear,zfar,result,isVerticalFovFixed=!0,halfZRange,projectionPlaneTilt=0,reverseDepthBufferMode=!1){fov=1/Math.tan(.5*fov);Matrix.FromValuesToRef(isVerticalFovFixed?fov/aspect:fov,0,0,0,0,isVerticalFovFixed?fov:fov*aspect,0,Math.tan(projectionPlaneTilt),0,0,reverseDepthBufferMode&&0===znear?1:0!==zfar?-(zfar+znear)/(zfar-znear):-1,-1,0,0,reverseDepthBufferMode&&0===znear?2*zfar:0!==zfar?-2*zfar*znear/(zfar-znear):-2*znear,0,result);halfZRange&&
result.multiplyToRef(mtxConvertNDCToHalfZRange,result);result._updateIdentityStatus(!1);return result}static PerspectiveFovReverseRHToRef(fov,aspect,znear,zfar,result,isVerticalFovFixed=!0,halfZRange,projectionPlaneTilt=0){fov=1/Math.tan(.5*fov);Matrix.FromValuesToRef(isVerticalFovFixed?fov/aspect:fov,0,0,0,0,isVerticalFovFixed?fov:fov*aspect,0,Math.tan(projectionPlaneTilt),0,0,-znear,-1,0,0,-1,0,result);halfZRange&&result.multiplyToRef(mtxConvertNDCToHalfZRange,result);result._updateIdentityStatus(!1);
return result}static PerspectiveFovWebVRToRef(fov,znear,zfar,result,rightHanded=!1,halfZRange,projectionPlaneTilt=0){const upTan=Math.tan(fov.upDegrees*Math.PI/180),downTan=Math.tan(fov.downDegrees*Math.PI/180),leftTan=Math.tan(fov.leftDegrees*Math.PI/180);fov=Math.tan(fov.rightDegrees*Math.PI/180);const xScale=2/(leftTan+fov),yScale=2/(upTan+downTan);projectionPlaneTilt=Math.tan(projectionPlaneTilt);const m=result._m;m[0]=xScale;m[1]=m[2]=m[3]=m[4]=0;m[5]=yScale;m[6]=0;m[7]=projectionPlaneTilt;m[8]=
(leftTan-fov)*xScale*.5;m[9]=-((upTan-downTan)*yScale*.5);m[10]=-zfar/(znear-zfar);m[11]=rightHanded?-1:1;m[12]=m[13]=m[15]=0;m[14]=-(2*zfar*znear)/(zfar-znear);halfZRange&&result.multiplyToRef(mtxConvertNDCToHalfZRange,result);result.markAsUpdated();return result}static GetFinalMatrix(viewport,world,view,projection,zmin,zmax){const cw=viewport.width,ch=viewport.height;viewport=Matrix.FromValues(cw/2,0,0,0,0,-ch/2,0,0,0,0,zmax-zmin,0,viewport.x+cw/2,ch/2+viewport.y,zmin,1);zmin=new world.constructor;
world.multiplyToRef(view,zmin);zmin.multiplyToRef(projection,zmin);return zmin.multiplyToRef(viewport,zmin)}static GetAsMatrix2x2(matrix){matrix=matrix.m;matrix=[matrix[0],matrix[1],matrix[4],matrix[5]];return _performanceConfigurator.PerformanceConfigurator.MatrixUse64Bits?matrix:new Float32Array(matrix)}static GetAsMatrix3x3(matrix){matrix=matrix.m;matrix=[matrix[0],matrix[1],matrix[2],matrix[4],matrix[5],matrix[6],matrix[8],matrix[9],matrix[10]];return _performanceConfigurator.PerformanceConfigurator.MatrixUse64Bits?
matrix:new Float32Array(matrix)}static Transpose(matrix){const result=new matrix.constructor;Matrix.TransposeToRef(matrix,result);return result}static TransposeToRef(matrix,result){const rm=result._m,mm=matrix.m;rm[0]=mm[0];rm[1]=mm[4];rm[2]=mm[8];rm[3]=mm[12];rm[4]=mm[1];rm[5]=mm[5];rm[6]=mm[9];rm[7]=mm[13];rm[8]=mm[2];rm[9]=mm[6];rm[10]=mm[10];rm[11]=mm[14];rm[12]=mm[3];rm[13]=mm[7];rm[14]=mm[11];rm[15]=mm[15];result.markAsUpdated();result._updateIdentityStatus(matrix._isIdentity,matrix._isIdentityDirty);
return result}static Reflection(plane){const matrix=new Matrix;Matrix.ReflectionToRef(plane,matrix);return matrix}static ReflectionToRef(plane,result){plane.normalize();const x=plane.normal.x,y=plane.normal.y,z=plane.normal.z,temp=-2*x,temp2=-2*y,temp3=-2*z;Matrix.FromValuesToRef(temp*x+1,temp2*x,temp3*x,0,temp*y,temp2*y+1,temp3*y,0,temp*z,temp2*z,temp3*z+1,0,temp*plane.d,temp2*plane.d,temp3*plane.d,1,result);return result}static FromXYZAxesToRef(xaxis,yaxis,zaxis,result){Matrix.FromValuesToRef(xaxis._x,
xaxis._y,xaxis._z,0,yaxis._x,yaxis._y,yaxis._z,0,zaxis._x,zaxis._y,zaxis._z,0,0,0,0,1,result);return result}static FromQuaternionToRef(quat,result){const xx=quat._x*quat._x,yy=quat._y*quat._y,zz=quat._z*quat._z,xy=quat._x*quat._y,zw=quat._z*quat._w,zx=quat._z*quat._x,yw=quat._y*quat._w,yz=quat._y*quat._z;quat=quat._x*quat._w;result._m[0]=1-2*(yy+zz);result._m[1]=2*(xy+zw);result._m[2]=2*(zx-yw);result._m[3]=0;result._m[4]=2*(xy-zw);result._m[5]=1-2*(zz+xx);result._m[6]=2*(yz+quat);result._m[7]=0;
result._m[8]=2*(zx+yw);result._m[9]=2*(yz-quat);result._m[10]=1-2*(yy+xx);result._m[11]=0;result._m[12]=0;result._m[13]=0;result._m[14]=0;result._m[15]=1;result.markAsUpdated();return result}}exports.Matrix=Matrix;Matrix._UpdateFlagSeed=0;Matrix._IdentityReadOnly=Matrix.Identity();class MathTmp{}MathTmp.Vector3=global.ArrayTools.BuildTuple(11,Vector3.Zero);MathTmp.Matrix=global.ArrayTools.BuildTuple(2,Matrix.Identity);MathTmp.Quaternion=global.ArrayTools.BuildTuple(3,Quaternion.Zero);class TmpVectors{}
exports.TmpVectors=TmpVectors;TmpVectors.Vector2=global.ArrayTools.BuildTuple(3,Vector2.Zero);TmpVectors.Vector3=global.ArrayTools.BuildTuple(13,Vector3.Zero);TmpVectors.Vector4=global.ArrayTools.BuildTuple(3,Vector4.Zero);TmpVectors.Quaternion=global.ArrayTools.BuildTuple(2,Quaternion.Zero);TmpVectors.Matrix=global.ArrayTools.BuildTuple(8,Matrix.Identity);(0,module.RegisterClass)("BABYLON.Vector2",Vector2);(0,module.RegisterClass)("BABYLON.Vector3",Vector3);(0,module.RegisterClass)("BABYLON.Vector4",
Vector4);(0,module.RegisterClass)("BABYLON.Matrix",Matrix);const mtxConvertNDCToHalfZRange=Matrix.FromValues(1,0,0,0,0,1,0,0,0,0,.5,0,0,0,.5,1)}
//# sourceMappingURL=module$node_modules$$babylonjs$core$Maths$math_vector.js.map
